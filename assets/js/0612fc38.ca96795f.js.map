{"version":3,"file":"assets/js/0612fc38.ca96795f.js","mappings":"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","sources":["webpack://website/../jui/src/ActionButton/ActionButton.tsx","webpack://website/../jui/src/ActionToolbar/ActionToolbar.tsx","webpack://website/../jui/src/Collections/Divider.ts","webpack://website/../jui/src/Collections/ItemStateContext.tsx","webpack://website/../jui/src/Icon/LafIcon.tsx","webpack://website/../jui/src/Icon/PlatformIcon.tsx","webpack://website/../jui/src/Icon/StyledIconWrapper.tsx","webpack://website/../jui/src/Icon/useSvgIcon.tsx","webpack://website/../jui/src/List/ListDivider.tsx","webpack://website/../jui/src/Menu/StyledMenu.tsx","webpack://website/../jui/src/Menu/StyledMenuItem.tsx","webpack://website/../jui/src/Menu/MenuItem.tsx","webpack://website/../jui/src/Menu/MenuSection.tsx","webpack://website/../jui/src/Menu/Menu.tsx","webpack://website/../jui/src/Menu/MenuItemLayout.tsx","webpack://website/../jui/src/Menu/MenuTrigger.tsx","webpack://website/../jui/src/StyledSeparator.tsx","webpack://website/../jui/src/ToolWindow/FocusScope.tsx","webpack://website/../jui/src/Tree/__tmp__useTreeState.ts","webpack://website/../jui/src/Collections/useCollectionCacheInvalidation.ts","webpack://website/../jui/src/Tree/useTreeRef.tsx","webpack://website/../jui/src/style-constants.ts","webpack://website/../jui/src/styled.ts","webpack://website/../jui/src/utils/useContextOrThrow.tsx","webpack://website/../jui/src/utils/useForwardedRef.ts","webpack://website/../jui/src/utils/useLatest.ts","webpack://website/../jui/src/utils/usePrevious.ts","webpack://website/../jui/src/Menu/Menu.stories.tsx","webpack://website/./docs/components/Menu.mdx","webpack://website/../../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js"],"sourcesContent":["import { PressProps, usePress } from \"@react-aria/interactions\";\nimport React, { ForwardedRef, HTMLProps } from \"react\";\nimport { styled } from \"../styled\";\nimport { mergeProps } from \"@react-aria/utils\";\n\nexport interface ActionButtonProps\n  extends PressProps,\n    // Maybe we should allow any arbitrary HTMLProps<HTMLButtonElement> props, instead of whitelisting?\n    Pick<HTMLProps<HTMLButtonElement>, \"onFocus\" | \"onBlur\"> {\n  children?: React.ReactNode;\n  minSize?: number;\n  /**\n   * Whether the button should be focusable by pressing tab. The default is true for action buttons, which means they\n   * are not included in the tab order.\n   */\n  excludeFromTabOrder?: boolean;\n}\n\nexport const DEFAULT_MINIMUM_BUTTON_SIZE = 22;\nexport const NAVBAR_MINIMUM_BUTTON_SIZE = 20;\n\nexport const StyledActionButton = styled.button<{ minSize: number }>`\n  position: relative; // to allow absolutely positioned overlays like an dropdown icon at the bottom right corner\n  background: none;\n  color: inherit;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  min-height: ${({ minSize }) => `${minSize}px`};\n  min-width: ${({ minSize }) => `${minSize}px`};\n  padding: 0;\n  margin: 0;\n  &:disabled {\n    opacity: 0.25; // not quite accurate implementation. There might be better ways to style disabled state.\n  }\n  &:hover:not(:disabled),\n  &:focus:not(:disabled) /* in intellij platform, the button doesn't grab the focus after being active. This is not the case in web,\n  for better accessibility. But there is no existing UI spec for it in intellij platform obviously. So for now, we\n  fallback to the same UI as hover state. Perhaps it can be improved with a opacity or something.*/ {\n    outline: none;\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBackground\", \"#DFDFDF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBorderColor\", \"#DFDFDF\")};\n  }\n  &:active:not(:disabled),\n  &.active:not(:disabled) {\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBackground\", \"#CFCFCF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBorderColor\", \"#CFCFCF\")};\n  }\n`;\n\nexport const ActionButton = React.forwardRef(function ActionButton(\n  {\n    minSize = DEFAULT_MINIMUM_BUTTON_SIZE,\n    preventFocusOnPress = true,\n    excludeFromTabOrder = true,\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    ...otherProps\n  }: ActionButtonProps,\n  ref: ForwardedRef<HTMLButtonElement>\n) {\n  const { pressProps, isPressed } = usePress({\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    preventFocusOnPress,\n  });\n\n  return (\n    <StyledActionButton\n      className={isPressed ? \"active\" : \"\"}\n      disabled={isDisabled}\n      {...mergeProps(pressProps, otherProps)}\n      minSize={minSize}\n      tabIndex={excludeFromTabOrder && !isDisabled ? -1 : undefined}\n      ref={ref}\n    />\n  );\n});\n","import { Theme } from \"@intellij-platform/core/Theme\";\nimport React, { useContext } from \"react\";\nimport { StyledActionButton } from \"../ActionButton/ActionButton\";\nimport { styled } from \"../styled\";\nimport {\n  StyledHorizontalSeparator,\n  StyledVerticalSeparator,\n} from \"../StyledSeparator\";\n\ninterface ActionToolbarProps {\n  orientation?: \"vertical\" | \"horizontal\";\n  /**\n   * Whether to include a border to the bottom/right the toolbar, or not.\n   */\n  hasBorder?: boolean;\n}\nconst StyledActionToolbar = styled.div`\n  display: flex;\n`;\n\nconst getBorder = ({\n  theme,\n  hasBorder,\n}: {\n  theme: Theme;\n  hasBorder?: boolean;\n}) =>\n  hasBorder\n    ? `1px solid ${theme.color(\n        \"Borders.color\",\n        theme.dark ? \"rgb(50,50,50)\" : \"rgb(192, 192, 192)\"\n      )}`\n    : \"none\";\nconst StyledHorizontalActionToolbar = styled(StyledActionToolbar)<{\n  hasBorder?: boolean;\n}>`\n  padding: 2px;\n  border-bottom: ${getBorder};\n  ${StyledHorizontalSeparator} {\n    margin: 1px 2px;\n  }\n  // NOTE: in the original implementation, there is no empty space between buttons, but buttons have kind of an\n  // invisible left padding, which is mouse-intractable, but doesn't visually seem a part of the button.\n  // Although implementable, it didn't seem necessary to follow the exact same thing. Margin should be fine.\n  ${StyledActionButton} {\n    margin: 0 2px 0 2px;\n  }\n`;\n\nconst StyledVerticalActionToolbar = styled(StyledActionToolbar)<{\n  hasBorder?: boolean;\n}>`\n  flex-direction: column;\n  padding: 0 2px;\n  border-right: ${getBorder};\n\n  ${StyledVerticalSeparator} {\n    margin: 4px 1px;\n  }\n  ${StyledActionButton} {\n    margin: 2px 0 1px 0;\n  }\n`;\n\n// This can be used in other places if use-cases are raised for keeping orientation in the context.\nconst OrientationContext = React.createContext<\"horizontal\" | \"vertical\">(\n  \"horizontal\"\n);\n\n/**\n * Remaining features:\n * - overflow behaviour:\n *   - wrap. like main action toolbar.\n *   - hidden, shown by arrow. Similar to actions in Git->Log. Note that the behaviour for horizontal and vertical\n *     modes are different apparently.\n */\nexport const ActionToolbar: React.FC<ActionToolbarProps> = ({\n  orientation = \"horizontal\",\n  hasBorder = false,\n  children,\n}): React.ReactElement => {\n  return (\n    <OrientationContext.Provider value={orientation}>\n      {orientation === \"horizontal\" ? (\n        <StyledHorizontalActionToolbar hasBorder={hasBorder}>\n          {children}\n        </StyledHorizontalActionToolbar>\n      ) : (\n        <StyledVerticalActionToolbar hasBorder={hasBorder}>\n          {children}\n        </StyledVerticalActionToolbar>\n      )}\n    </OrientationContext.Provider>\n  );\n};\n\n/**\n * Separator to be used between action buttons in an action toolbar.\n */\nexport const ActionToolbarSeparator = (): React.ReactElement => {\n  const orientation = useContext(OrientationContext);\n  return orientation === \"horizontal\" ? (\n    <StyledHorizontalSeparator />\n  ) : (\n    <StyledVerticalSeparator />\n  );\n};\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { ItemProps } from \"@react-types/shared\";\nimport { ReactElement } from \"react\";\nimport { PartialNode } from \"@react-stately/collections\";\n\ninterface DividerProps {}\nfunction Divider({}: DividerProps): ReactElement {\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null as any;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet _Divider = Divider as (props: DividerProps) => JSX.Element;\nexport { _Divider as Divider };\n\nDivider.getCollectionNode = function* getCollectionNode<T>(\n  props: ItemProps<T>\n): Generator<PartialNode<T>> {\n  let rendered = null;\n\n  yield {\n    type: \"divider\",\n    element: null as any, // to prevent check on key, which is not necessary for divider\n    props: props,\n    rendered,\n    hasChildNodes: false,\n  };\n};\n\n/**\n * To be used in dynamic collections, just to provide a key and make it easy to check in the render\n * function to figure out what to render (an Item or a Divider)\n */\nexport class DividerItem {\n  private static seq = 0;\n  key = \"divider_\" + DividerItem.seq++;\n}\n","import React from \"react\";\nimport { Node } from \"@react-types/shared\";\n\n/**\n * Generic state of items in collections, provided via a context.\n * To be used in Menu, Tree, or anything that deals with a collection of items for which the common states like\n * **disabled** or **selected** is applicable.\n */\nexport interface ItemStateContextType {\n  node: Node<unknown>;\n  isSelected: boolean;\n  isFocused: boolean;\n  isDisabled: boolean;\n}\n\nexport const ItemStateContext = React.createContext<ItemStateContextType | null>(\n  null\n);\n","import useForwardedRef from \"@intellij-platform/core/utils/useForwardedRef\";\nimport React, { ForwardedRef } from \"react\";\nimport { useTheme } from \"styled-components\";\nimport { Theme } from \"../Theme/Theme\";\nimport { IconProps } from \"./IconProps\";\nimport { StyledIconWrapper } from \"./StyledIconWrapper\";\nimport { useSvgIcon } from \"./useSvgIcon\";\n\ninterface IconModifiers {\n  Selected?: boolean;\n  Focused?: boolean;\n  Disabled?: boolean;\n  Editable?: boolean;\n  Pressed?: boolean;\n}\n\nexport interface ThemeIconProps extends IconProps {\n  /**\n   * Icon which will be resolved against the default icon location based on theme type\n   */\n  icon: string | { name: string; modifiers: IconModifiers };\n\n  /**\n   * A theme key that can optionally override the icon.\n   */\n  themePath?: string;\n}\n\nconst ICONS_DIR_PREFIX = \"com/intellij/ide/ui/laf/icons/\";\n\n// Similar to LafIconLookup\nfunction findIconPath(\n  theme: Theme,\n  name: string,\n  modifiers: IconModifiers = {}\n) {\n  const basePath = `${ICONS_DIR_PREFIX}${\n    theme.isUnderDarcula() ? \"darcula/\" : \"intellij/\"\n  }`;\n  const suffix = ([\n    \"Editable\",\n    \"Selected\",\n    \"Pressed\",\n    \"Focused\",\n    \"Disabled\",\n  ] as Array<keyof typeof modifiers>).reduce(\n    (soFar, modifier) => soFar + (modifiers[modifier] ? modifier : \"\"),\n    \"\"\n  );\n  return `${basePath}${name}${suffix}.svg`;\n}\n\nfunction useIconPath(\n  iconDescriptor: string | { name: string; modifiers?: IconModifiers },\n  themePath?: string\n) {\n  const theme = useTheme() as Theme; // TODO: investigate why useTheme is typed like this\n  const resolvedValue = themePath && theme.value(themePath);\n  if (resolvedValue) {\n    return resolvedValue;\n  }\n  const { modifiers = {}, name } =\n    typeof iconDescriptor === \"string\"\n      ? { name: iconDescriptor }\n      : iconDescriptor;\n  return findIconPath(theme, name, modifiers);\n}\n\nexport const LafIcon = React.forwardRef(\n  (\n    { themePath, icon, size, ...props }: ThemeIconProps,\n    forwardedRef: ForwardedRef<HTMLElement>\n  ) => {\n    const resolvedIconPath = useIconPath(icon, themePath);\n\n    const ref = useForwardedRef(forwardedRef);\n    useSvgIcon({ path: `platform/platform-impl/src/${resolvedIconPath}` }, ref);\n    return <StyledIconWrapper {...props} ref={ref} size={size} />;\n  }\n);\n","import React, { ForwardedRef } from \"react\";\nimport useForwardedRef from \"@intellij-platform/core/utils/useForwardedRef\";\nimport { useTheme } from \"styled-components\";\nimport { Theme } from \"../Theme/Theme\";\nimport { IconProps } from \"./IconProps\";\nimport { StyledIconWrapper } from \"./StyledIconWrapper\";\nimport { useSvgIcon } from \"./useSvgIcon\";\n\nexport interface PlatformIconProps extends IconProps {\n  icon: string;\n  darkIcon?: string;\n}\n\nexport const amendName = (iconNameOrPath: string, amendment: string) => {\n  const [name, ext] = iconNameOrPath.split(\".\");\n  return `${name}${amendment}${ext ? `.${ext}` : \"\"}`;\n};\n\nexport const getDarkPath = (path: string, darkPath?: string) => {\n  const [name, ext] = path.split(\".\");\n  return darkPath || `${name}_dark${ext ? `.${ext}` : \"\"}`;\n};\n\nconst getPlatformIconPath = (relativePath: string) =>\n  `platform/icons/src/${relativePath}`;\n\n/**\n * Renders an icon from the predefined list of platform icons.\n * icon name must follow the directory structure in platform icons.\n * @example <PlatformIcon icon=\"general/hideToolWindow\" />\n * @example <PlatformIcon icon=\"toolbar/pin\" />\n * @example <PlatformIcon icon=\"toolbar/pin.svg\" />\n */\nexport const PlatformIcon = React.forwardRef(\n  (\n    { icon, darkIcon, ...props }: PlatformIconProps,\n    forwardedRef: ForwardedRef<HTMLElement>\n  ) => {\n    const ref = useForwardedRef(forwardedRef);\n    const theme = useTheme() as Theme; // TODO: investigate why useTheme is typed like this\n    const iconName = theme.dark ? getDarkPath(icon, darkIcon) : icon;\n    useSvgIcon(\n      {\n        path: getPlatformIconPath(iconName),\n        fallbackPath: getPlatformIconPath(icon),\n      },\n      ref\n    );\n\n    return <StyledIconWrapper {...props} ref={ref} />;\n  }\n);\n","import { styled } from \"../styled\";\nimport { IconSize } from \"@intellij-platform/core/Icon/IconProps\";\n\nconst DEFAULT_ICON_SIZE: IconSize = 16;\n\nexport const StyledIconWrapper = styled.span<{\n  size?: IconSize;\n  useCurrentColor?: boolean;\n}>`\n  box-sizing: border-box;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  line-height: 0;\n  width: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  height: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  position: relative; // to allow absolute positioned indicators and overlays on icon\n`;\n","import { RefObject, useEffect } from \"react\";\nimport { useTheme } from \"styled-components\";\nimport { Theme } from \"../Theme/Theme\";\n\nexport function useSvgIcon(\n  { path, fallbackPath }: { path: string; fallbackPath?: string },\n  /**\n   * ref to the icon wrapper element in which the svg should be injected.\n   * This hook used to return svg string, and that svg was set as dangerouslySetInnerHTML. But now it injects the svg.\n   * by direct DOM manipulation. That's to eliminate the need for using dangerouslySetInnerHTML, so that we can allow\n   * arbitrary children (like LiveIndicator) as overlays on top of icons.\n   */\n  ref: RefObject<HTMLElement>\n) {\n  const theme = useTheme() as Theme; // TODO: investigate why useTheme is typed like this\n  useEffect(() => {\n    let unmounted = false;\n    const fetchIcon = async () => {\n      if (!path) {\n        console.error(\"icon path is empty\");\n        return;\n      }\n      if (ref.current) {\n        // For querying for icons that are not loaded yet. Especially useful for visual testing\n        ref.current.dataset.loadingIcon = \"true\";\n      }\n      const svg = await theme.getSvgIcon(path).catch((e) => {\n        if (fallbackPath) {\n          return theme.getSvgIcon(fallbackPath);\n        }\n        throw e;\n      });\n      if (svg) {\n        if (!unmounted && ref?.current) {\n          if (ref) {\n            // potential SSR issues here?\n            ref.current?.querySelector(\"svg\")?.remove();\n            const svgElement = document.createElement(\"svg\");\n            ref.current?.appendChild(svgElement);\n            svgElement.outerHTML = svg;\n            delete ref.current?.dataset.loadingIcon;\n          }\n        }\n      } else {\n        console.error(\"Could not resolve icon:\", path);\n      }\n    };\n    fetchIcon().catch(console.error);\n    return () => {\n      unmounted = true;\n    };\n  }, [path]);\n}\n","import React from \"react\";\nimport { StyledVerticalSeparator } from \"../StyledSeparator\";\nimport { useSeparator } from \"@react-aria/separator\";\n\nexport const ListDivider: React.FC = () => {\n  return (\n    <StyledVerticalSeparator\n      as={\"li\"}\n      {...useSeparator({ orientation: \"vertical\" })}\n    />\n  );\n};\n","import { isMac } from \"@react-aria/utils\";\nimport { css } from \"styled-components\";\nimport { MAC_WINDOW_SHADOW } from \"../style-constants\";\nimport { styled } from \"../styled\";\nimport { StyledVerticalSeparator } from \"../StyledSeparator\";\nimport { Theme, UnknownThemeProp } from \"../Theme/Theme\";\n\nexport const MENU_VERTICAL_PADDING = 5;\nexport const MENU_BORDER_WIDTH = 1;\n\nexport const StyledMenu = styled.ul`\n  font-size: 0.87rem;\n  margin: 0;\n  padding: ${MENU_VERTICAL_PADDING}px 0;\n  outline: none;\n  list-style: none;\n  width: fit-content;\n  min-width: 100px;\n  border: ${MENU_BORDER_WIDTH}px solid\n    ${({ theme }) => theme.color(\"Menu.borderColor\")};\n  ${isMac() &&\n  css<{ theme: Theme }>`\n    ${MAC_WINDOW_SHADOW};\n    border-color: ${({ theme }) =>\n      theme.dark ? \"rgba(0, 0, 0, 0.15)\" : undefined};\n  `}\n  background: ${({ theme }) =>\n    theme.color(\"PopupMenu.background\" as UnknownThemeProp)};\n  color: ${({ theme }) =>\n    theme.color(\"PopupMenu.foreground\" as UnknownThemeProp)};\n\n  ${StyledVerticalSeparator} {\n    background-color: ${({ theme }) =>\n      theme.color(\"Menu.separatorColor\" as UnknownThemeProp)};\n    height: ${({ theme }) =>\n      `${theme.value(\"PopupMenuSeparator.height\" as UnknownThemeProp) ?? 3}px`};\n    padding: ${({ theme }) =>\n      `${\n        theme.value(\"PopupMenuSeparator.stripeIndent\" as UnknownThemeProp) ?? 1\n      }px 0`};\n  }\n`;\n","import { css } from \"styled-components\";\nimport { styled } from \"../styled\";\nimport { UnknownThemeProp } from \"../Theme/Theme\";\n\nexport const StyledMenuItem = styled.li<{\n  isDisabled: boolean;\n  isActive: boolean;\n}>`\n  position: relative; // for being able to position arrow icon absolutely\n  outline: none;\n  cursor: default;\n  white-space: nowrap;\n  color: ${({ isActive, isDisabled, theme }) => {\n    if (isDisabled) {\n      return theme.color(\"MenuItem.disabledForeground\");\n    }\n    if (isActive) {\n      return theme.color(\"MenuItem.selectionForeground\" as UnknownThemeProp);\n    }\n    return theme.color(\"MenuItem.foreground\" as UnknownThemeProp);\n  }};\n  ${({ isActive, theme }) =>\n    isActive &&\n    css`\n      background: ${theme.color(\n        \"MenuItem.selectionBackground\" as UnknownThemeProp\n      )};\n      color: ${undefined};\n      // Kind of a solution for hard coded fill values in svg icons. Is there a better approaches?\n      svg {\n        filter: brightness(2);\n      }\n    `}\n  // would be nice to have a visual clue for focus visible state, but it's not like that in intellij platform\n  //border-left: 3px solid transparent;\n  //&:focus-visible {\n  //  border-left: 3px solid rgba(255, 255, 255, 0.1);\n  //}\n  padding: 0 20px 0 27px;\n  line-height: 1.35; // to make the item have the right height\n  display: flex;\n  align-items: center;\n`;\n","import { useHover, useKeyboard } from \"@react-aria/interactions\";\nimport { useMenuItem } from \"@react-aria/menu\";\nimport { OverlayContainer, useOverlayPosition } from \"@react-aria/overlays\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { Item } from \"@react-stately/collections\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { Node } from \"@react-types/shared\";\nimport React, { Key } from \"react\";\nimport { ItemStateContext } from \"../Collections/ItemStateContext\";\nimport { LafIcon, PlatformIcon } from \"../Icon\";\n\nimport { styled } from \"../styled\";\nimport { FocusScope } from \"../ToolWindow/FocusScope\";\nimport { Menu } from \"./Menu\";\nimport { MENU_BORDER_WIDTH, MENU_VERTICAL_PADDING } from \"./StyledMenu\";\nimport { StyledMenuItem } from \"./StyledMenuItem\";\n\nexport interface MenuItemProps<T> {\n  item: Node<T>;\n  state: TreeState<T>;\n  onAction?: (key: Key) => void;\n  onSubmenuClose?: () => void;\n  expandOn?: \"hover\" | \"press\";\n}\n\nconst StyledNestedArrow = styled.span`\n  margin-right: -11px;\n  margin-left: 11px;\n  display: inline-flex; // to make it not take more height than the icon\n`;\n\nconst StyledSelectedMark = styled.span`\n  position: absolute;\n  left: 4px;\n  top: 50%;\n  transform: translateY(-50%);\n  display: inline-flex; // to make it not take more height than the icon\n`;\n\nconst StyledMenuItemText = styled.span`\n  flex: 1;\n`;\n\nexport function MenuItem<T>({\n  item,\n  state,\n  onAction,\n  expandOn,\n}: MenuItemProps<T>) {\n  // Get props for the menu item element\n  const ref = React.useRef<HTMLLIElement>(null);\n  const nestedMenuRef = React.useRef<HTMLDivElement>(null);\n  const isDisabled = state.disabledKeys.has(item.key);\n  const isExpanded = state.expandedKeys.has(item.key);\n  const isSelected = state.selectionManager.selectedKeys.has(item.key);\n  const isFocused = state.selectionManager.focusedKey === item.key;\n\n  const { menuItemProps } = useMenuItem(\n    {\n      key: item.key,\n      isDisabled,\n      onAction: !item.hasChildNodes ? onAction : undefined,\n    },\n    state,\n    ref\n  );\n\n  const maybeOpenSubmenu = () => {\n    // Not the best way to clear expandedKeys, but current implementation of tree state only allows toggling keys\n    state.expandedKeys.forEach((key) => {\n      state.toggleKey(key);\n    });\n    if (item.hasChildNodes) {\n      state.toggleKey(item.key);\n    }\n  };\n\n  const { hoverProps } = useHover({\n    isDisabled: isDisabled || expandOn !== \"hover\",\n    onHoverStart: () => {\n      maybeOpenSubmenu();\n    },\n  });\n\n  const { keyboardProps } = useKeyboard({\n    onKeyDown: (e) => {\n      if ([\"ArrowRight\", \"Enter\", \" \"].includes(e.key)) {\n        maybeOpenSubmenu();\n      } else {\n        e.continuePropagation();\n      }\n    },\n  });\n\n  let { overlayProps: positionProps } = useOverlayPosition({\n    targetRef: ref,\n    overlayRef: nestedMenuRef,\n    placement: \"right top\",\n    shouldFlip: true,\n    onClose: () => {\n      console.log(\"on close\");\n    },\n    offset: 0,\n    crossOffset: -(MENU_VERTICAL_PADDING + MENU_BORDER_WIDTH),\n    isOpen: isExpanded,\n  });\n\n  const { subMenuProps } = useSubmenu({\n    onClose: () => {\n      state.toggleKey(item.key);\n      // setting focus with selection manager didn't work. Perhaps because of patchy implementation of nested menus\n      ref.current?.focus();\n    },\n  });\n\n  return (\n    <>\n      <StyledMenuItem\n        {...mergeProps(menuItemProps, hoverProps, keyboardProps)}\n        isDisabled={isDisabled}\n        isActive={isFocused}\n        ref={ref}\n      >\n        {isSelected && (\n          <StyledSelectedMark>\n            <LafIcon\n              icon={{\n                name: \"checkmark\",\n                modifiers: { Selected: isFocused },\n              }}\n            />\n          </StyledSelectedMark>\n        )}\n        <ItemStateContext.Provider\n          value={{ isDisabled, isFocused, isSelected, node: item }}\n        >\n          {typeof item.rendered === \"string\" ? (\n            <StyledMenuItemText>{item.rendered}</StyledMenuItemText>\n          ) : (\n            item.rendered\n          )}\n        </ItemStateContext.Provider>\n        {item.hasChildNodes && (\n          <StyledNestedArrow>\n            <PlatformIcon icon=\"icons/ide/menuArrow\" />\n          </StyledNestedArrow>\n        )}\n      </StyledMenuItem>\n      {isExpanded && (\n        /**\n         * A note about using OverlayContainer and FocusScope here:\n         * If sub-menu is not rendered in a portal, useOverlayPosition doesn't work properly and the submenu may\n         * be rendered offscreen. Worse, it may introduce scroll in body (or some scrollable ancestor), which will\n         * trigger a scroll event which closes the menu if the menu is rendered in an overlay (like in MenuTrigger),\n         * which is almost always the case.\n         * So we need to render in a portal and that's done by OverlayContainer. We also need to render a FocusScope,\n         * because now that we are rendering in a portal, we are dom-wise outside the focus scope of the menu in\n         * MenuTrigger (or any other implementation that renders menu in an overlay with a focus scope), and therefore\n         * the auto focus behaviour for the nested menu doesn't work. That's because FocusScope works based on dom\n         * tree, not react tree. Although it's not clear why this problem persists while `contain` is not set on the\n         * FocusScope in MenuTrigger.\n         * So we need focus scope. Rendering a FocusScope here messes with the `restoreFocus` behaviour of the one\n         * in MenuTrigger, and that's why `forceRestoreFocus` is introduced in the locally implemented FocusScope.\n         * In a nutshell:\n         * Positioning -> need for OverlayContainer\n         * using OverlayContainer -> need for FocusScope\n         * FocusScope -> problem in focus restoration in MenuTrigger -> forceRestoreFocus as a patchy solution.\n         */\n        <OverlayContainer>\n          <FocusScope>\n            <div\n              ref={nestedMenuRef}\n              {...mergeProps(positionProps, subMenuProps)}\n            >\n              <Menu\n                aria-label={item[\"aria-label\"] || item.textValue}\n                items={item.childNodes}\n                disabledKeys={state.disabledKeys}\n                selectedKeys={state.selectionManager.selectedKeys}\n                onAction={onAction}\n                autoFocus\n              >\n                {(childItem) => {\n                  // FIXME: This is not complete and doesn't support section and divider\n                  return (\n                    <Item\n                      childItems={childItem.childNodes}\n                      hasChildItems={childItem.hasChildNodes}\n                      textValue={childItem.textValue}\n                    >\n                      {childItem.rendered}\n                    </Item>\n                  );\n                }}\n              </Menu>\n            </div>\n          </FocusScope>\n        </OverlayContainer>\n      )}\n    </>\n  );\n}\n\nconst useSubmenu = ({ onClose }: { onClose: () => void }) => {\n  const { keyboardProps } = useKeyboard({\n    onKeyDown: (e) => {\n      if (e.key === \"ArrowLeft\" || e.key === \"Escape\") {\n        onClose();\n      } else if (![\"ArrowUp\", \"ArrowDown\"].includes(e.key)) {\n        e.continuePropagation();\n      }\n    },\n  });\n  return { subMenuProps: keyboardProps };\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React, { Key } from \"react\";\nimport { useMenuSection } from \"@react-aria/menu\";\nimport { MenuItem } from \"@intellij-platform/core/Menu/MenuItem\";\nimport { Node } from \"@react-types/shared\";\nimport { TreeState } from \"@react-stately/tree\";\n\nexport interface MenuSectionProps<T> {\n  item: Node<T>;\n  state: TreeState<T>;\n  onAction?: (key: Key) => void;\n  expandOn?: \"hover\" | \"press\";\n}\n\nconst StyledMenuHeading = styled.li`\n  cursor: default;\n  padding: 2px 0 2px 12px;\n  color: ${({ theme }) =>\n    theme.color(\n      \"MenuItem.disabledForeground\"\n    )}; // TODO: make sure about it. It's probably not correct color\n`;\n\nconst StyledMenuSectionItemsContainer = styled.ul`\n  padding: 0;\n  margin: 0;\n`;\n\nexport const MenuSection = <T extends unknown>({\n  item,\n  state,\n  onAction,\n  expandOn,\n}: MenuSectionProps<T>): React.ReactElement => {\n  let { itemProps, headingProps, groupProps } = useMenuSection({\n    heading: item.rendered,\n    \"aria-label\": item[\"aria-label\"],\n  });\n\n  return (\n    <>\n      <li {...itemProps}>\n        {item.rendered && (\n          <StyledMenuHeading {...headingProps}>\n            {item.rendered}\n          </StyledMenuHeading>\n        )}\n        <StyledMenuSectionItemsContainer {...groupProps}>\n          {[...item.childNodes].map((node) => {\n            return (\n              <MenuItem\n                key={node.key}\n                item={node}\n                state={state}\n                onAction={onAction}\n                expandOn={expandOn}\n              />\n            );\n          })}\n        </StyledMenuSectionItemsContainer>\n      </li>\n    </>\n  );\n};\n","import { useMenu } from \"@react-aria/menu\";\nimport { AriaMenuProps } from \"@react-types/menu\";\nimport { Node } from \"@react-types/shared\";\nimport React, { Key, useEffect } from \"react\";\nimport { ListDivider } from \"../List/ListDivider\";\nimport { useTreeState } from \"../Tree/__tmp__useTreeState\";\nimport { MenuItem } from \"./MenuItem\";\nimport { StyledMenu } from \"./StyledMenu\";\nimport { MenuSection } from \"@intellij-platform/core/Menu/MenuSection\";\n\nexport interface MenuProps<T>\n  extends Omit<\n    AriaMenuProps<T>,\n    // selection is not properly supported for nested menus. Plus, it's not even that meaningful for a nested menu\n    // at least the way it's implemented now.\n    \"onSelectionChange\" | \"defaultSelection\" | \"selectionMode\"\n  > {\n  /**\n   * Indicates currently expanded menu item (controlled).\n   */\n  expandedKey?: Key;\n  /**\n   * Called when expanded menu item is changed by user interaction, which can be either hovering over the menu item\n   * if `expandOn` is \"focus\", or clicking on the menu item (when `expandOn` is \"press\").\n   */\n  onExpandedKeyChange?: (expandedKey: Key) => void;\n  defaultExpandedKey?: Key;\n  expandOn?: \"hover\" | \"press\"; // hover delay doesn't seem to be needed as an option\n}\n\n/**\n * UI for menus which are normally shown in a popover. Being rendered as an overlay is not handled here.\n * Also there is no coupling with any higher level entity like \"Action\", since this is just for the UI layer.\n * Something like ActionMenu which creates a menu out of a list of actions can be implemented on top of this.\n *\n * @example\n *  <Menu>\n *    <Item>Item one</Item>\n *    <Item>\n *      <MenuItemLayout\n *        icon={<PlatformIcon icon={\"actions/copy\"} />}\n *        content=\"Copy\"\n *        shortcut={\"âŒ˜C\"} />\n *    </Item>\n *  </Menu>\n *\n *  Current issues and limitations:\n *  - Divider in sub-menu's is not supported. because of a constraint in @react-stately/collections, which results in\n *    this error: Unsupported type <Divider> in <Item>. Only <Item> is supported. Maybe supporting section would\n *    be a workaround for it.\n *  - when a parent menu item which has an open submenu is hovered, it gets focus.\n *\n *  TODO:\n *  - [Least important] pass aria props to icon, keyboard shortcut, and content part of menu item. Maybe a context\n *    can be provided for it from menu item, which also exposes state like selected.\n */\nexport function Menu<T extends object>({\n  expandOn = \"hover\",\n  ...props\n}: MenuProps<T>) {\n  if (expandOn === \"press\") {\n    // The only discovered use case so far is in \"Branches\" menu. Perhaps it's not even implemented as a Menu\n    // in Intellij Platform, but it seems it very well can be, by supporting expand on press.\n    throw new Error(\"expanding menu items only on press is not supported yet.\");\n  }\n  // Create state based on the incoming props\n  let state = useTreeState({\n    ...props,\n    expandedKeys: props.expandedKey ? [props.expandedKey] : undefined,\n    onExpandedChange: ([firstKey]) => props?.onExpandedKeyChange?.(firstKey),\n    defaultExpandedKeys: props.defaultExpandedKey\n      ? [props.defaultExpandedKey]\n      : undefined,\n  });\n\n  // Get props for the menu element\n  let ref = React.useRef<HTMLUListElement>(null);\n  let { menuProps } = useMenu(props, state, ref);\n\n  useEffect(() => {\n    if (props.autoFocus) {\n      setTimeout(() => {\n        // we need this hack until the nested menu is properly supported. That's because when the element is hovered\n        // it sets the focus key, which will move focus to that item.\n        ref.current?.focus();\n      });\n    }\n  }, [props.autoFocus]);\n  return (\n    <StyledMenu {...menuProps} ref={ref}>\n      {[...state.collection].map((item: Node<T>) => {\n        switch (item.type) {\n          case \"item\":\n            return (\n              <MenuItem\n                key={item.key}\n                item={item}\n                state={state}\n                expandOn={expandOn}\n                onAction={props.onAction}\n              />\n            );\n          case \"section\":\n            // Maybe something like \"Branches\" menu needs titled sections.\n            return (\n              <MenuSection\n                key={item.key}\n                item={item}\n                state={state}\n                expandOn={expandOn}\n                onAction={props.onAction}\n              />\n            );\n          case \"divider\":\n            return <ListDivider key={item.key} />;\n        }\n      })}\n    </StyledMenu>\n  );\n}\n","import React from \"react\";\nimport { ItemStateContext } from \"../Collections/ItemStateContext\";\nimport { styled } from \"../styled\";\nimport { UnknownThemeProp } from \"../Theme/Theme\";\nimport { useContextOrThrow } from \"../utils/useContextOrThrow\";\n\ninterface MenuItemLayoutProps {\n  icon?: React.ReactNode;\n  content: React.ReactNode;\n  shortcut?: React.ReactNode;\n}\n\nconst StyledMenuItemLayout = styled.div`\n  display: flex;\n  align-items: center;\n  flex: 1; // to make sure it takes as much space as available in the menu item row, so that the suffix (shortcut) is pushed to the right\n`;\nconst Content = styled.span`\n  flex: 1;\n`;\n\nconst Icon = styled.span`\n  display: inline-flex; // prevents unwanted increased height\n  min-width: 16px;\n  margin-right: 5px;\n  margin-left: -21px;\n`;\n\nconst Shortcut = styled.kbd<{ selected: boolean }>`\n  font-family: system-ui, sans-serif;\n  margin-left: 30px;\n  color: ${({ theme, selected }) =>\n    selected\n      ? theme.color(\"MenuItem.selectionForeground\" as UnknownThemeProp)\n      : theme.color(\"MenuItem.acceleratorForeground\")};\n`;\n\nexport const MenuItemLayout = ({\n  content,\n  shortcut,\n  icon,\n}: MenuItemLayoutProps) => {\n  const { isFocused, isSelected } = useContextOrThrow(\n    ItemStateContext,\n    \"MenuItemLayout is meant to be rendered in Item component in Menus\"\n  );\n  return (\n    <StyledMenuItemLayout>\n      <Icon>{!isSelected && icon}</Icon>\n      <Content>{content}</Content>\n      {shortcut && <Shortcut selected={isFocused}>{shortcut}</Shortcut>}\n    </StyledMenuItemLayout>\n  );\n};\n","import { useButton } from \"@react-aria/button\";\nimport { useMenuTrigger } from \"@react-aria/menu\";\nimport {\n  OverlayContainer,\n  useOverlay,\n  useOverlayPosition,\n} from \"@react-aria/overlays\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { useMenuTriggerState } from \"@react-stately/menu\";\nimport { MenuTriggerProps as AriaMenuTriggerProps } from \"@react-types/menu\";\nimport React, { HTMLProps, RefObject } from \"react\";\nimport { FocusScope } from \"../ToolWindow/FocusScope\";\n\nexport interface MenuTriggerProps extends AriaMenuTriggerProps {\n  restoreFocus?: boolean;\n  children: (\n    props: HTMLProps<HTMLElement>,\n    ref: RefObject<any> // Using a generic didn't seem to work for some reason\n  ) => React.ReactNode;\n  renderMenu: (props: {\n    close: () => void;\n    menuProps: React.HTMLAttributes<HTMLElement>;\n  }) => React.ReactNode;\n}\n\n// FIXME: closeOnSelect should either work or be removed\n// FIXME: Escape doesn't close the menu\n// FIXME: Focus is not restored if nested menu are opened. It may be solved by using useOverlay and closing submenu in click outside.\n// TODO: introduce a more generic Overlay component and use it here too.\nexport const MenuTrigger: React.FC<MenuTriggerProps> = ({\n  children,\n  renderMenu,\n  direction = \"bottom\",\n  align = \"start\",\n  shouldFlip = true,\n  restoreFocus = false,\n  ...otherProps\n}) => {\n  const menuTriggerProps: AriaMenuTriggerProps = {\n    ...otherProps,\n    direction,\n    align,\n    shouldFlip,\n  };\n  let state = useMenuTriggerState(menuTriggerProps);\n  let triggerRef = React.useRef(null);\n  let overlayRef = React.useRef(null);\n  // FIXME: Menu props is not used, but it's just about labelBy and id. Only needed for accessibility, but it would\n  //  require a `renderMenu` prop, instead of `menu`.\n  let { menuTriggerProps: triggerProps, menuProps } = useMenuTrigger(\n    { type: \"menu\" },\n    state,\n    triggerRef\n  );\n  let { buttonProps } = useButton(triggerProps, triggerRef);\n  let { overlayProps } = useOverlay(\n    {\n      onClose: () => {\n        return state.close();\n      },\n      shouldCloseOnBlur: false,\n      isOpen: state.isOpen,\n      isKeyboardDismissDisabled: false,\n      isDismissable: true,\n      shouldCloseOnInteractOutside: (element) => {\n        // FIXME: this is kind of hacky and should be removed when nested menu is properly supported\n        return !element.matches(\"[role=menu] *\");\n      },\n    },\n    overlayRef\n  );\n\n  let { overlayProps: positionProps } = useOverlayPosition({\n    targetRef: triggerRef,\n    overlayRef,\n    placement: getPlacement(direction, align),\n    shouldFlip,\n    offset: 0,\n    containerPadding: 0,\n    isOpen: state.isOpen,\n  });\n\n  return (\n    <>\n      {children(buttonProps, triggerRef)}\n      {state.isOpen && (\n        <OverlayContainer>\n          <FocusScope\n            restoreFocus={restoreFocus}\n            forceRestoreFocus={restoreFocus}\n            autoFocus\n          >\n            <div {...mergeProps(overlayProps, positionProps)} ref={overlayRef}>\n              {renderMenu({ menuProps, close: () => state.close() })}\n            </div>\n          </FocusScope>\n        </OverlayContainer>\n      )}\n    </>\n  );\n};\n\nfunction getPlacement(\n  direction: Required<AriaMenuTriggerProps>[\"direction\"],\n  align: Required<AriaMenuTriggerProps>[\"align\"]\n) {\n  switch (direction) {\n    case \"left\":\n    case \"right\":\n    case \"start\":\n    case \"end\":\n      return `${direction} ${align === \"end\" ? \"bottom\" : \"top\"}` as const;\n    case \"bottom\":\n    case \"top\":\n    default:\n      return `${direction} ${align}` as const;\n  }\n}\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nconst StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","import {\n  FocusManager,\n  focusSafely,\n  FocusScope as WrappedFocusScope,\n  FocusScopeProps,\n  useFocusManager,\n} from \"@react-aria/focus\";\nimport React, {\n  ForwardedRef,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n} from \"react\";\n\ntype BetterFocusScopeProps = FocusScopeProps & {\n  /**\n   *\n   */\n  forceRestoreFocus?: boolean;\n};\n/**\n * A version of FocusScope which also allows for imperatively moving focus to the scope.\n * and has tiny patches/improvements\n * It's useful for\n */\nexport const FocusScope = React.forwardRef(function BetterFocusScope(\n  { children, forceRestoreFocus, ...otherProps }: BetterFocusScopeProps,\n  ref: ForwardedRef<{ focus: () => void }>\n) {\n  const directChildRef = useRef<HTMLSpanElement>(null);\n  const focusManagerRef = useRef<FocusManager>(null);\n  useForceRestoreFocus(forceRestoreFocus);\n  useImperativeHandle(\n    ref,\n    () => ({\n      focus: () => {\n        const focusManager = focusManagerRef.current;\n        const containerElement = directChildRef.current?.parentElement;\n        if (!focusManager) {\n          throw new Error(\"focus manager not found!\");\n        }\n        if (!containerElement) {\n          throw new Error(\"container element not found\");\n        }\n        const alreadyHasFocused =\n          document.activeElement &&\n          document.activeElement !== containerElement &&\n          containerElement.contains(document.activeElement);\n        if (!alreadyHasFocused) {\n          focusManager.focusNext({ tabbable: true });\n        }\n      },\n    }),\n    []\n  );\n\n  return (\n    <WrappedFocusScope {...otherProps}>\n      <GetFocusManager ref={focusManagerRef} />\n      <span data-focus-root-direct-child=\"\" hidden ref={directChildRef} />\n      {children}\n    </WrappedFocusScope>\n  );\n});\nconst GetFocusManager = React.forwardRef(function FocusScopeHandle(\n  props: {},\n  ref: ForwardedRef<FocusManager>\n) {\n  const focusManager = useFocusManager();\n  useImperativeHandle(ref, () => focusManager, [focusManager]);\n  return null;\n});\n\n/**\n * Kind of a patchy solution for focus restoration when currently focused element is in a different focus scope, but\n * we still want focus restoration to work. So far the only use case is in nested menu, which is rendered as a separate\n * overlay with a focus scope. If focus is within that submenu, when the menu is closed, the default `restoreFocus`\n * doesn't work because there is a check in useRestoreFocus, which requires the currently focused element to be in\n * the focus scope, to do the focus restoration:\n * https://github.com/adobe/react-spectrum/blob/e14523fedd93ac1a4ede355aed70988af572ae74/packages/%40react-aria/focus/src/FocusScope.tsx#L460\n */\nfunction useForceRestoreFocus(restoreFocus?: boolean) {\n  useLayoutEffect(() => {\n    let nodeToRestore = document.activeElement as HTMLElement;\n\n    return () => {\n      if (restoreFocus && nodeToRestore) {\n        requestAnimationFrame(() => {\n          if (document.body.contains(nodeToRestore)) {\n            focusSafely(nodeToRestore);\n          }\n        });\n      }\n    };\n  }, [restoreFocus]);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n//@ts-nocheck\n\n/**\n * IMPORTANT: this is coppied from react spectrum, temporarily until,\n * https://github.com/adobe/react-spectrum/issues/1525 is fixed. Any version above 3.1.3 should be\n * sufficient to remove this copy and use the one from @react-stately/tree\n */\n\nimport {\n  Collection,\n  CollectionBase,\n  Expandable,\n  MultipleSelection,\n  Node,\n} from \"@react-types/shared\";\nimport { TreeRef, useTreeRef } from \"@intellij-platform/core/Tree/useTreeRef\";\nimport { ForwardedRef, Key, useEffect, useMemo } from \"react\";\nimport {\n  SelectionManager,\n  useMultipleSelectionState,\n} from \"@react-stately/selection\";\nimport { useCollection } from \"@react-stately/collections\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport {\n  CollectionCacheInvalidationProps,\n  useCollectionCacheInvalidation,\n} from \"@intellij-platform/core/Collections/useCollectionCacheInvalidation\";\n\nexport class TreeCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(\n    nodes: Iterable<Node<T>>,\n    { expandedKeys }: { expandedKeys?: Set<Key> } = {}\n  ) {\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (\n        node.childNodes &&\n        (node.type === \"section\" || expandedKeys.has(node.key))\n      ) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === \"item\") {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n}\n\nexport interface TreeProps<T>\n  extends CollectionBase<T>,\n    Expandable,\n    MultipleSelection,\n    CollectionCacheInvalidationProps {}\nexport interface TreeState<T> {\n  /** A collection of items in the tree. */\n  readonly collection: Collection<Node<T>>;\n\n  /** A set of keys for items that are disabled. */\n  readonly disabledKeys: Set<Key>;\n\n  /** A set of keys for items that are expanded. */\n  readonly expandedKeys: Set<Key>;\n\n  /** Toggles the expanded state for an item by its key. */\n  toggleKey(key: Key): void;\n\n  /** A selection manager to read and update multiple selection state. */\n  readonly selectionManager: SelectionManager;\n}\n\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n */\nexport function useTreeState<T extends object, C>(\n  props: TreeProps<T>,\n  treeRef?: ForwardedRef<TreeRef>\n): TreeState<T> {\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    props.expandedKeys ? props.expandedKeys : undefined,\n    props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(),\n    props.onExpandedChange\n  );\n\n  let selectionState = useMultipleSelectionState({\n    ...props,\n    selectionBehavior: \"replace\",\n  });\n  let disabledKeys = useMemo(\n    () => (props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()),\n    [props.disabledKeys]\n  );\n\n  const context = useCollectionCacheInvalidation(props);\n\n  let tree = useCollection(\n    props,\n    (nodes) => new TreeCollection(nodes, { expandedKeys }),\n    context,\n    [expandedKeys]\n  );\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (\n      selectionState.focusedKey != null &&\n      !tree.getItem(selectionState.focusedKey)\n    ) {\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  const onToggle = (key: Key) => {\n    setExpandedKeys((expandedKeys) => {\n      const newKeys = toggleKey(expandedKeys, key);\n      // In Intellij impl, when a node is collapsed, all descendants are also collapsed. In other words, keys that are\n      // not a part of the list of visible nodes, will be excluded from the expanded keys, with the toggle action.\n      for (const aKey of newKeys) {\n        if (tree.getItem(aKey) == null) {\n          newKeys.delete(aKey);\n        }\n      }\n\n      // If we are toggling it open, expand all expandable single-child items\n      if (newKeys.has(key)) {\n        for (const aKey of getSingleChildrenKeys(tree.getItem(key))) {\n          newKeys.add(aKey);\n        }\n      }\n      return newKeys;\n    });\n  };\n\n  const selectionManager = new SelectionManager(tree, selectionState);\n\n  useTreeRef({ selectionManager }, treeRef);\n\n  return {\n    collection: tree,\n    expandedKeys,\n    disabledKeys,\n    toggleKey: onToggle,\n    selectionManager,\n  };\n}\n\nfunction toggleKey(set: Set<Key>, key: Key): Set<Key> {\n  let res = new Set(set);\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}\n\nconst isExpandable = (node: Node<T>) =>\n  node.hasChildNodes || !isEmptyIterable(node.childNodes);\n\nfunction getSingleChildrenKeys<T>(node: Node<T> | null | undefined): Key[] {\n  return getSingleChildrenKeysRecursive(node, []);\n}\n\nfunction getSingleChildrenKeysRecursive(\n  node: Node<T> | null | undefined,\n  previousKeys: Key[]\n) {\n  if (!node) {\n    return [];\n  }\n  const childNodesIterator: Iterator<\n    Node<T>,\n    Node<T> | undefined\n  > = node.childNodes[Symbol.iterator]();\n  const { value: firstChild, done } = childNodesIterator.next();\n  const noMoreChildren = done || childNodesIterator.next().value == null;\n  if (firstChild != null && noMoreChildren && isExpandable(firstChild)) {\n    return getSingleChildrenKeysRecursive(\n      firstChild,\n      previousKeys.concat((firstChild as Node<T>).key)\n    );\n  }\n  return previousKeys;\n}\n\nfunction isEmptyIterable(iterable: Iterable<unknown> | undefined | null) {\n  for (const _ of iterable || []) {\n    // eslint-disable-line no-unused-vars, no-unreachable-loop\n    return false;\n  }\n  return true;\n}\n","import { CacheInvalidationContext } from \"@intellij-platform/core/Collections/Item\";\nimport { usePrevious } from \"@intellij-platform/core/utils/usePrevious\";\n\nexport interface CollectionCacheInvalidationProps {\n  /**\n   * Defines cache invalidation policy for items. By default, the render result is cached based on the item objects.\n   * This is equivalent of passing false or not passing anything for `cacheInvalidation`. If `true` is passed, it will\n   * always invalidate the render result, causing the collection to be recreated on each re-render. It can\n   * considerably affect performance in large collections. in addition to boolean value, an object with the list of\n   * invalidators can also be passed. renderer function is called each time any of the invalidators are changed.\n   * Think of it as [dependency array in react hooks](https://reactjs.org/docs/hooks-reference.html#usememo). Except\n   * that the length of the array can also safely change.\n   */\n  cacheInvalidation?: boolean | { invalidators: ReadonlyArray<unknown> };\n}\n\n/**\n * Allows cache invalidation options based on input props, for components that use collection\n */\nexport const useCollectionCacheInvalidation = ({\n  cacheInvalidation,\n}: CollectionCacheInvalidationProps): CacheInvalidationContext => {\n  const invalidators =\n    typeof cacheInvalidation === \"object\" ? cacheInvalidation.invalidators : [];\n  const lastInvalidators = usePrevious(invalidators);\n\n  const invalidated =\n    typeof cacheInvalidation === \"object\"\n      ? cacheInvalidation.invalidators.length !== lastInvalidators.length ||\n        cacheInvalidation.invalidators.some(\n          (anInvalidator, index) => anInvalidator !== lastInvalidators[index]\n        )\n      : cacheInvalidation;\n\n  return {\n    invalidated,\n  };\n};\n","import { ForwardedRef, Key, useImperativeHandle } from \"react\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { useLatest } from \"@intellij-platform/core/utils/useLatest\";\n\nexport interface TreeRef {\n  focus(key: Key): void;\n  replaceSelection(key: Key): void;\n}\n\n/**\n * Sets up a tree ref for imperatively working with tree from outside. For imperatively focusing, expanding to\n * specific key, etc.\n */\nexport function useTreeRef(\n  props: { selectionManager: SelectionManager },\n  forwardedRef?: ForwardedRef<TreeRef>\n) {\n  const latestState = useLatest(props);\n\n  useImperativeHandle(\n    forwardedRef,\n    () => {\n      return {\n        replaceSelection: (key: Key) => {\n          latestState.current.selectionManager.replaceSelection(key);\n        },\n        focus: (key: Key) => {\n          const selectionManager = latestState.current.selectionManager;\n          selectionManager.setFocused(true);\n          /**\n           * NOTE: we set focus key to null and set it to key again, to make sure scroll into view works even when\n           * the key is currently focused but not in view. It wouldn't be needed if there was an imperative handle\n           * for scrolling an item into view, but it's only implemented in way that is reactive to changes to the\n           * focused key. {@see useCollectionAutoScroll}\n           */\n          // @ts-expect-error: setFocusedKey typing mistakenly doesn't accept null, while it should\n          selectionManager.setFocusedKey(null);\n          setTimeout(() => {\n            selectionManager.setFocusedKey(key);\n          });\n        },\n      };\n    },\n    []\n  );\n}\n","/**\n * drop shadow of windows and other overlays in Mac OS X. The current value is not accurate and needs to be revisited.\n */\nexport const MAC_WINDOW_SHADOW = \"box-shadow: 0 5px 15px rgb(0 0 0 / 30%)\";\n","import * as styledComponents from \"styled-components\";\nimport { ThemedStyledComponentsModule } from \"styled-components\";\nimport { Theme } from \"./Theme\";\nimport { KnownThemePropertyPath } from \"./Theme/types\";\n\ntype JuiStyledComponentsModule = ThemedStyledComponentsModule<\n  Theme<KnownThemePropertyPath>\n>;\n\nexport const styled = styledComponents.default as JuiStyledComponentsModule[\"default\"];\nexport const useTheme = styledComponents.useTheme as JuiStyledComponentsModule[\"useTheme\"];\nexport const css = styledComponents.css as JuiStyledComponentsModule[\"css\"];\nexport const ThemeConsumer = styledComponents.ThemeConsumer as JuiStyledComponentsModule[\"ThemeConsumer\"];\n","import React, { useContext } from \"react\";\n\nexport const useContextOrThrow = <ContextType extends unknown>(\n  Context: React.Context<ContextType | null>,\n  nullErrorMessage: string\n) => {\n  const context = useContext<ContextType | null>(Context);\n\n  if (context == null) {\n    throw new Error(nullErrorMessage);\n  }\n\n  return context;\n};\n","import React, { useRef } from \"react\";\n\n/**\n * For when a component needs to forward ref, but it too needs to use the same ref. Since forwarded ref can be in form\n * of a callback too, this will normalize it as a RefObject.\n * NOTE: Should we keep the ref in state because of edge cases?\n */\nexport default function useForwardedRef<T>(\n  forwardedRef: React.Ref<T>\n): React.RefObject<T> {\n  const innerRef = useRef<T>(null);\n  React.useEffect(() => {\n    if (!forwardedRef) {\n      return;\n    }\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(innerRef.current);\n    } else {\n      (forwardedRef as React.MutableRefObject<T | null>).current =\n        innerRef.current;\n    }\n  });\n\n  return innerRef;\n}\n","import { useRef } from \"react\";\n\nexport function useLatest<T>(value: T) {\n  const ref = useRef(value);\n  ref.current = value;\n  return ref;\n}\n","import { useEffect, useRef } from \"react\";\n\nexport function usePrevious<T>(value: T): T {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n","import { Item } from \"@react-stately/collections\";\nimport { Meta, StoryFn } from \"@storybook/react\";\nimport React from \"react\";\nimport { ActionButton } from \"../ActionButton/ActionButton\";\nimport { ActionToolbar } from \"../ActionToolbar/ActionToolbar\";\nimport { Divider, DividerItem } from \"../Collections/Divider\";\nimport { PlatformIcon } from \"../Icon\";\nimport { styledComponentsControlsExclude } from \"../story-helpers\";\nimport { Menu } from \"./Menu\";\nimport { MenuItemLayout } from \"./MenuItemLayout\";\nimport { MenuTrigger } from \"./MenuTrigger\";\n\nexport default {\n  title: \"Components/Menu\",\n  parameters: {\n    controls: { exclude: styledComponentsControlsExclude },\n    component: Menu, // doesn't work for some reason.\n  },\n} as Meta;\n\nexport const Static: StoryFn = () => {\n  return (\n    <Menu disabledKeys={[\"jumpToExternalEditor\"]}>\n      <Item textValue=\"Cut\">\n        <MenuItemLayout\n          icon={<PlatformIcon icon={\"actions/menu-cut\"} />}\n          content=\"Cut\"\n          shortcut={\"âŒ˜X\"}\n        />\n      </Item>\n      <Item textValue=\"Copy\">\n        <MenuItemLayout\n          icon={<PlatformIcon icon={\"actions/copy\"} />}\n          content=\"Copy\"\n          shortcut={\"âŒ˜C\"}\n        />\n      </Item>\n      <Item textValue=\"Paste\">\n        <MenuItemLayout\n          icon={<PlatformIcon icon={\"actions/menu-paste\"} />}\n          content=\"Paste\"\n          shortcut={\"âŒ˜V\"}\n        />\n      </Item>\n      <Divider />\n      <Item>Reformat Code</Item>\n      <Item textValue=\"Optimize Imports\">\n        <MenuItemLayout content=\"Optimize Imports\" shortcut={\"âŒƒâŒ¥O\"} />\n      </Item>\n      <Item textValue=\"Delete\">\n        <MenuItemLayout content=\"Delete\" shortcut={\"âŒ«\"} />\n      </Item>\n      <Divider />\n      <Item textValue=\"Compare with...\">\n        <MenuItemLayout\n          icon={<PlatformIcon icon={\"actions/diff\"} />}\n          content=\"Compare with...\"\n        />\n      </Item>\n      <Divider />\n      <Item key=\"jumpToExternalEditor\" textValue=\"Jump to external editor\">\n        <MenuItemLayout content=\"Jump to external editor\" shortcut={\"âŒ¥âŒ˜F4\"} />\n      </Item>\n    </Menu>\n  );\n};\n\nexport const StaticWithTextItems: StoryFn = () => (\n  <Menu>\n    <Item>Restart Typescript Service</Item>\n    <Item title=\"Compile\">\n      <Item>packages/jui/tsconfig.json</Item>\n      <Item>packages/jui/src/StatusBar/StatusBar.stories.tsx</Item>\n      <Item>Compile All</Item>\n    </Item>\n  </Menu>\n);\ntype MenuItem =\n  | {\n      title: string;\n      icon?: string;\n      shortcut?: string;\n      subItems?: MenuItem[];\n    }\n  | DividerItem;\nconst viewModeItems: Array<MenuItem> = [\n  {\n    title: \"Undock\",\n  },\n  {\n    title: \"Docked\",\n    subItems: [\n      {\n        title: \"Pinned\",\n      },\n      {\n        title: \"UnPinned\",\n      },\n    ],\n  },\n\n  {\n    title: \"Float\",\n  },\n  {\n    title: \"Window\",\n  },\n];\nconst items: Array<MenuItem> = [\n  {\n    title: \"View Mode\",\n    subItems: viewModeItems,\n  },\n  new DividerItem(),\n  {\n    title: \"Group tabs\",\n    icon: \"toolwindows/documentation\",\n  },\n];\n\nexport const Nested: StoryFn = () => {\n  return (\n    <Menu items={items} selectedKeys={[\"Pinned\"]} autoFocus>\n      {renderItem}\n    </Menu>\n  );\n};\n\nexport const Position = ({ offsetRight = 230 }: { offsetRight: number }) => {\n  return (\n    <div style={{ paddingLeft: `calc(100% - ${offsetRight}px)` }}>\n      <Menu items={items}>{renderItem}</Menu>\n    </div>\n  );\n};\n\nexport const MenuWithTrigger: StoryFn<{\n  offsetRight?: number;\n  offsetBottom?: number;\n  restoreFocus?: boolean;\n}> = ({ offsetRight, offsetBottom, restoreFocus }) => {\n  return (\n    <div\n      style={{\n        paddingLeft:\n          offsetRight != undefined\n            ? `calc(100% - ${offsetRight + 24}px)`\n            : undefined,\n        paddingTop:\n          offsetBottom != undefined\n            ? `calc(100% - ${offsetBottom + 24}px)`\n            : undefined,\n      }}\n    >\n      <ActionToolbar>\n        <MenuTrigger\n          restoreFocus={restoreFocus}\n          renderMenu={({ menuProps, close }) => (\n            <Menu\n              items={items}\n              {...menuProps}\n              onAction={(key) => {\n                console.log(key);\n                close();\n              }}\n            >\n              {renderItem}\n            </Menu>\n          )}\n        >\n          {(props, ref) => (\n            <ActionButton {...props} ref={ref}>\n              <PlatformIcon icon={\"general/gearPlain\"} />\n            </ActionButton>\n          )}\n        </MenuTrigger>\n      </ActionToolbar>\n    </div>\n  );\n};\n\nconst renderItem = (item: MenuItem) => {\n  if (item instanceof DividerItem) {\n    return <Divider key={item.key} />;\n  }\n  return (\n    <Item key={item.title} childItems={item.subItems}>\n      <MenuItemLayout\n        icon={item.icon && <PlatformIcon icon={item.icon} />}\n        content={item.title}\n        shortcut={item.shortcut}\n      />\n    </Item>\n  );\n};\n","\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\n/* @jsxFrag mdx.Fragment */\n\nimport React from 'react';\nimport { mdx } from '@mdx-js/react';\n\n\nexport const frontMatter = {};\nexport const contentTitle = 'Menu';\nexport const metadata = {\n  \"unversionedId\": \"components/Menu\",\n  \"id\": \"components/Menu\",\n  \"title\": \"Menu\",\n  \"description\": \"Features\",\n  \"source\": \"@site/docs/components/Menu.mdx\",\n  \"sourceDirName\": \"components\",\n  \"slug\": \"/components/Menu\",\n  \"permalink\": \"/jui/docs/components/Menu\",\n  \"draft\": false,\n  \"editUrl\": \"https://github.com/alirezamirian/jui/edit/master/packages/website/docs/components/Menu.mdx\",\n  \"tags\": [],\n  \"version\": \"current\",\n  \"frontMatter\": {},\n  \"sidebar\": \"tutorialSidebar\",\n  \"previous\": {\n    \"title\": \"List\",\n    \"permalink\": \"/jui/docs/components/List\"\n  },\n  \"next\": {\n    \"title\": \"ProgressBar\",\n    \"permalink\": \"/jui/docs/components/ProgressBar\"\n  }\n};\nexport const assets = {\n\n};\n\nimport { RefToIntellijPlatform } from \"../../src/components/RefToIntellijPlatform.tsx\";\nimport {\n  Static,\n  MenuWithTrigger,\n} from \"@intellij-platform/core/Menu/Menu.stories\";\nimport { Example } from \"../../src/components/ExampleContext\";\nexport const toc = [{\n  value: 'Features',\n  id: 'features',\n  level: 3\n}, {\n  value: 'Remaining',\n  id: 'remaining',\n  level: 4\n}, {\n  value: 'Examples',\n  id: 'examples',\n  level: 2\n}, {\n  value: 'Simple flat menu with static items',\n  id: 'simple-flat-menu-with-static-items',\n  level: 3\n}, {\n  value: 'Menu with a trigger',\n  id: 'menu-with-a-trigger',\n  level: 3\n}];\n\nconst layoutProps = {\n  toc\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"menu\"\n    }}>{`Menu`}</h1>\n    <h3 {...{\n      \"id\": \"features\"\n    }}>{`Features`}</h3>\n    <ul>\n      <li parentName=\"ul\">{`Nested menu items`}</li>\n      <li parentName=\"ul\">{`Check-able menu items`}</li>\n      <li parentName=\"ul\">{`Default menu layout with icon, text and keyboard shortcut`}</li>\n      <li parentName=\"ul\">{`Full keyboard support`}</li>\n      <li parentName=\"ul\">{`Viewport-aware positioning with respect to a trigger.`}</li>\n    </ul>\n    <h4 {...{\n      \"id\": \"remaining\"\n    }}>{`Remaining`}</h4>\n    <ul {...{\n      \"className\": \"contains-task-list\"\n    }}>\n      <li parentName=\"ul\" {...{\n        \"className\": \"task-list-item\"\n      }}><input parentName=\"li\" {...{\n          \"type\": \"checkbox\",\n          \"checked\": false,\n          \"disabled\": true\n        }}></input>{` `}{`Context Menu. Positioning with respect to a click point.`}</li>\n      <li parentName=\"ul\" {...{\n        \"className\": \"task-list-item\"\n      }}><input parentName=\"li\" {...{\n          \"type\": \"checkbox\",\n          \"checked\": false,\n          \"disabled\": true\n        }}></input>{` `}{`Advanced hover behaviour, which detects attempt to go to submenu and doesn't close the menu on mouse out.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"examples\"\n    }}>{`Examples`}</h2>\n    <h3 {...{\n      \"id\": \"simple-flat-menu-with-static-items\"\n    }}>{`Simple flat menu with static items`}</h3>\n    <Example mdxType=\"Example\">\n  <Static mdxType=\"Static\" />\n    </Example>\n    <h3 {...{\n      \"id\": \"menu-with-a-trigger\"\n    }}>{`Menu with a trigger`}</h3>\n    <p>{`This is the most common use case of a menu.`}</p>\n    <Example mdxType=\"Example\">\n  <MenuWithTrigger mdxType=\"MenuWithTrigger\" />\n    </Example>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n","export default function _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  strings.raw = raw;\n  return strings;\n}"],"names":["DEFAULT_MINIMUM_BUTTON_SIZE","NAVBAR_MINIMUM_BUTTON_SIZE","StyledActionButton","styled","minSize","theme","color","ActionButton","React","ref","preventFocusOnPress","excludeFromTabOrder","isPressed","isPressedInput","isDisabled","onPress","onPressChange","onPressEnd","onPressStart","onPressUp","shouldCancelOnPointerExit","otherProps","pressProps","usePress","className","disabled","mergeProps","tabIndex","undefined","StyledActionToolbar","getBorder","hasBorder","dark","StyledHorizontalActionToolbar","StyledHorizontalSeparator","StyledVerticalActionToolbar","StyledVerticalSeparator","OrientationContext","ActionToolbar","orientation","children","Provider","value","ActionToolbarSeparator","useContext","Divider","_Divider","getCollectionNode","props","type","element","rendered","hasChildNodes","DividerItem","key","seq","ItemStateContext","LafIcon","forwardedRef","themePath","icon","size","resolvedIconPath","iconDescriptor","useTheme","resolvedValue","modifiers","name","isUnderDarcula","reduce","soFar","modifier","findIconPath","useIconPath","useForwardedRef","useSvgIcon","path","amendName","iconNameOrPath","amendment","ext","split","getPlatformIconPath","relativePath","PlatformIcon","darkIcon","iconName","darkPath","getDarkPath","fallbackPath","DEFAULT_ICON_SIZE","StyledIconWrapper","useEffect","unmounted","async","console","error","current","dataset","loadingIcon","svg","getSvgIcon","catch","e","querySelector","remove","svgElement","document","createElement","appendChild","outerHTML","fetchIcon","ListDivider","as","useSeparator","StyledMenu","isMac","css","MAC_WINDOW_SHADOW","StyledMenuItem","isActive","StyledNestedArrow","StyledSelectedMark","StyledMenuItemText","MenuItem","item","state","onAction","expandOn","nestedMenuRef","disabledKeys","has","isExpanded","expandedKeys","isSelected","selectionManager","selectedKeys","isFocused","focusedKey","menuItemProps","useMenuItem","maybeOpenSubmenu","forEach","toggleKey","hoverProps","useHover","onHoverStart","keyboardProps","useKeyboard","onKeyDown","includes","continuePropagation","overlayProps","positionProps","useOverlayPosition","targetRef","overlayRef","placement","shouldFlip","onClose","log","offset","crossOffset","isOpen","subMenuProps","useSubmenu","focus","Selected","node","FocusScope","Menu","textValue","items","childNodes","autoFocus","childItem","childItems","hasChildItems","StyledMenuHeading","StyledMenuSectionItemsContainer","MenuSection","itemProps","headingProps","groupProps","useMenuSection","heading","map","Error","useTreeState","expandedKey","onExpandedChange","firstKey","onExpandedKeyChange","defaultExpandedKeys","defaultExpandedKey","menuProps","useMenu","setTimeout","collection","StyledMenuItemLayout","Content","Icon","Shortcut","selected","MenuItemLayout","content","shortcut","useContextOrThrow","MenuTrigger","renderMenu","direction","align","restoreFocus","menuTriggerProps","useMenuTriggerState","triggerRef","triggerProps","useMenuTrigger","buttonProps","useButton","useOverlay","close","shouldCloseOnBlur","isKeyboardDismissDisabled","isDismissable","shouldCloseOnInteractOutside","matches","getPlacement","containerPadding","forceRestoreFocus","DarculaSeparatorUI","defaultSize","StyledSeparator","backgroundColor","backgroundClip","boxSizing","margin","border","flexShrink","directChildRef","useRef","focusManagerRef","useLayoutEffect","nodeToRestore","activeElement","requestAnimationFrame","body","contains","focusSafely","useImperativeHandle","focusManager","containerElement","parentElement","focusNext","tabbable","GetFocusManager","hidden","useFocusManager","Symbol","iterator","TreeCollection","constructor","nodes","keyMap","Map","iterable","lastKey","this","Set","last","visit","set","child","index","nextKey","prevKey","getKeys","keys","getKeyBefore","get","getKeyAfter","getFirstKey","getLastKey","getItem","treeRef","setExpandedKeys","useControlledState","selectionState","useMultipleSelectionState","selectionBehavior","useMemo","context","cacheInvalidation","invalidators","lastInvalidators","usePrevious","invalidated","length","some","anInvalidator","useCollectionCacheInvalidation","tree","useCollection","setFocusedKey","SelectionManager","useTreeRef","newKeys","res","delete","add","aKey","getSingleChildrenKeysRecursive","previousKeys","childNodesIterator","firstChild","done","next","noMoreChildren","_","isEmptyIterable","isExpandable","concat","latestState","useLatest","replaceSelection","setFocused","styledComponents","ThemeConsumer","Context","nullErrorMessage","innerRef","Static","title","subItems","MenuWithTrigger","offsetRight","offsetBottom","style","paddingLeft","paddingTop","renderItem","frontMatter","contentTitle","metadata","assets","toc","id","level","layoutProps","MDXContent","components","mdxType","parentName","isMDXComponent","_taggedTemplateLiteralLoose","strings","raw","slice"],"sourceRoot":""}