{"version":3,"file":"assets/js/b54e7c57.ee0cbe96.js","mappings":"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","sources":["webpack://website/../jui/src/CollectionSpeedSearch/CollectionSpeedSearchContext.tsx","webpack://website/../jui/src/CollectionSpeedSearch/HighlightedTextValue.tsx","webpack://website/../jui/src/CollectionSpeedSearch/useCollectionSpeedSearchResult.ts","webpack://website/../jui/src/CollectionSpeedSearch/createSpeedSearchSelectionManager.ts","webpack://website/../jui/src/CollectionSpeedSearch/useCollectionSpeedSearch.ts","webpack://website/../jui/src/CollectionSpeedSearch/createSpeedSearchKeyboardDelegate.ts","webpack://website/../jui/src/Collections/Divider.ts","webpack://website/../jui/src/Collections/Item.ts","webpack://website/../jui/src/Collections/ItemStateContext.tsx","webpack://website/../jui/src/Collections/useCollectionAutoScroll.ts","webpack://website/../jui/src/Collections/useCollectionRef.ts","webpack://website/../jui/src/Collections/useCollectionSearchInput.ts","webpack://website/../jui/src/Icon/LafIcon.tsx","webpack://website/../jui/src/Icon/PlatformIcon.tsx","webpack://website/../jui/src/Icon/StyledIconWrapper.tsx","webpack://website/../jui/src/Icon/useSvgIcon.tsx","webpack://website/../jui/src/List/List.tsx","webpack://website/../jui/src/List/ListDivider.tsx","webpack://website/../jui/src/List/ListItem.tsx","webpack://website/../jui/src/List/StyledList.tsx","webpack://website/../jui/src/List/StyledListItem.tsx","webpack://website/../jui/src/List/StyledListSectionHeader.tsx","webpack://website/../jui/src/List/listItemRenderer.tsx","webpack://website/../jui/src/List/useList.ts","webpack://website/../jui/src/List/useSelectableList.ts","webpack://website/../jui/src/List/useListState.ts","webpack://website/../jui/src/Menu/ContextMenuContainer.tsx","webpack://website/../jui/src/Menu/useContextMenu.tsx","webpack://website/../jui/src/Collections/patchCollectionProps.tsx","webpack://website/../jui/src/Menu/Menu.tsx","webpack://website/../jui/src/Menu/MenuItem.tsx","webpack://website/../jui/src/Menu/MenuItemLayout.tsx","webpack://website/../jui/src/Menu/MenuOverlay.tsx","webpack://website/../jui/src/Menu/StyledMenu.tsx","webpack://website/../jui/src/Menu/StyledMenuItem.tsx","webpack://website/../jui/src/Menu/Submenu.tsx","webpack://website/../jui/src/Menu/_useSubmenu.ts","webpack://website/../jui/src/Menu/_useSubmenuState.tsx","webpack://website/../jui/src/Menu/MenuSection.tsx","webpack://website/../jui/src/Menu/renderMenuNodes.tsx","webpack://website/../jui/src/Overlay/Overlay.tsx","webpack://website/../jui/src/SpeedSearch/SpeedSearchPopup.tsx","webpack://website/../jui/src/SpeedSearch/useGhostInput.tsx","webpack://website/../jui/src/SpeedSearch/useSpeedSearch.tsx","webpack://website/../jui/src/StyledSeparator.tsx","webpack://website/../jui/src/TextRange.ts","webpack://website/../jui/src/TextWithHighlights/TextWithHighlights.tsx","webpack://website/../jui/src/Tree/SpeedSearchTree/SpeedSearchTreeNode.tsx","webpack://website/../jui/src/Tree/SpeedSearchTree/SpeedSearchTree.tsx","webpack://website/../jui/src/Tree/SpeedSearchTree/useSpeedSearchTree.ts","webpack://website/../jui/src/Tree/StyledTree.tsx","webpack://website/../jui/src/Tree/TreeContext.tsx","webpack://website/../jui/src/Tree/TreeKeyboardDelegate.tsx","webpack://website/../jui/src/Tree/TreeNodeIcon.tsx","webpack://website/../jui/src/Tree/useTreeNodeToggleButton.tsx","webpack://website/../jui/src/Tree/StyledTreeNode.tsx","webpack://website/../jui/src/Tree/TreeNode.tsx","webpack://website/../jui/src/Tree/useTreeNode.tsx","webpack://website/../jui/src/Tree/useSelectableTree.tsx","webpack://website/../jui/src/Tree/__copied__TreeCollection.ts","webpack://website/../jui/src/Tree/getSingleChildrenKeys.ts","webpack://website/../jui/src/Tree/TreeSelectionManager.ts","webpack://website/../jui/src/Tree/useTreeState.ts","webpack://website/../jui/src/Collections/useCollectionCacheInvalidation.ts","webpack://website/../jui/src/Tree/useTreeRef.tsx","webpack://website/../jui/src/VariableWidthListLayout.tsx","webpack://website/../jui/src/Tree/useTreeVirtualizer.tsx","webpack://website/../jui/src/utils/string-utils.ts","webpack://website/../jui/src/minusculeMatch.ts","webpack://website/../jui/src/selection/useSelectableCollection.ts","webpack://website/../jui/src/selection/useSelectableItem.tsx","webpack://website/../jui/src/style-constants.ts","webpack://website/../jui/src/styled.ts","webpack://website/../jui/src/utils/FocusScope.tsx","webpack://website/../jui/src/utils/array-utils.ts","webpack://website/../jui/src/utils/keyboard-utils.ts","webpack://website/../jui/src/utils/useContextOrThrow.tsx","webpack://website/../jui/src/utils/useEventCallback.ts","webpack://website/../jui/src/utils/useForwardedRef.ts","webpack://website/../jui/src/utils/useLatest.ts","webpack://website/../jui/src/utils/useMouseEventOverlayPosition.tsx","webpack://website/../jui/src/utils/usePrevious.ts","webpack://website/./src/components/ExampleContext.tsx","webpack://website/../jui/test-data.ts","webpack://website/../jui/src/Tree/story-helpers.tsx","webpack://website/../jui/src/story-components.tsx","webpack://website/../jui/src/List/story-helpers.tsx","webpack://website/../jui/src/List/List.stories.tsx","webpack://website/./docs/components/List.mdx"],"sourcesContent":["import React from \"react\";\nimport { Collection, Node } from \"@react-types/shared\";\nimport { CollectionSpeedSearchMatches } from \"./useCollectionSpeedSearchResult\";\n\nexport type CollectionSpeedSearchContextValue = {\n  matches: CollectionSpeedSearchMatches;\n  collection: Collection<Node<unknown>>;\n};\n\nexport const CollectionSpeedSearchContext =\n  React.createContext<CollectionSpeedSearchContextValue | null>(null);\n","import React, { Key, useContext } from \"react\";\nimport { TextWithHighlights } from \"@intellij-platform/core/TextWithHighlights/TextWithHighlights\";\nimport { TextRange } from \"@intellij-platform/core/TextRange\";\nimport { CollectionSpeedSearchContext } from \"@intellij-platform/core/CollectionSpeedSearch/CollectionSpeedSearchContext\";\n\ntype CollectionSpeedSearchItemContextValue = {\n  text: string;\n  highlightedRanges: null | TextRange[];\n};\n\nconst CollectionSpeedSearchItemContext =\n  React.createContext<null | CollectionSpeedSearchItemContextValue>(null);\n\nexport const SpeedSearchItemHighlightsProvider: React.FC<{ itemKey: Key }> = ({\n  children,\n  itemKey,\n}) => {\n  const context = useContext(CollectionSpeedSearchContext);\n  if (!context) {\n    throw new Error(\n      `SpeedSearchItemProvider is only meant to be rendered by collection components with speed search. \n      CollectionSpeedSearchContext is expected to be rendered as a wrapper around all items.`\n    );\n  }\n  const item = context.collection.getItem(itemKey);\n  const text = item?.textValue;\n  if (!text && item?.props.textValue === undefined) {\n    console.warn(\n      \"no textValue specified on Item. When using SpeedSearch, you need to specify textValue for item, which will be the basis for search\"\n    );\n  }\n  return (\n    <CollectionSpeedSearchItemContext.Provider\n      value={{\n        highlightedRanges: context.matches.get(itemKey) || null,\n        text: text,\n      }}\n    >\n      {children}\n    </CollectionSpeedSearchItemContext.Provider>\n  );\n};\n\n/**\n * Used inside Item content, to render the textValue of the Item, potentially with highlighted ranges if it's a match\n * in current search.\n */\nexport const HighlightedTextValue = function ({\n  Component = \"span\",\n}: {\n  /**\n   * When rendering in a flex parent (which is the case for tree or list), rendering a container is necessary to have\n   * the right spacing around highlights, when the highlighter span is immediately followed or proceeded by a white\n   * space. By default, a \"span\" is rendered.\n   */\n  Component?: React.ElementType;\n}) {\n  const speedSearchContext = React.useContext(CollectionSpeedSearchItemContext);\n  if (!speedSearchContext) {\n    throw new Error(\n      \"HighlightedTextValue should be rendered only in items of a speed search enabled collection component\"\n    );\n  }\n  const { highlightedRanges, text } = speedSearchContext;\n  return (\n    <Component>\n      {highlightedRanges ? (\n        <TextWithHighlights highlights={highlightedRanges}>\n          {text}\n        </TextWithHighlights>\n      ) : (\n        text\n      )}\n    </Component>\n  );\n};\n","import { Key, useEffect, useMemo } from \"react\";\nimport { minusculeMatch } from \"../minusculeMatch\";\nimport { SpeedSearchState } from \"../SpeedSearch/useSpeedSearch\";\nimport { Collection, Node } from \"@react-types/shared\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { createSpeedSearchSelectionManager } from \"./createSpeedSearchSelectionManager\";\nimport { TextRange } from \"@intellij-platform/core/TextRange\";\nimport { useLatest } from \"@intellij-platform/core/utils/useLatest\";\n\nexport type CollectionSpeedSearchMatches = Map<Key, TextRange[]>;\n\nexport function useCollectionSpeedSearchResult<T>({\n  collection,\n  selectionManager: inputSelectionManager,\n  speedSearch,\n  focusBestMatch = false,\n}: {\n  collection: Collection<Node<T>>;\n  selectionManager: SelectionManager;\n  speedSearch: SpeedSearchState;\n  /**\n   * If true, focusing the best match (the longest \"start-with\" match) will be preferred.\n   * By default, the focus is moved to the first match that comes after the currently focused item, if currently\n   * focused item itself is not a match.\n   * A typical use case would be collections that filter out non-match items.\n   * @default false\n   */\n  focusBestMatch?: boolean;\n}) {\n  const { searchTerm, active } = speedSearch;\n\n  /**\n   * Note: when a component is implemented using react-aria's useCollection, any re-render of that component causes\n   * a new collection. That's because prop.children is normally an inline function, and therefore the collection is\n   * re-created: https://github.com/adobe/react-spectrum/blob/4a1cff846018e449487ccf54d7474bdfa4d4f57c/packages/@react-stately/collections/src/useCollection.ts#L29\n   * This means we will unnecessarily perform the search in such cases. it might be a non-issue, but if it turned out\n   * to be an issue, a sub-optimum improvement would be to use `collection.size` as a dependency instead of `collection`,\n   * assuming that searchable text in collections won't change, and assuming that the important changes (search-wise)\n   * will usually involve a size change in the collection.\n   */\n  const { matches } = useMemo(() => {\n    const matches: CollectionSpeedSearchMatches = new Map(); // maybe make it nullable makes more sense\n    if (speedSearch.active) {\n      // it's important not to iterate on items, since they can be nested.\n      [...collection.getKeys()]\n        .map((key) => collection.getItem(key))\n        .filter(({ type }) => type === \"item\")\n        .forEach((item) => {\n          const matchedRanges = minusculeMatch(item.textValue, searchTerm);\n          if (matchedRanges) {\n            matches.set(item.key, matchedRanges);\n          }\n        });\n    }\n\n    return {\n      matches,\n    };\n  }, [searchTerm, collection, active]);\n\n  const selectionManager = createSpeedSearchSelectionManager(\n    inputSelectionManager,\n    active ? matches : null\n  );\n  const latestValues = useLatest({\n    matches,\n    selectionManager,\n    collection,\n    focusBestMatch,\n  });\n\n  // On every query change, if the current selection doesn't include any of the matched items, move selection to the\n  // first matched item.\n  useEffect(() => {\n    const { selectionManager, matches, collection } = latestValues.current;\n    const matchedKeys = [...matches.keys()];\n    const noneOfTheMatchesAreSelected = !matchedKeys.some((matchedKey) =>\n      selectionManager.isSelected(matchedKey)\n    );\n    let keyToFocus: Key | undefined;\n    if (latestValues.current.focusBestMatch) {\n      keyToFocus = getLongestCommonPrefixMatch(matches);\n    }\n    if (!keyToFocus && matchedKeys.length > 0 && noneOfTheMatchesAreSelected) {\n      keyToFocus = getMatchToSelect({\n        collection,\n        selectionManager,\n        matchedKeys,\n      });\n    }\n    if (keyToFocus) {\n      selectionManager.setFocusedKey(keyToFocus);\n      selectionManager.replaceSelection(keyToFocus);\n    }\n  }, [\n    searchTerm,\n    latestValues /*it's a ref object, so no harm in listing it here to comply with rules of hooks*/,\n  ]);\n  return {\n    matches,\n    selectionManager,\n  };\n}\n\n/**\n * given a non-empty array of matched keys, returns the one that should be selected\n */\nfunction getMatchToSelect({\n  collection,\n  selectionManager,\n  matchedKeys,\n}: {\n  collection: Collection<Node<unknown>>;\n  selectionManager: SelectionManager;\n  matchedKeys: Key[];\n}): Key {\n  let passedFirstSelection = false;\n  for (const key of collection.getKeys()) {\n    if (key === selectionManager.firstSelectedKey) {\n      passedFirstSelection = true;\n    }\n    if (passedFirstSelection && matchedKeys.includes(key)) {\n      return key;\n    }\n  }\n  return matchedKeys[0];\n}\n\n/**\n * Returns the longest match from the beginning, if exists.\n */\nfunction getLongestCommonPrefixMatch(matches: CollectionSpeedSearchMatches) {\n  return [...matches.entries()]\n    .filter(([, [firstRange]]) => firstRange?.from === 0)\n    .sort(\n      ([, [rangeA]], [, [rangeB]]) =>\n        rangeB.to - rangeB.from - rangeA.to - rangeA.from\n    )?.[0]?.[0];\n}\n","import { SelectionManager } from \"@react-stately/selection\";\nimport { Key } from \"react\";\n\nexport function createSpeedSearchSelectionManager(\n  wrappedSelectionManager: SelectionManager,\n  matches: Map<Key, unknown /* We don't care what a match is here */> | null\n): SelectionManager {\n  return Object.create(wrappedSelectionManager, {\n    selectAll: {\n      value: () => {\n        if (matches) {\n          // @ts-expect-error: state is private and there is no API on SelectionManager for bulk\n          // setting selected keys (which would ideally check for not selecting disabled keys internally).\n          const state = wrappedSelectionManager.state;\n          state.setSelectedKeys(\n            new Set(\n              [...matches.keys()].filter((key) => !state.disabledKeys.has(key))\n            )\n          );\n        } else {\n          wrappedSelectionManager.selectAll();\n        }\n      },\n    },\n  });\n}\n","import { HTMLAttributes, RefObject, useMemo } from \"react\";\nimport { Collection, KeyboardDelegate, Node } from \"@react-types/shared\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { SpeedSearchPopupProps } from \"@intellij-platform/core/SpeedSearch\";\nimport {\n  SpeedSearchState,\n  SpeedSearchStateProps,\n  useSpeedSearch,\n  useSpeedSearchState,\n} from \"../SpeedSearch/useSpeedSearch\";\nimport { CollectionSpeedSearchContextValue } from \"./CollectionSpeedSearchContext\";\nimport {\n  CollectionSpeedSearchMatches,\n  useCollectionSpeedSearchResult,\n} from \"./useCollectionSpeedSearchResult\";\nimport { createSpeedSearchKeyboardDelegate } from \"./createSpeedSearchKeyboardDelegate\";\n\nexport interface CollectionSpeedSearch {\n  containerProps: HTMLAttributes<HTMLElement>;\n  selectionManager: SelectionManager;\n  keyboardDelegate: KeyboardDelegate;\n  speedSearch: SpeedSearchState & { matches: CollectionSpeedSearchMatches };\n  searchPopupProps: SpeedSearchPopupProps;\n  speedSearchContextValue: CollectionSpeedSearchContextValue;\n}\n\n/**\n * Given a `collection`, a `selectionManager` and a `keyboardDelegate`, it returns:\n * - `speedSearch`: search term, if speed search is active or not, and the matched keys\n * - `matches`: A Set of matched keys, or `null` if speed search is not active\n * - `containerProps`: The props you need to pass to the collection container element to enable\n * speedSearch on it.\n * - `selectionManager`: a selection manager in which select all is overridden to only select\n * matched items if speed search is active.\n * - `keyboardDelegate`: a keyboard delegate in which limits navigation to matched items, when\n * speed search is active.\n *\n * Speed search options, including the ones for optionally controlling the state of the speed search\n * are also accepted in inputs.\n */\nexport function useCollectionSpeedSearch<T>({\n  collection,\n  selectionManager,\n  stickySearch,\n  keyboardDelegate,\n  focusBestMatch,\n  ref,\n  ...speedSearchStateProps\n}: {\n  collection: Collection<Node<T>>;\n  selectionManager: SelectionManager;\n  keyboardDelegate: KeyboardDelegate;\n  ref: RefObject<HTMLElement>;\n  stickySearch?: boolean;\n  focusBestMatch?: boolean;\n} & SpeedSearchStateProps): CollectionSpeedSearch {\n  const speedSearch = useSpeedSearchState(speedSearchStateProps);\n\n  const { matches, selectionManager: speedSearchSelectionManager } =\n    useCollectionSpeedSearchResult({\n      collection,\n      selectionManager,\n      speedSearch,\n      focusBestMatch,\n    });\n  const { containerProps } = useSpeedSearch({ stickySearch }, speedSearch, ref);\n  const speedSearchKeyboardDelegate = useMemo(\n    () =>\n      createSpeedSearchKeyboardDelegate(\n        keyboardDelegate,\n        speedSearch.active ? matches : null\n      ),\n    [speedSearch.active, keyboardDelegate, matches]\n  );\n\n  // Doesn't seem necessary to wrap with useMemo, but can be rethink-ed\n  const speedSearchContextValue = { matches, collection };\n\n  return {\n    containerProps,\n    selectionManager: speedSearchSelectionManager,\n    keyboardDelegate: speedSearchKeyboardDelegate,\n    speedSearch: {\n      ...speedSearch,\n      matches,\n    },\n    searchPopupProps: {\n      active: speedSearch.active,\n      match: matches.size > 0,\n      children: speedSearch.searchTerm,\n    },\n    speedSearchContextValue,\n  };\n}\n","import React, { Key } from \"react\";\nimport { KeyboardDelegate } from \"@react-types/shared\";\n\n/**\n * Creates a new KeyboardDelegate in which keyKeyBelow and getKeyAbove are overridden in a way that\n * navigation is limited to matched items.\n * Note: select all action is not handled in KeyboardDelegate.\n * Note: when virtualization is added, this probably need to change, like how it's handled\n * in `useListBoxLayout` in react spectrum.\n */\nexport function createSpeedSearchKeyboardDelegate(\n  wrappedKeyboardDelegate: KeyboardDelegate,\n  matches: Map<Key, unknown /*We don't care what a match is, here*/> | null\n): KeyboardDelegate {\n  // TODO: page up and down deactivate speed search. If we want that, we can pass the speedSearch\n  //  object too. but doesn't seem like the best way to do it, even it the same behavior is expected\n  const findFirstMatch = <T extends React.Key | undefined, K>(\n    fromKey: React.Key | undefined | null,\n    direction: \"up\" | \"down\"\n  ) => {\n    let currentKey: React.Key | undefined | null = fromKey;\n    while (currentKey != null) {\n      if (!matches || matches.has(currentKey)) {\n        return currentKey;\n      }\n      currentKey =\n        direction === \"up\"\n          ? wrappedKeyboardDelegate.getKeyAbove?.(currentKey)\n          : wrappedKeyboardDelegate.getKeyBelow?.(currentKey);\n    }\n    return currentKey ?? undefined;\n  };\n  return Object.create(wrappedKeyboardDelegate, {\n    getKeyBelow: {\n      value: (key) =>\n        findFirstMatch(wrappedKeyboardDelegate.getKeyBelow?.(key), \"down\"),\n    },\n    getKeyAbove: {\n      value: (key) =>\n        findFirstMatch(wrappedKeyboardDelegate.getKeyAbove?.(key), \"up\"),\n    },\n    getFirstKey: {\n      value: (key?: React.Key, global?: boolean): React.Key | null => {\n        const firstKey = findFirstMatch(\n          wrappedKeyboardDelegate.getFirstKey?.(key, global),\n          \"down\"\n        );\n        return firstKey == null ? matches?.values().next().value : firstKey;\n      },\n    },\n    getLastKey: {\n      value: (key?: React.Key, global?: boolean): React.Key | null => {\n        const lastKey = findFirstMatch(\n          wrappedKeyboardDelegate.getLastKey?.(key, global),\n          \"down\"\n        );\n        return lastKey == null\n          ? [...(matches?.keys() || [])].pop() ?? null\n          : lastKey;\n      },\n    },\n  } as { [key in keyof KeyboardDelegate]: { value: KeyboardDelegate[key] } });\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { ReactElement } from \"react\";\nimport { ItemProps } from \"@react-types/shared\";\nimport { PartialNode } from \"@react-stately/collections\";\n\ninterface DividerProps {}\n\n/**\n * To be used in dynamic collections, just to provide a key and make it easy to check in the render\n * function to figure out what to render (an Item or a Divider)\n */\nexport class DividerItem {\n  private static seq = 0;\n  key = \"divider_\" + DividerItem.seq++;\n  get id() {\n    return this.key;\n  }\n}\n\nfunction Divider({}: DividerProps): ReactElement {\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  return null as any;\n}\n// We don't want getCollectionNode to show up in the type definition\nlet _Divider = Divider as (props: DividerProps) => JSX.Element;\nexport { _Divider as Divider };\n\nDivider.getCollectionNode = function* getCollectionNode<T>(\n  props: ItemProps<T>\n): Generator<PartialNode<T>> {\n  let rendered = null;\n\n  yield {\n    type: \"divider\",\n    element: null as any, // to prevent check on key, which is not necessary for divider\n    props: props,\n    rendered,\n    hasChildNodes: false,\n  };\n};\n","import React, { ReactElement } from \"react\";\nimport { ItemProps } from \"@react-types/shared\";\nimport { Item as StatelyItem, PartialNode } from \"@react-stately/collections\";\n\n// noinspection JSUnusedLocalSymbols\n/**\n * Item for collection components, which by default disables caching, unless `invalidated` prop is set to false on the\n * context passed to useCollection. Control over cache invalidation policy can be enabled by using\n * `useCollectionCacheInvalidation` for creating such context object.\n */\nfunction Item<T>(props: ItemProps<T>): ReactElement {\n  return null as any as React.ReactElement;\n}\n\nexport type CacheInvalidationContext = { invalidated?: boolean };\n\n// We don't want getCollectionNode to show up in the type definition\nlet _Item = Item as <T>(props: ItemProps<T>) => JSX.Element;\nexport { _Item as Item };\n\n/**\n * @private @preapproved\n */\nItem.getCollectionNode = function* getCollectionNode<T>(\n  props: ItemProps<T>,\n  context: CacheInvalidationContext\n): Generator<PartialNode<T>> {\n  const itemGenerator: Generator<PartialNode<T>> = (\n    StatelyItem as any\n  ).getCollectionNode(props, context);\n  const result = itemGenerator.next().value;\n  const originalShouldInvalidate = result.shouldInvalidate;\n  result.shouldInvalidate = (context: CacheInvalidationContext) =>\n    originalShouldInvalidate?.(context) || context.invalidated;\n  yield result;\n};\n","import React from \"react\";\nimport { Node } from \"@react-types/shared\";\n\n/**\n * Generic state of items in collections, provided via a context.\n * To be used in Menu, Tree, or anything that deals with a collection of items for which the common states like\n * **disabled** or **selected** is applicable.\n */\nexport interface ItemStateContextType {\n  node: Node<unknown>;\n  isSelected: boolean;\n  isContainerFocused: boolean;\n  isDisabled: boolean;\n}\n\nexport const ItemStateContext =\n  React.createContext<ItemStateContextType | null>(null);\n","import { RefObject, useEffect } from \"react\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { scrollIntoView } from \"@react-aria/utils\";\n\ntype CollectionAutoScrollProps = {\n  isVirtualized?: boolean;\n  selectionManager: SelectionManager;\n};\n\nexport function useCollectionAutoScroll(\n  { isVirtualized, selectionManager }: CollectionAutoScrollProps,\n  ref: RefObject<HTMLElement>\n) {\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && selectionManager.focusedKey && ref?.current) {\n      let element = ref.current.querySelector(\n        `[data-key=\"${selectionManager.focusedKey}\"]`\n      ) as HTMLElement;\n      if (element) {\n        scrollIntoView(ref.current, element);\n      }\n    }\n  }, [isVirtualized, ref, selectionManager.focusedKey]);\n}\n","import { SelectionManager } from \"@react-stately/selection\";\nimport { RefObject, useImperativeHandle } from \"react\";\n\nexport type CollectionRefProps = {\n  /**\n   * Gives imperative access to selection manager.\n   */\n  selectionManagerRef?: RefObject<SelectionManager>;\n};\n\n/**\n * Common imperative API for collections. Used in Lists at the moment. Tree components implement a different imperative\n * API that can be refactored later for more consistency.\n */\nexport function useCollectionRef(\n  { selectionManagerRef }: CollectionRefProps,\n  state: { selectionManager: SelectionManager }\n) {\n  useImperativeHandle(selectionManagerRef, () => state.selectionManager);\n}\n","import React, { RefObject } from \"react\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { useEventCallback } from \"@intellij-platform/core/utils/useEventCallback\";\nimport { DOMAttributes } from \"@react-types/shared\";\n\n/**\n * A solution for connecting a collection to a search input, so that collection can still be navigated by keyboard\n * while the input is focused. It works by replaying certain keyboard events on the collection container and focused\n * item. An alternative approach (which is used in react-aria's useCombobox) is to use useSelectableCollection\n * separately for the input, but the biggest issue with that approach is that it's limiting in the following ways:\n * - Rendering input should be a part of the same component that renders the collection. Having specific components\n *   for use cases that requires a search input is not flexible enough. For example one may want to use SpeedSearchList\n *   or List connected to an input. Also, the input and the collection may need to be in different layouts in different\n *   use cases. Decoupling the rendering of the input and collection is a more flexible solution.\n * - The same options used for collection should be passed to the input field for behavior consistency, and that can be\n *   prone to error. Some of these options, like `keyboardDelegate` can even have a default value in hooks like\n *   `useSelectableList`, which means for making sure the same value is passed to the useSelectableCollection for input,\n *   would require to not use the default value, since the same value can't be accessed.\n *\n * With this event forwarding approach, it's an arrow up or down event would behave exactly like it was triggered on\n * the collection itself, leaving no room for behavior discrepancies. But it has a few drawbacks:\n * - Although small, there is still some coupling between this code and implementation of the collection component.\n *   More specifically, the following things are assumed by this implementation:\n *   - \"Enter\" keys (selection or action) are handled on items, but arrow keys are handled on the collection element.\n *   - \"[data-key] attribute is set on items. That is used to find the element for the focused item (which of course is\n *     not actually focused while the input is).\n */\nexport const useCollectionSearchInput = ({\n  collectionRef,\n  selectionManager,\n}: {\n  /**\n   * ref to the html element of the collection component\n   */\n  collectionRef: RefObject<HTMLElement>;\n  /**\n   * SelectionManager instance, returned from the state management hook for the collection component.\n   * {@link CollectionRefProps.selectionManagerRef} can be used on collection components that implement\n   * `useCollectionRef`, to get a hold of selection manager, from outside.\n   */\n  selectionManager: SelectionManager | null | undefined;\n}): { collectionSearchInputProps: DOMAttributes<HTMLInputElement> } => {\n  const relayEventsToCollection = useEventCallback(\n    (event: React.KeyboardEvent) => {\n      // Relay ArrowUp and ArrowDown to the container\n      if (\n        event.type === \"keydown\" &&\n        (event.key === \"ArrowUp\" || event.key === \"ArrowDown\")\n      ) {\n        event.preventDefault();\n        event.stopPropagation();\n        collectionRef.current?.dispatchEvent(\n          new KeyboardEvent(event.type, event.nativeEvent)\n        );\n      }\n      // Relay Enter to the focused item\n      else if (event.key === \"Enter\" && selectionManager?.focusedKey) {\n        collectionRef.current\n          ?.querySelector(`[data-key=\"${selectionManager?.focusedKey}\"]`)\n          ?.dispatchEvent(new KeyboardEvent(event.type, event.nativeEvent));\n        event.preventDefault();\n      }\n    }\n  );\n\n  return {\n    collectionSearchInputProps: {\n      onKeyDown: relayEventsToCollection,\n      onKeyUp: relayEventsToCollection,\n      onKeyPress: relayEventsToCollection,\n    },\n  };\n};\n","import useForwardedRef from \"@intellij-platform/core/utils/useForwardedRef\";\nimport React, { ForwardedRef } from \"react\";\nimport { useTheme } from \"styled-components\";\nimport { Theme } from \"../Theme/Theme\";\nimport { IconProps } from \"./IconProps\";\nimport { StyledIconWrapper } from \"./StyledIconWrapper\";\nimport { useSvgIcon } from \"./useSvgIcon\";\n\ninterface IconModifiers {\n  Selected?: boolean;\n  Focused?: boolean;\n  Disabled?: boolean;\n  Editable?: boolean;\n  Pressed?: boolean;\n}\n\nexport interface ThemeIconProps extends IconProps {\n  /**\n   * Icon which will be resolved against the default icon location based on theme type\n   */\n  icon: string | { name: string; modifiers: IconModifiers };\n\n  /**\n   * A theme key that can optionally override the icon.\n   */\n  themePath?: string;\n}\n\nconst ICONS_DIR_PREFIX = \"com/intellij/ide/ui/laf/icons/\";\n\n// Similar to LafIconLookup\nfunction findIconPath(\n  theme: Theme,\n  name: string,\n  modifiers: IconModifiers = {}\n) {\n  const basePath = `${ICONS_DIR_PREFIX}${\n    theme.isUnderDarcula() ? \"darcula/\" : \"intellij/\"\n  }`;\n  const suffix = (\n    [\"Editable\", \"Selected\", \"Pressed\", \"Focused\", \"Disabled\"] as Array<\n      keyof typeof modifiers\n    >\n  )\n    .filter((modifier) =>\n      // Focused or Pressed can't coexist with Disabled\n      modifiers.Disabled ? ![\"Focused\", \"Pressed\"].includes(modifier) : true\n    )\n    .reduce(\n      (soFar, modifier) => soFar + (modifiers[modifier] ? modifier : \"\"),\n      \"\"\n    );\n  return `${basePath}${name}${suffix}.svg`;\n}\n\nfunction useIconPath(\n  iconDescriptor: string | { name: string; modifiers?: IconModifiers },\n  themePath?: string\n) {\n  const theme = useTheme() as Theme; // TODO: investigate why useTheme is typed like this\n  const resolvedValue = themePath && theme.value(themePath);\n  if (resolvedValue) {\n    return resolvedValue;\n  }\n  const { modifiers = {}, name } =\n    typeof iconDescriptor === \"string\"\n      ? { name: iconDescriptor }\n      : iconDescriptor;\n  return findIconPath(theme, name, modifiers);\n}\n\nexport const LafIcon = React.forwardRef(\n  (\n    { themePath, icon, size, ...props }: ThemeIconProps,\n    forwardedRef: ForwardedRef<HTMLElement>\n  ) => {\n    const resolvedIconPath = useIconPath(icon, themePath);\n\n    const ref = useForwardedRef(forwardedRef);\n    useSvgIcon({ path: `platform/platform-impl/src/${resolvedIconPath}` }, ref);\n    return <StyledIconWrapper {...props} ref={ref} size={size} />;\n  }\n);\n","import React, { ForwardedRef } from \"react\";\nimport useForwardedRef from \"@intellij-platform/core/utils/useForwardedRef\";\nimport { useTheme } from \"@intellij-platform/core/styled\";\nimport { IconProps } from \"./IconProps\";\nimport { StyledIconWrapper } from \"./StyledIconWrapper\";\nimport { useSvgIcon } from \"./useSvgIcon\";\n\nexport interface PlatformIconProps extends IconProps {\n  /**\n   * Icon path in intellij platform repo.\n   * If starts with \"/\", the path will be from the repo root. Otherwise, it's relative to \"platform/icons/src\".\n   * \".svg\" extension is optional.\n   */\n  icon: string;\n  /**\n   * Similar to icon, but for dark themes.\n   */\n  darkIcon?: string;\n}\n\nexport const amendName = (iconNameOrPath: string, amendment: string) => {\n  const [name, ext] = iconNameOrPath.split(\".\");\n  return `${name}${amendment}${ext ? `.${ext}` : \"\"}`;\n};\n\nexport const getDarkPath = (path: string, darkPath?: string) => {\n  const [name, ext] = path.split(\".\");\n  return darkPath || `${name}_dark${ext ? `.${ext}` : \"\"}`;\n};\n\nconst getPlatformIconPath = (relativePath: string) =>\n  relativePath.startsWith(\"/\")\n    ? relativePath.slice(1)\n    : `platform/icons/src/${relativePath}`;\n\n/**\n * Renders an icon from the predefined list of platform icons.\n * icon name must follow the directory structure in platform icons.\n * @example <PlatformIcon icon=\"general/hideToolWindow\" />\n * @example <PlatformIcon icon=\"toolbar/pin\" />\n * @example <PlatformIcon icon=\"toolbar/pin.svg\" />\n * @example <PlatformIcon icon=\"/platform/dvcs-impl/resources/icons/currentBranchLabel.svg\" />\n */\nexport const PlatformIcon = React.forwardRef(\n  (\n    { icon, darkIcon, ...props }: PlatformIconProps,\n    forwardedRef: ForwardedRef<HTMLElement>\n  ) => {\n    const ref = useForwardedRef(forwardedRef);\n    const theme = useTheme();\n    const iconName = theme.dark ? getDarkPath(icon, darkIcon) : icon;\n    useSvgIcon(\n      {\n        path: getPlatformIconPath(iconName),\n        fallbackPath: getPlatformIconPath(icon),\n      },\n      ref\n    );\n\n    return <StyledIconWrapper {...props} ref={ref} />;\n  }\n);\n","import { styled } from \"../styled\";\nimport { IconSize } from \"@intellij-platform/core/Icon/IconProps\";\n\nconst DEFAULT_ICON_SIZE: IconSize = 16;\n\nexport const StyledIconWrapper = styled.span<{\n  size?: IconSize;\n  useCurrentColor?: boolean;\n  role?: string;\n}>`\n  box-sizing: border-box;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  line-height: 0;\n  width: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  height: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  position: relative; // to allow absolute positioned indicators and overlays on icon\n  cursor: ${({ role }) => (role === \"button\" ? \"pointer\" : undefined)};\n`;\n","import { RefObject, useContext, useEffect } from \"react\";\nimport { useTheme } from \"@intellij-platform/core/styled\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections\";\n\nexport function useSvgIcon(\n  { path, fallbackPath }: { path: string; fallbackPath?: string },\n  /**\n   * ref to the icon wrapper element in which the svg should be injected.\n   * This hook used to return svg string, and that svg was set as dangerouslySetInnerHTML. But now it injects the svg.\n   * by direct DOM manipulation. That's to eliminate the need for using dangerouslySetInnerHTML, so that we can allow\n   * arbitrary children (like LiveIndicator) as overlays on top of icons.\n   */\n  ref: RefObject<HTMLElement>\n) {\n  const theme = useTheme();\n  const itemState = useContext(ItemStateContext);\n  const selected = itemState?.isSelected || itemState?.isContainerFocused;\n  useEffect(() => {\n    let unmounted = false;\n    const fetchIcon = async () => {\n      if (!path) {\n        console.error(\"icon path is empty\");\n        return;\n      }\n      if (ref.current) {\n        // For querying for icons that are not loaded yet. Especially useful for visual testing\n        ref.current.dataset.loadingIcon = \"true\";\n      }\n      const svg = await theme.getSvgIcon(path, selected).catch((e) => {\n        if (fallbackPath) {\n          return theme.getSvgIcon(fallbackPath, selected);\n        }\n        throw e;\n      });\n      if (svg) {\n        if (!unmounted && ref?.current) {\n          if (ref) {\n            ref.current?.querySelector(\"svg\")?.remove();\n            const svgElement = document.createElement(\"svg\");\n            ref.current?.appendChild(svgElement);\n            svgElement.outerHTML = makeIdsUnique(svg); // UNSAFE! Would require sanitization, or icon sources must be trusted.\n            delete ref.current?.dataset.loadingIcon;\n          }\n        }\n      } else {\n        console.error(\"Could not resolve icon:\", path);\n      }\n    };\n    fetchIcon().catch(console.error);\n    return () => {\n      unmounted = true;\n    };\n  }, [path, selected]);\n}\n\n/**\n * If multiple instance of the same icon is rendered at the same time, and the SVG includes\n * url(#...) references to locally defined ids, in some cases the icon is not rendered properly.\n * because of ids colliding. We make sure the ids are unique in each rendered icon.\n */\nfunction makeIdsUnique(svg: string): string {\n  const randomPostfix = (Math.random() * 1000).toFixed(0);\n  const idMatches = svg.matchAll(/id=\"(.*?)\"/g);\n  return [...idMatches].reduce((modifiedSvg, [_, id]) => {\n    const newId = `${id}-${randomPostfix}`;\n    return replaceAll(\n      `id=\"${id}\"`,\n      `id=\"${newId}\"`,\n      replaceAll(`url(#${id})`, `url(#${newId})`, modifiedSvg)\n    );\n  }, svg);\n}\n\nfunction replaceAll(theOld: string, theNew: string, str: string): string {\n  const replaced = str.replace(theOld, theNew);\n  const replacedAgain = replaced.replace(theOld, theNew);\n  if (replaced === replacedAgain) {\n    return replaced;\n  }\n  return replaceAll(theOld, theNew, replacedAgain);\n}\n","import { AriaListBoxProps } from \"@react-types/listbox\";\nimport { AsyncLoadable } from \"@react-types/shared\";\nimport React, { ForwardedRef, Key } from \"react\";\nimport { useList } from \"./useList\";\nimport { ListItem } from \"./ListItem\";\nimport { StyledList } from \"./StyledList\";\nimport { listItemRenderer } from \"./listItemRenderer\";\nimport { useListState } from \"./useListState\";\nimport { useObjectRef } from \"@react-aria/utils\";\nimport { CollectionRefProps } from \"@intellij-platform/core/Collections/useCollectionRef\";\n\nexport type ListProps<T extends object> = Omit<\n  Omit<AriaListBoxProps<T>, \"disallowEmptySelection\">,\n  keyof AsyncLoadable\n> &\n  CollectionRefProps & {\n    /**\n     * fills the available horizontal or vertical space, when rendered in a flex container.\n     */\n    fillAvailableSpace?: boolean;\n    /**\n     * When true, shows the list in focused style, even when it's not focused. A common use case is when the list\n     * is virtually focused. i.e. the focus is physically on some other element (like a search input) which handles\n     * keyboard events as if the list was focused.\n     * Another (maybe questionable) use case is master detail views, where the master view is shown as focused, even\n     * when the details view has physical focus.\n     */\n    showAsFocused?: boolean;\n    allowEmptySelection?: boolean;\n    /**\n     * Called when the action for the item should be triggered, which can be by double click or pressing Enter.\n     * Enter not implemented yet :D\n     */\n    onAction?: (key: Key) => void;\n  };\n\n/**\n * List view with speedSearch instead of default typeahead.\n * TODO:\n *  - Support virtualization\n *  - Support custom rendering\n *  -\n */\nexport const List = React.forwardRef(function List<T extends object>(\n  {\n    allowEmptySelection = false,\n    showAsFocused = false,\n    fillAvailableSpace = false,\n    onAction,\n    ...inputProps\n  }: ListProps<T>,\n  forwardedRef: ForwardedRef<HTMLUListElement>\n) {\n  const props: AriaListBoxProps<T> & CollectionRefProps = {\n    ...inputProps,\n    disallowEmptySelection: !allowEmptySelection,\n  };\n  const ref = useObjectRef(forwardedRef);\n  const state = useListState(props);\n  const { listProps, focused } = useList(props, state, ref);\n\n  return (\n    <StyledList\n      fillAvailableSpace={fillAvailableSpace}\n      {...listProps}\n      ref={ref}\n    >\n      {[...state.collection].map(\n        listItemRenderer({\n          item: (item) => (\n            <ListItem\n              key={item.key}\n              item={item}\n              state={state}\n              onAction={() => onAction?.(item.key)}\n              listFocused={showAsFocused || focused}\n            />\n          ),\n        })\n      )}\n    </StyledList>\n  );\n});\n","import React from \"react\";\nimport { StyledVerticalSeparator } from \"../StyledSeparator\";\nimport { useSeparator } from \"@react-aria/separator\";\n\nexport const ListDivider: React.FC = () => {\n  return (\n    <StyledVerticalSeparator\n      as={\"li\"}\n      {...useSeparator({ elementType: \"li\", orientation: \"vertical\" })\n        .separatorProps}\n    />\n  );\n};\n","import React from \"react\";\nimport { Node } from \"@react-types/shared\";\nimport { ListState } from \"@react-stately/list\";\nimport { usePress } from \"@react-aria/interactions\";\nimport { useSelectableItem } from \"@intellij-platform/core/selection\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections\";\nimport { StyledListItem } from \"./StyledListItem\";\n\nexport interface ListItemProps<T> {\n  listFocused: boolean;\n  item: Node<T>;\n  state: ListState<T>;\n  onAction: () => void;\n  children?: React.ReactNode;\n}\n\nexport function ListItem<T>({\n  listFocused,\n  item,\n  state,\n  onAction,\n  children,\n}: ListItemProps<T>) {\n  const ref = React.useRef(null);\n  const isDisabled = state.disabledKeys.has(item.key);\n  const isSelected = state.selectionManager.isSelected(item.key);\n\n  const { itemProps } = useSelectableItem({\n    key: item.key,\n    ref,\n    onAction,\n    selectionManager: state.selectionManager,\n  });\n  let { pressProps } = usePress({\n    ...itemProps,\n    isDisabled,\n    preventFocusOnPress: false,\n  });\n\n  return (\n    <StyledListItem\n      containerFocused={listFocused}\n      selected={isSelected}\n      disabled={isDisabled}\n      aria-disabled={isDisabled}\n      aria-selected={isSelected}\n      {...pressProps}\n      ref={ref}\n    >\n      <ItemStateContext.Provider\n        value={{\n          isDisabled,\n          isSelected,\n          isContainerFocused: listFocused,\n          node: item,\n        }}\n      >\n        {children || item.rendered}\n      </ItemStateContext.Provider>\n    </StyledListItem>\n  );\n}\n","import { css } from \"styled-components\";\nimport { styled } from \"../styled\";\n\nexport const StyledList = styled.ul.withConfig<{\n  fillAvailableSpace?: boolean;\n}>({\n  shouldForwardProp: (prop) => prop !== \"fillAvailableSpace\",\n})`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  max-height: 100%;\n  overflow: auto;\n  color: ${({ theme }) => theme.color(\"*.textForeground\")};\n  outline: none;\n  ${({ fillAvailableSpace }) =>\n    fillAvailableSpace &&\n    css`\n      flex: 1;\n      height: fill-available; // will be converted to --webkit-fill-available and --moz-available, but doesn't work in FF\n    `}\n  background: ${({ theme }) => theme.color(\"List.background\")};\n`;\n","import { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { styled } from \"../styled\";\n\nexport type StyledListItemProps = {\n  containerFocused: boolean;\n  selected: boolean;\n  disabled: boolean;\n};\n\nexport const StyledListItem = styled.li<StyledListItemProps>(\n  ({ containerFocused, selected, disabled, theme }) => {\n    let backgroundColor;\n    let color = disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\n          \"List.foreground\" as UnknownThemeProp<\"List.foreground\">,\n          theme.commonColors.labelForeground\n        );\n    if (selected) {\n      if (containerFocused) {\n        color = theme.asCurrentForeground(\n          theme.color(\n            \"List.selectionForeground\" as UnknownThemeProp<\"List.selectionForeground\">\n          ) || theme.commonColors.labelSelectedForeground\n        ) /* Prioritizing \"*.selectionForeground\" over labelSelectedForeground*/;\n        backgroundColor = theme.color(\n          \"List.selectionBackground\" as UnknownThemeProp<\"List.selectionBackground\">\n        );\n      } else {\n        color = theme.color(\n          \"List.selectionInactiveForeground\" as UnknownThemeProp<\"List.selectionInactiveForeground\">,\n          color\n        );\n        backgroundColor = theme.color(\n          \"List.selectionBackgroundInactive\" as UnknownThemeProp<\"List.selectionBackgroundInactive\">\n        );\n      }\n    }\n    return {\n      backgroundColor,\n      color,\n      position: \"relative\",\n      display: \"flex\",\n      whiteSpace: \"nowrap\",\n      paddingLeft: \"0.5rem\", // themed?\n      paddingRight: \"0.5rem\", // themed?\n      lineHeight: \"20px\",\n      outline: \"none\",\n      cursor: \"default\",\n      minWidth: \"min-content\", // ?\n    };\n  }\n);\n","import { styled } from \"../styled\";\n\nexport const StyledListSectionHeader = styled.li(({ theme }) => ({\n  paddingLeft: 8,\n  fontWeight: \"bold\",\n  lineHeight: \"20px\",\n  outline: \"none\",\n  cursor: \"default\",\n  color: theme.color(\"*.textForeground\", theme.color(\"*.foreground\")),\n}));\n","import { Node } from \"@react-types/shared\";\nimport React from \"react\";\nimport { StyledListSectionHeader } from \"./StyledListSectionHeader\";\nimport { ListDivider } from \"./ListDivider\";\n\ninterface SectionNode<T> extends Node<T> {\n  type: \"section\";\n}\n\ninterface ItemNode<T> extends Node<T> {\n  type: \"item\";\n}\n\ninterface DividerNode<T> extends Node<T> {\n  type: \"divider\";\n}\n\nconst isItemNode = <T extends any>(node: Node<T>): node is ItemNode<T> =>\n  node.type === \"item\";\nconst isSectionNode = <T extends any>(node: Node<T>): node is SectionNode<T> =>\n  node.type === \"section\";\nconst isDividerNode = <T extends any>(node: Node<T>): node is DividerNode<T> =>\n  node.type === \"divider\";\n\ntype listItemRendererArgs<T extends any> = {\n  item: (item: ItemNode<T>) => React.ReactNode;\n  sectionHeader?: (item: SectionNode<T>) => React.ReactNode;\n};\nexport const listItemRenderer = <T extends any>({\n  item: renderItem,\n  sectionHeader: renderSectionHeader = (item) => (\n    <StyledListSectionHeader>{item.rendered}</StyledListSectionHeader>\n  ),\n}: listItemRendererArgs<T>) => {\n  return render;\n\n  function render(item: Node<T>): React.ReactNode {\n    if (isItemNode(item)) {\n      return renderItem(item);\n    }\n    if (isSectionNode(item)) {\n      return (\n        <React.Fragment key={item.key}>\n          {renderSectionHeader(item)}\n          {[...(item.childNodes as ItemNode<T>[])].map(render)}\n        </React.Fragment>\n      );\n    }\n    if (isDividerNode(item)) {\n      return <ListDivider key={item.key} />;\n    }\n    return null;\n  }\n};\n","import { AriaSelectableListOptions } from \"@react-aria/selection\";\nimport { ListState } from \"@react-stately/list\";\nimport React, { useEffect, useState } from \"react\";\nimport { useSelectableList } from \"./useSelectableList\";\nimport { useFocusWithin } from \"@react-aria/interactions\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { CollectionRefProps } from \"@intellij-platform/core/Collections/useCollectionRef\";\n\nexport interface ListProps\n  extends Omit<\n      AriaSelectableListOptions,\n      | \"disallowEmptySelection\"\n      | \"selectOnFocus\"\n      | \"selectionManager\" // Grouped as state, the second argument, like in useListBox\n      | \"collection\" // Grouped as state, the second argument, like in useListBox\n      | \"disabledKeys\" // Grouped as state, the second argument, like in useListBox\n      | \"ref\" // Third argument\n    >,\n    CollectionRefProps {\n  allowEmptySelection?: boolean;\n  id?: string;\n}\n// import { useSelectableList } from \"@react-aria/selection\";\n\nexport function useList<T>(\n  props: ListProps,\n  state: ListState<T>,\n  ref: React.RefObject<HTMLElement>\n) {\n  const {\n    listProps: { onMouseDown, ...listProps },\n  } = useSelectableList({\n    ...props,\n    ref,\n    selectionManager: state.selectionManager,\n    disallowEmptySelection: !props.allowEmptySelection,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys,\n    // if selectOnFocus is going to be an option (which is not in intellij UI), we should also conditionally show outline on items\n    selectOnFocus: true,\n  });\n  const [focused, setFocused] = useState(false);\n\n  const { focusWithinProps } = useFocusWithin({\n    onFocusWithinChange: setFocused,\n  });\n\n  // auto select the first item, if selection is empty and allowEmptySelection is false.\n  useEffect(() => {\n    const firstKey = state.collection.getFirstKey();\n    if (\n      !props.allowEmptySelection &&\n      state.selectionManager.isEmpty &&\n      firstKey\n    ) {\n      state.selectionManager.setFocusedKey(firstKey);\n      state.selectionManager.select(firstKey);\n    }\n  }, [!props.allowEmptySelection]);\n\n  return {\n    listProps: mergeProps(listProps, focusWithinProps),\n    focused,\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n  Collection,\n  FocusStrategy,\n  KeyboardDelegate,\n  Node,\n} from \"@react-types/shared\";\nimport { HTMLAttributes, Key, RefObject, useMemo } from \"react\";\nimport { ListKeyboardDelegate } from \"@react-aria/selection\";\nimport {\n  MultipleSelectionManager,\n  SelectionManager,\n} from \"@react-stately/selection\";\nimport { useCollator } from \"@react-aria/i18n\";\nimport { useSelectableCollection } from \"@intellij-platform/core/selection\";\nimport { useCollectionAutoScroll } from \"@intellij-platform/core/Collections/useCollectionAutoScroll\";\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager;\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>;\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise\n   * interacted with.\n   */\n  disabledKeys: Set<Key>;\n  /**\n   * A ref to the item.\n   */\n  ref: RefObject<HTMLElement>;\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate;\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy;\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean;\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean;\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean;\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean;\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean;\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean;\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean;\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>;\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(\n  props: SelectableListOptions\n): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({ usage: \"search\", sensitivity: \"base\" });\n  let delegate = useMemo(\n    () =>\n      keyboardDelegate ||\n      new ListKeyboardDelegate(collection, disabledKeys, ref, collator),\n    [keyboardDelegate, collection, disabledKeys, ref, collator]\n  );\n  useCollectionAutoScroll(\n    { isVirtualized, selectionManager: selectionManager as SelectionManager },\n    ref\n  );\n\n  let { collectionProps } = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n  });\n\n  return {\n    listProps: collectionProps,\n  };\n}\n","import {\n  ListProps,\n  ListState,\n  useListState as originalUseListState,\n} from \"@react-stately/list\";\nimport {\n  CollectionRefProps,\n  useCollectionRef,\n} from \"@intellij-platform/core/Collections/useCollectionRef\";\n\nexport function useListState<T extends object>(\n  props: ListProps<T> & CollectionRefProps\n): ListState<T> {\n  const state = originalUseListState({\n    ...props,\n    selectionBehavior: \"replace\",\n  });\n  useCollectionRef(props, state);\n  return state;\n}\n","import React, { HTMLAttributes, HTMLProps } from \"react\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { useMenuTriggerState } from \"@react-stately/menu\";\nimport { OverlayTriggerProps } from \"@react-types/overlays\";\n\nimport { useContextMenu } from \"./useContextMenu\";\nimport { MenuOverlay } from \"./MenuOverlay\";\n\ninterface ContextMenuContainerProps extends HTMLProps<HTMLDivElement> {\n  /**\n   * Will be called to return the Menu when context menu is triggered. Use {@link Menu} component to render a menu.\n   */\n  renderMenu: () => React.ReactNode;\n  /**\n   * If children is a function, context menu props is passed to it, to be passed to the underlying element.\n   * Otherwise, a div container will be rendered.\n   */\n  children:\n    | React.ReactNode\n    | ((props: HTMLAttributes<HTMLElement>) => React.ReactNode);\n}\n\n/**\n * A generic container for context menu. It's the same as a normal div, only with an additional `renderMenu` prop,\n * to be used to render context menu, when it's triggered.\n * Closes the menu when a menu action is triggered.\n */\nexport const ContextMenuContainer = ({\n  children,\n  renderMenu,\n  ...props\n}: ContextMenuContainerProps) => {\n  const state = useMenuTriggerState({} as OverlayTriggerProps);\n\n  const { overlayProps, containerProps, overlayRef } = useContextMenu(\n    {},\n    state\n  );\n  const allProps = mergeProps(props, containerProps);\n  return (\n    <>\n      {typeof children === \"function\" ? (\n        children(allProps)\n      ) : (\n        <div {...allProps}>{children}</div>\n      )}\n      <MenuOverlay\n        state={state}\n        overlayRef={overlayRef}\n        overlayProps={overlayProps}\n        restoreFocus\n      >\n        {renderMenu()}\n      </MenuOverlay>\n    </>\n  );\n};\n","import React, { useRef } from \"react\";\nimport { MenuTriggerState } from \"@react-stately/menu\";\nimport { useOverlay } from \"@react-aria/overlays\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { useMouseEventOverlayPosition } from \"@intellij-platform/core/utils/useMouseEventOverlayPosition\";\nimport { areInNestedOverlays } from \"@intellij-platform/core/Overlay\";\n\n/**\n * Functionality and accessibility of context menu.\n */\nexport const useContextMenu = (\n  { isDisabled = false }: { isDisabled?: boolean },\n  state: MenuTriggerState\n) => {\n  /**\n   * NOTE: not using useMenuTrigger because:\n   * - There is no option to have a trigger like this: \"right click + long press only by touch\" which seems to be the\n   *   reasonable trigger for context menu. If we want to use it just for long press, we could disable it if it's not\n   *   a touch device, but that would be suboptimal, since both touch and mouse can be available, and it should depend\n   *   not on availability of touch, but on the triggered event type. Plus, isDisabled is broken in v<3.5.0\n   * - It's not quite clear at the moment, if the aria attributes that useMenuTrigger sets would be applicable in case\n   *   of this context menu component too. the trigger is not the container. For example, if there is a list rendered\n   *   inside, the selected item would be the trigger. Maybe even this component, as a container for context menu\n   *   is not the best way to allow for context menu, when comes to a11y concerns. For now, we skip a11y props of the\n   *   trigger. A11y props of the menu itself (e.g. aria-label) would also be up to the usage of this component.\n   *\n   *   TODO: add support for long touch\n   */\n  const onContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n    e.preventDefault();\n    // NOTE: we can't use offsetX/offsetY, because it would depend on the exact target that was clicked.\n    if (!state.isOpen) {\n      state.open(null);\n    }\n    updatePosition(e);\n  };\n\n  const overlayRef = useRef(null);\n\n  const { overlayProps: positionProps, updatePosition } =\n    useMouseEventOverlayPosition({\n      overlayRef,\n      placement: \"bottom start\",\n      // shouldFlip should be false, but it doesn't work as expected. Overlay container is rendered within the view port\n      // but the menu overflows from the overlay container\n      shouldFlip: true,\n      offset: -8,\n      isOpen: state.isOpen,\n    });\n  const { overlayProps } = useOverlay(\n    {\n      onClose: () => {\n        return state.close();\n      },\n      shouldCloseOnBlur: false,\n      isOpen: state.isOpen,\n      isKeyboardDismissDisabled: false,\n      isDismissable: true,\n      shouldCloseOnInteractOutside: (element) => {\n        return !areInNestedOverlays(overlayRef.current, element);\n      },\n    },\n    overlayRef\n  );\n\n  const containerProps: React.HTMLAttributes<HTMLElement> = isDisabled\n    ? {}\n    : { onContextMenu };\n  return {\n    /**\n     * props to be applied on the container element which is supposed to have the context menu\n     */\n    containerProps,\n    /**\n     * The ref to be applied on the menu overlay wrapper. It's usually an input instead of an output in similar\n     * react-aria hooks, but it seemed unnecessary here.\n     */\n    overlayRef,\n    /**\n     * props to be applied on the menu overlay wrapper.\n     */\n    overlayProps: mergeProps(overlayProps, positionProps),\n  };\n};\n","import { Item, PartialNode, Section } from \"@react-stately/collections\";\nimport { Item as Item2 } from \"./Item\";\nimport {\n  CollectionBase,\n  CollectionElement,\n  ItemProps,\n  SectionProps,\n} from \"@react-types/shared\";\nimport React from \"react\";\n\nfunction* patchCollectionItem<T>(nodes: Generator<PartialNode<T>>) {\n  for (const partialNode of nodes)\n    yield {\n      ...partialNode,\n      *childNodes() {\n        const result2 = partialNode.childNodes?.();\n        if (result2) {\n          for (const partialChildNode of result2) {\n            const { type, ...partialChildNodeWithoutType } = partialChildNode;\n            yield partialChildNodeWithoutType;\n          }\n        }\n      },\n    };\n}\n\nconst PatchedItem = Item.bind(null);\n\n// @ts-expect-error: getCollectionNode is not public\nPatchedItem.getCollectionNode = function getCollectionNode<T>(\n  props: ItemProps<T>,\n  context: any\n): Generator<PartialNode<T>> {\n  // @ts-expect-error getCollectionNode is not public API\n  return patchCollectionItem(Item.getCollectionNode(props, context));\n};\n\nconst PatchedSection = Section.bind(null);\n\n// @ts-expect-error: getCollectionNode is not public\nPatchedSection.getCollectionNode = function getCollectionNode<T>(\n  props: SectionProps<T>,\n  context: any\n): Generator<PartialNode<T>> {\n  // @ts-expect-error getCollectionNode is not public API\n  return patchCollectionItem(Section.getCollectionNode(props, context));\n};\nfunction convertCollectionElement<T>(\n  result: CollectionElement<T> | React.ReactNode\n): CollectionElement<T> {\n  if (\n    React.isValidElement(result) &&\n    (result.type === Item || result.type === Item2)\n  ) {\n    return React.createElement(\n      PatchedItem,\n      {\n        key: result.key != null ? result.key : undefined,\n        ...(result.props as ItemProps<T>),\n      },\n      convertChildren(result.props.children)\n    ) as CollectionElement<T>;\n  }\n  if (React.isValidElement(result) && result.type === Section) {\n    return React.createElement(\n      PatchedSection,\n      {\n        key: result.key != null ? result.key : undefined,\n        ...(result.props as SectionProps<T>),\n      } as any,\n      convertChildren((result.props as any).children)\n    ) as CollectionElement<T>;\n  }\n  return result as CollectionElement<T>;\n}\n\nfunction convertChildren<T>(children: React.ReactNode): React.ReactNode {\n  return Array.isArray(children)\n    ? // NOTE: We intentionally avoid using React.Children.map as it messes with keys.\n      children.map(convertChildren)\n    : convertCollectionElement(children);\n}\n\n/**\n * CollectionBuilder expects child type to be the same as parent type, which is weird in the first place:\n * https://github.com/adobe/react-spectrum/blob/cae83ff95f2f709b761c70d47ace96d6346ed873/packages/%40react-stately/collections/src/CollectionBuilder.ts#L148\n * On the other hand, the default Item components sets the `type` to item, for all child PartialNode objects:\n * https://github.com/adobe/react-spectrum/blob/c49d9819adc2cb63377f39557352440c72072caf/packages/%40react-stately/collections/src/Item.ts#L40-L54\n * Which is also a little unexpected, as in many nested collections, an item can have all types of children.\n * This function patches that, replacing Item elements with PatchedItem element which doesn't set type on children\n * PartialNodes.\n */\nexport function patchCollectionProps<T>({\n  children,\n  ...props\n}: CollectionBase<T>): CollectionBase<T> {\n  return {\n    ...props,\n    children:\n      typeof children === \"function\"\n        ? (node: T) => convertChildren(children(node)) as CollectionElement<T>\n        : (convertChildren(children) as CollectionElement<T>),\n  };\n}\n","import React, { CSSProperties, Key, RefObject, useContext } from \"react\";\nimport { AriaMenuOptions, useMenu as useMenuAria } from \"@react-aria/menu\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { AriaMenuProps } from \"@react-types/menu\";\nimport { Node } from \"@react-types/shared\";\nimport { patchCollectionProps } from \"@intellij-platform/core/Collections/patchCollectionProps\";\nimport { TreeProps, useTreeState } from \"../Tree/useTreeState\"; // shared dependency between tree and menu, that could be lifted up import {Submenu} from '@intellij-platform/core/Menu/Submenu'\nimport { renderMenuNodes } from \"./renderMenuNodes\";\nimport { StyledMenu } from \"./StyledMenu\";\nimport { SubmenuProps } from \"./Submenu\"; // internal export\n\nexport interface MenuProps<T>\n  extends Omit<\n    AriaMenuProps<T>,\n    // selection is not properly supported for nested menus. Plus, it's not even that meaningful for a nested menu\n    // at least the way it's implemented now.\n    | \"onSelectionChange\"\n    | \"defaultSelectedKeys\"\n    | \"selectionMode\"\n    | \"disallowEmptySelection\"\n  > {\n  /**\n   * Indicates currently expanded menu item (controlled).\n   */\n  expandedKey?: Key; // FIXME: should be keys\n  /**\n   * Called when expanded menu item is changed by user interaction, which can be either hovering over the menu item\n   */\n  onExpandedKeyChange?: (expandedKey: Key) => void; // FIXME: should be keys\n  defaultExpandedKey?: Key; // FIXME: should be keys\n  /**\n   * @deprecated\n   */\n  expandOn?: \"hover\" | \"press\"; // hover delay doesn't seem to be needed as an option\n\n  /**\n   * Defines the press behaviour (either by mouse or by pressing Enter when focused) on menu items with submenu.\n   * By default (undefined), pressing or hovering over a menu item with submenu, opens the submenu.\n   * When set to \"toggle\", pressing a menu item with submenu will toggle the submenu. Hovering over such items will\n   * no longer open the submenu.\n   * When set to \"action\", pressing a menu item with submenu will call onAction for that item, and closes the menu.\n   * Hovering over such items will no longer open the submenu.\n   *\n   * In all cases, pressing the right arrow will always open the submenu.\n   */\n  submenuBehavior?: \"default\" | \"toggleOnPress\" | \"actionOnPress\";\n\n  /**\n   * fills the available horizontal or vertical space, when rendered in a flex container.\n   */\n  fillAvailableSpace?: boolean;\n\n  /**\n   * Minimum width of the menu\n   * @default: 120px\n   */\n  minWidth?: CSSProperties[\"minWidth\"];\n}\n\n/**\n * Can be provided by the overlay where the menu is rendered in. If provided, menu will call the provided close function\n * on actions. Note that there is no `closeOnSelect` option as of now, on this context, since no use case seems to exist\n * for keeping the menu overlay open after a menu item is selected.\n * **Update**: there are use cases where the menu is not closed after an item is clicked. Most of the toggle-able\n * actions (the ones with a checkmark) seem to be like this.\n * TODO: Make \"close on selection\" more flexible. Some ideas:\n *  - instead of calling close, pass it to `onAction` handler. Then on each action, one would need to call close if\n *    needed.\n *  - Offer a `MenuItem` component to be used instead of generic `Item`, where it accepts `closeOnSelect` boolean, which\n *    is true by default.\n *  - pass a `keepOpen` function to `onAction`.\n *  - Allow signaling whether the menu should kept open, via the returned value of onAction. e.g. return false means keep open.\n *  Last two suggestions are based on the assumption that most of the menu items are not selectable.\n *  Note that MenuOverlayContext could be used directly in action handlers too, but baking it into the menu makes it\n *  much more convenient, which seems more important than breaking the nice separation between Menu and MenuTrigger.\n */\nexport const MenuOverlayContext = React.createContext({ close: () => {} });\nexport const MenuContext = React.createContext<\n  Pick<\n    MenuProps<unknown>,\n    \"onClose\" | \"onAction\" | \"submenuBehavior\" | \"autoFocus\"\n  > & {\n    itemWrapper?: (\n      renderedItem: React.ReactNode,\n      item: Node<unknown>\n    ) => React.ReactNode;\n    renderSubmenu?: (props: SubmenuProps<unknown>) => React.ReactNode;\n  }\n>({});\n\nexport function useMenu<T>(\n  {\n    onAction: onActionProp,\n    submenuBehavior = \"default\",\n    ...props\n  }: MenuProps<T> & AriaMenuOptions<T>,\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n) {\n  const { close } = useContext(MenuOverlayContext);\n  const onClose = () => {\n    props.onClose?.();\n    close();\n  };\n  const onAction = (key: Key) => {\n    if (\n      // The following check should have been in useMenu, but it's not currently. Probably because they haven't yet\n      // covered nested menus.\n      !state.collection.getItem(key)?.hasChildNodes\n    ) {\n      return onActionProp?.(key);\n    } else if (submenuBehavior === \"actionOnPress\") {\n      onClose();\n      return onActionProp?.(key);\n    }\n  };\n  const menuContextValue: React.ContextType<typeof MenuContext> = {\n    submenuBehavior,\n    autoFocus: props.autoFocus,\n    onAction,\n    onClose,\n  };\n  const { menuProps } = useMenuAria(\n    { ...props, onAction, onClose },\n    state,\n    ref\n  );\n\n  return {\n    menuProps,\n    menuContextValue,\n  };\n}\n\nexport function useMenuState<T extends object>(\n  props: TreeProps<T> &\n    Pick<\n      MenuProps<T>,\n      \"expandedKey\" | \"defaultExpandedKey\" | \"onExpandedKeyChange\"\n    >\n) {\n  props = patchCollectionProps(props);\n  return useTreeState({\n    ...props,\n    childExpansionBehaviour: \"single\",\n    expandedKeys: props.expandedKey ? [props.expandedKey] : undefined,\n    onExpandedChange: ([firstKey]) => props?.onExpandedKeyChange?.(firstKey),\n    defaultExpandedKeys: props.defaultExpandedKey\n      ? [props.defaultExpandedKey]\n      : undefined,\n  });\n}\n\n/**\n * UI for menus which are normally shown in a popover. Being rendered as an overlay is not handled here.\n * Also, there is no coupling with any higher level entity like \"Action\", since this is just for the UI layer.\n * Something like ActionMenu which creates a menu out of a list of actions can be implemented on top of this.\n *\n * @example\n *  <Menu>\n *    <Item>Item one</Item>\n *    <Item>\n *      <MenuItemLayout\n *        icon={<PlatformIcon icon={\"actions/copy\"} />}\n *        content=\"Copy\"\n *        shortcut={\"⌘C\"} />\n *    </Item>\n *  </Menu>\n *\n *  Current issues and limitations:\n *  - Divider in sub-menu's is not supported. because of a constraint in @react-stately/collections, which results in\n *    this error: Unsupported type <Divider> in <Item>. Only <Item> is supported. Maybe supporting section would\n *    be a workaround for it.\n *  - when a parent menu item which has an open submenu is hovered, it gets focus.\n */\nexport function Menu<T extends object>({ minWidth, ...props }: MenuProps<T>) {\n  const ref = React.useRef<HTMLUListElement>(null);\n  const state = useMenuState(props);\n  const { menuContextValue, menuProps } = useMenu(props, state, ref);\n\n  return (\n    /**\n     * MenuContext is used to pass onAction and onClose to be passed to useMenu in submenus.\n     * That's needed because in useMenuItem onAction and onClose are read off a WeakMap which has the menu state\n     * (TreeState) as key. So we have to pass onAction and onClose everytime we call useMenu in submenus, to let the\n     * menu items in that submenu access the right value of onAction and onClose. To avoid drilling these props down,\n     * we keep it in a context.\n     */\n    <MenuContext.Provider value={menuContextValue}>\n      <StyledMenu\n        {...menuProps}\n        ref={ref}\n        style={{ minWidth }}\n        fillAvailableSpace={props.fillAvailableSpace}\n      >\n        {renderMenuNodes(state, [...state.collection])}\n      </StyledMenu>\n    </MenuContext.Provider>\n  );\n}\n","import React, { HTMLAttributes, ReactNode, RefObject, useContext } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { isFocusVisible, useHover, usePress } from \"@react-aria/interactions\";\nimport {\n  AriaMenuItemProps,\n  MenuItemAria,\n  useMenuItem as useMenuItemAria,\n} from \"@react-aria/menu\";\nimport { useOverlayPosition } from \"@react-aria/overlays\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { FocusableElement, Node } from \"@react-types/shared\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections/ItemStateContext\";\nimport { Overlay } from \"@intellij-platform/core/Overlay\";\n\nimport { LafIcon, PlatformIcon } from \"../Icon\";\nimport { styled } from \"../styled\";\nimport { MenuContext, MenuProps } from \"./Menu\";\nimport { MENU_BORDER_WIDTH, MENU_VERTICAL_PADDING } from \"./StyledMenu\";\nimport {\n  StyledMenuItem,\n  StyledMenuItemIcon,\n  StyledNestedArrow,\n} from \"./StyledMenuItem\";\nimport { Submenu, SubmenuProps } from \"@intellij-platform/core/Menu/Submenu\";\n\nexport interface MenuItemProps<T> {\n  item: Node<T>;\n  state: TreeState<T>;\n  onSubmenuClose?: () => void;\n}\n\nconst StyledMenuItemText = styled.span`\n  flex: 1;\n`;\n\nconst StyledMenuItemPlatformIcon = styled(PlatformIcon)`\n  svg path {\n    stroke: currentColor;\n  }\n`;\n\nconst StyledMenuItemLafIcon = styled(LafIcon)`\n  svg path {\n    stroke: currentColor;\n  }\n`;\n\nfunction useMenuItem<T extends unknown>(\n  {\n    submenuBehavior,\n    ...props\n  }: AriaMenuItemProps & { submenuBehavior: MenuProps<T>[\"submenuBehavior\"] },\n  state: TreeState<T>,\n  ref: RefObject<FocusableElement>\n): MenuItemAria {\n  const item = state.collection.getItem(props.key!);\n  const isDisabled = state.disabledKeys.has(item.key);\n  const isExpanded = state.expandedKeys.has(item.key);\n  const hasSubmenu = item.hasChildNodes;\n  const { menuItemProps: ariaMenuItemProps, ...result } = useMenuItemAria(\n    {\n      key: item.key,\n      // hack to prevent react-aria to call onClose when nested items are selected, which is incorrect, and because\n      // react-aria doesn't officially support nested menus at the moment\n      onClose: hasSubmenu ? () => {} : undefined,\n    },\n    state,\n    ref\n  );\n\n  // useMenuItem in react aria utilizes useHover to focus item on hover. The logic there conflicts with nested menus\n  // requirements (at least based on how nested menu is implemented here currently). Also, submenuBehavior requires\n  // some more customization. So we delete the handlers set by useHover in useMenuItem, and add a custom useHover.\n  delete ariaMenuItemProps.onMouseEnter;\n  delete ariaMenuItemProps.onPointerEnter;\n\n  if (submenuBehavior === \"default\" && isExpanded) {\n    // When menu item has its submenu opened, clicking it should not move focus or do anything.\n    delete ariaMenuItemProps.onPointerDown;\n  }\n\n  const { hoverProps } = useHover({\n    isDisabled: isDisabled,\n    onHoverStart: () => {\n      const isAnySubmenuOpen = [...state.expandedKeys].some(\n        (expandedKey) =>\n          state.collection.getItem(expandedKey)?.parentKey === item.parentKey\n      );\n\n      if (submenuBehavior === \"default\" && !isExpanded) {\n        state.toggleKey(item.key);\n      }\n\n      if (!isFocusVisible()) {\n        const shouldFocus =\n          submenuBehavior === \"default\" ? !isExpanded : !isAnySubmenuOpen;\n        if (shouldFocus) {\n          state.selectionManager.setFocused(true);\n        }\n        state.selectionManager.setFocusedKey(item.key);\n      }\n    },\n  });\n\n  const keyboardProps = {\n    onKeyDown: (e: React.KeyboardEvent) => {\n      if (\n        ((e.key === \"Enter\" || e.key === \" \") &&\n          submenuBehavior !== \"actionOnPress\") ||\n        \"ArrowRight\" === e.key\n      ) {\n        state.toggleKey(item.key);\n        e.stopPropagation();\n        return;\n      }\n    },\n  };\n\n  const { pressProps: togglePressProps } = usePress({\n    isDisabled: isDisabled,\n    onPressUp: () => {\n      state.toggleKey(item.key);\n      if (isExpanded) {\n        // submenu was expanded and is closed now. moving focus back to the parent item\n        state.selectionManager.setFocusedKey(item.key);\n      }\n    },\n  });\n\n  return {\n    ...result,\n    menuItemProps: mergeProps(\n      hasSubmenu\n        ? {\n            \"aria-expanded\": isExpanded,\n            \"aria-haspopup\": \"menu\",\n          }\n        : {},\n      ariaMenuItemProps,\n      hoverProps,\n      keyboardProps,\n      submenuBehavior === \"toggleOnPress\" ? togglePressProps : {}\n    ),\n  };\n}\n\nconst MenuItemContext = React.createContext<{\n  labelProps: HTMLAttributes<HTMLElement>;\n  descriptionProps: HTMLAttributes<HTMLElement>;\n  keyboardShortcutProps: HTMLAttributes<HTMLElement>;\n}>({ descriptionProps: {}, labelProps: {}, keyboardShortcutProps: {} });\n\nexport const useMenuItemLayout = () => {\n  return useContext(MenuItemContext);\n};\n\nexport function MenuItem<T>({ item, state }: MenuItemProps<T>) {\n  // Get props for the menu item element\n  const ref = React.useRef<HTMLLIElement>(null);\n  const nestedMenuRef = React.useRef<HTMLDivElement>(null);\n  const isDisabled = state.disabledKeys.has(item.key);\n  const isExpanded = state.expandedKeys.has(item.key);\n  const isSelected = state.selectionManager.selectedKeys.has(item.key);\n  const isFocused = state.selectionManager.focusedKey === item.key;\n  const {\n    onClose,\n    submenuBehavior,\n    renderSubmenu = (props: SubmenuProps<T>) => <Submenu {...props} />,\n    itemWrapper = (i: React.ReactNode) => i,\n  } = useContext(MenuContext);\n\n  const { menuItemProps, labelProps, descriptionProps, keyboardShortcutProps } =\n    useMenuItem(\n      {\n        submenuBehavior,\n        key: item.key,\n      },\n      state,\n      ref\n    );\n\n  const { pressProps: togglePressProps } = usePress({\n    isDisabled: isDisabled,\n    onPressUp: () => {\n      state.toggleKey(item.key);\n      if (isExpanded) {\n        // submenu was expanded and is closed now. moving focus back to the parent item\n        state.selectionManager.setFocusedKey(item.key);\n      }\n    },\n  });\n\n  let { overlayProps: positionProps } = useOverlayPosition({\n    targetRef: ref,\n    overlayRef: nestedMenuRef,\n    placement: \"right top\",\n    shouldFlip: true,\n    onClose,\n    offset: 0,\n    crossOffset: -(MENU_VERTICAL_PADDING + MENU_BORDER_WIDTH),\n    isOpen: isExpanded,\n  });\n\n  const arrowProps: HTMLAttributes<HTMLElement> =\n    submenuBehavior !== \"default\"\n      ? {\n          role: \"button\",\n          \"aria-label\": \"Open\",\n          ...mergeProps(togglePressProps, {\n            // to prevent pointer up event handler on the item, which would trigger action.\n            onPointerUp: (e: React.PointerEvent) => e.stopPropagation(),\n          }),\n        }\n      : {};\n  return (\n    <>\n      <StyledMenuItem\n        {...menuItemProps}\n        isDisabled={isDisabled}\n        isActive={isFocused}\n        ref={ref}\n      >\n        {isSelected && (\n          <StyledMenuItemIcon>\n            <StyledMenuItemLafIcon\n              icon={{\n                name: \"checkmark\",\n                modifiers: { Selected: isFocused },\n              }}\n            />\n          </StyledMenuItemIcon>\n        )}\n        <ItemStateContext.Provider\n          value={{\n            isDisabled,\n            isContainerFocused: state.selectionManager.isFocused,\n            isSelected,\n            node: item,\n          }}\n        >\n          <MenuItemContext.Provider\n            value={{ labelProps, descriptionProps, keyboardShortcutProps }}\n          >\n            {itemWrapper(\n              typeof item.rendered === \"string\" ? (\n                <StyledMenuItemText {...labelProps}>\n                  {item.rendered}\n                </StyledMenuItemText>\n              ) : (\n                item.rendered\n              ),\n              item\n            )}\n          </MenuItemContext.Provider>\n        </ItemStateContext.Provider>\n        {item.hasChildNodes && (\n          <StyledNestedArrow {...arrowProps}>\n            <StyledMenuItemPlatformIcon icon=\"icons/ide/menuArrow\" />\n          </StyledNestedArrow>\n        )}\n      </StyledMenuItem>\n      {isExpanded && (\n        /**\n         * A note about using Overlay:\n         * If sub-menu is not rendered in a portal, useOverlayPosition doesn't work properly and the submenu may\n         * be rendered offscreen. Worse, it may introduce scroll in body (or some scrollable ancestor), which will\n         * trigger a scroll event which closes the menu if the menu is rendered in an overlay (like in MenuTrigger),\n         * which is almost always the case.\n         *\n         */\n        <Overlay\n          OverlayComponent={\n            /**\n             *  The FocusScope included in the default Overlay, messes with a particular expected behavior. So we use\n             *  SimpleOverlay, which just renders its children as a portal. There may be a better solution for that\n             *  problem, which would eliminate the need for the funky `OverlayComponent` prop on our `Overlay`\n             *  component. Something to look into in the future.\n             */\n            SimpleOverlay\n          }\n        >\n          <div ref={nestedMenuRef} {...positionProps}>\n            {renderSubmenu({ parentState: state, rootKey: item.key })}\n          </div>\n        </Overlay>\n      )}\n    </>\n  );\n}\n\n/**\n * A replacement for react-aria Overlay, which doesn't render FocusScope\n */\nfunction SimpleOverlay({\n  children,\n  portalContainer = document.body,\n}: {\n  children: ReactNode;\n  portalContainer?: Element | undefined;\n}) {\n  return ReactDOM.createPortal(children, portalContainer);\n}\n","import React from \"react\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections/ItemStateContext\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { useContextOrThrow } from \"@intellij-platform/core/utils/useContextOrThrow\";\n\nimport { useMenuItemLayout } from \"./MenuItem\";\nimport { StyledMenuItemIcon } from \"./StyledMenuItem\";\n\ninterface MenuItemLayoutProps {\n  icon?: React.ReactNode;\n  content: React.ReactNode;\n  shortcut?: React.ReactNode;\n}\n\nconst StyledMenuItemLayout = styled.div`\n  display: flex;\n  align-items: center;\n  flex: 1; // to make sure it takes as much space as available in the menu item row, so that the suffix (shortcut) is pushed to the right\n`;\nconst Content = styled.span`\n  flex: 1;\n`;\n\nconst Shortcut = styled.kbd`\n  font-family: system-ui, sans-serif;\n  margin-left: 30px;\n  margin-right: -0.625rem;\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(\n      theme.color(\"MenuItem.acceleratorForeground\")\n    )};\n`;\n\nexport const MenuItemLayout = ({\n  content,\n  shortcut,\n  icon,\n}: MenuItemLayoutProps) => {\n  const { isSelected } = useContextOrThrow(\n    ItemStateContext,\n    \"MenuItemLayout is meant to be rendered in Item component in Menus\"\n  );\n  const { labelProps, keyboardShortcutProps } = useMenuItemLayout();\n  const allowedIcon = !isSelected && icon;\n  return (\n    <StyledMenuItemLayout>\n      {allowedIcon && <StyledMenuItemIcon>{allowedIcon}</StyledMenuItemIcon>}\n      <Content {...labelProps}>{content}</Content>\n      {shortcut && <Shortcut {...keyboardShortcutProps}>{shortcut}</Shortcut>}\n    </StyledMenuItemLayout>\n  );\n};\n","import React, { HTMLProps } from \"react\";\nimport { MenuTriggerState } from \"@react-stately/menu\";\nimport { FocusScope } from \"@intellij-platform/core/utils/FocusScope\";\nimport { MenuOverlayContext } from \"@intellij-platform/core/Menu/Menu\";\nimport { Overlay } from \"@intellij-platform/core/Overlay\";\n\n/**\n * Overlay container for menu. Extracted into a separate component, to be used by components like MenuTrigger or\n * ContextMenuContainer, that need to render a menu as an overlay.\n * @private\n */\nexport function MenuOverlay({\n  children,\n  restoreFocus,\n  overlayProps,\n  overlayRef,\n  state,\n}: {\n  children: React.ReactNode;\n  restoreFocus?: boolean;\n  overlayProps: HTMLProps<HTMLDivElement>;\n  overlayRef: React.Ref<HTMLDivElement>;\n  state: MenuTriggerState;\n}) {\n  if (!state.isOpen) {\n    return null;\n  }\n  return (\n    <Overlay>\n      <FocusScope\n        restoreFocus={restoreFocus}\n        forceRestoreFocus={restoreFocus}\n        autoFocus\n      >\n        <MenuOverlayContext.Provider value={state}>\n          <div {...overlayProps} ref={overlayRef}>\n            {children}\n          </div>\n        </MenuOverlayContext.Provider>\n      </FocusScope>\n    </Overlay>\n  );\n}\n","import { css } from \"styled-components\";\n\nimport { WINDOW_SHADOW } from \"../style-constants\";\nimport { styled } from \"../styled\";\nimport { StyledVerticalSeparator } from \"../StyledSeparator\";\nimport { UnknownThemeProp } from \"../Theme/Theme\";\n\nimport { StyledMenuItem, StyledMenuItemIcon } from \"./StyledMenuItem\";\n\nexport const MENU_VERTICAL_PADDING = 5;\nexport const MENU_BORDER_WIDTH = 1;\n\n// noinspection CssInvalidPropertyValue\nexport const StyledMenu = styled.ul<{ fillAvailableSpace?: boolean }>`\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  font-size: 0.8rem;\n  margin: 0;\n  padding: ${MENU_VERTICAL_PADDING}px 0;\n  outline: none;\n  list-style: none;\n  width: fit-content;\n  min-width: 120px;\n  overflow: auto;\n  // Border doesn't seem to be painted in the original impl. IdeaPopupMenuUI.isUnderPopup(c) seemed to return false\n  // in all cases. More info: https://github.com/JetBrains/intellij-community/blob/c5ece483811a3ab546fc3880225efb02cc8b94dd/platform/platform-impl/src/com/intellij/ide/ui/laf/darcula/ui/DarculaPopupMenuBorder.java#L24\n  /*  border: ${MENU_BORDER_WIDTH}px solid\n    ${({ theme }) =>\n    theme.color(\"Menu.borderColor\", !theme.dark ? \"#CDCDCD\" : \"#515151\")};*/\n  ${WINDOW_SHADOW};\n  background: ${({ theme }) =>\n    theme.color(\n      \"PopupMenu.background\" as UnknownThemeProp<\"PopupMenu.background\">\n    )};\n  color: ${({ theme }) =>\n    theme.color(\n      \"PopupMenu.foreground\" as UnknownThemeProp<\"PopupMenu.foreground\">\n    )};\n\n  ${StyledVerticalSeparator}:first-child,\n  ${StyledVerticalSeparator}:last-child, \n  ${StyledVerticalSeparator} + ${StyledVerticalSeparator} {\n    display: none;\n  }\n  ${StyledVerticalSeparator} {\n    background-color: ${({ theme }) => theme.color(\"Menu.separatorColor\")};\n    height: ${({ theme }) =>\n      `${theme.value(\"PopupMenuSeparator.height\") ?? 3}px`};\n    padding: ${({ theme }) =>\n      `${theme.value(\"PopupMenuSeparator.stripeIndent\") ?? 1}px 0`};\n    margin: ${({ theme }) =>\n      `0 ${theme.value(\"PopupMenuSeparator.withToEdge\") ?? 1}px`};\n  }\n  ${({ fillAvailableSpace }) =>\n    fillAvailableSpace &&\n    css`\n      flex: 1;\n      width: fill-available; // will be converted to --webkit-fill-available and --moz-available, but doesn't work in FF\n      height: fill-available;\n    `}\n\n  --jui-menu-item-padding: 1rem;\n  --jui-menu-item-icon-width: 1rem;\n  --jui-menu-item-icon-spacing: 0.3125rem;\n\n  ${StyledMenuItem} {\n    // NOTE: The left margin seems not to be consistent in all menus.\n    padding-left: var(--jui-menu-item-padding);\n  }\n  &:has(${StyledMenuItemIcon}) {\n    // Adjusting item padding for menus with icon to be slightly smaller. Based on observations on the reference impl.\n    // Could be handled by a negative margin on icons as well.\n    --jui-menu-item-padding: 0.75rem;\n\n    // CSS-only solution to conditionally add left margin to menu items without icon, if there is at least one menu item\n    // with icon, in the current menu. To have text in all menu items aligned. The extra margin is avoided if there is no\n    // menu item with icon. It relies on :has() css pseudo-class which is not supported in FF at the moment.\n    ${StyledMenuItem}:not(:has(${StyledMenuItemIcon})) {\n      padding-left: calc(\n        var(--jui-menu-item-padding) + var(--jui-menu-item-icon-width) +\n          var(--jui-menu-item-icon-spacing)\n      );\n    }\n  }\n  ${StyledMenuItemIcon} {\n    width: var(--jui-menu-item-icon-width);\n    margin-right: var(--jui-menu-item-icon-spacing);\n  }\n`;\n","import { css, styled } from \"@intellij-platform/core/styled\";\n\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nexport const StyledMenuItemIcon = styled.span`\n  display: inline-flex; // prevents unwanted increased height\n`;\n\nexport const StyledNestedArrow = styled.span`\n  display: inline-flex; // to make it not take more height than the icon\n  margin-right: -0.75rem;\n  margin-left: 0.75rem;\n`;\n\nconst highlightedStyle = css`\n  color: ${({ theme }) =>\n    theme.asCurrentForeground(\n      theme.color(\n        \"MenuItem.selectionForeground\" as UnknownThemeProp<\"MenuItem.selectionForeground\">\n      )\n    )};\n  background: ${({ theme }) =>\n    theme.color(\n      \"MenuItem.selectionBackground\" as UnknownThemeProp<\"MenuItem.selectionBackground\">\n    )};\n`;\nconst defaultStyle = css`\n  color: ${({ theme }) =>\n    theme.color(\n      \"MenuItem.foreground\" as UnknownThemeProp<\"MenuItem.foreground\">\n    )};\n  background: unset;\n`;\nconst disabledStyle = css`\n  color: ${({ theme }) =>\n    theme.color(\"MenuItem.disabledForeground\") + \"!important\"};\n  background: unset !important;\n`;\nexport const StyledMenuItem = styled.li<{\n  isDisabled: boolean;\n  isActive: boolean;\n}>`\n  position: relative; // for being able to position arrow icon absolutely\n  outline: none;\n  cursor: default;\n  white-space: nowrap;\n\n  // bg/fg style for different states. Order is based on how they should override each other\n  ${defaultStyle};\n  ${({ isActive }) => isActive && highlightedStyle};\n  ${({ isDisabled }) => isDisabled && disabledStyle};\n\n  padding-right: 1.25rem;\n  line-height: 1.5; // to make the item have the right height\n  display: flex;\n  align-items: center;\n`;\n","import React, { useContext, useEffect, useRef } from \"react\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { AriaMenuOptions, useMenu } from \"@react-aria/menu\";\nimport { mergeProps } from \"@react-aria/utils\";\n\nimport {\n  MenuKeyboardDelegate,\n  useSubmenu as useSubmenuAria,\n} from \"./_useSubmenu\";\nimport { useSubmenuState } from \"./_useSubmenuState\";\nimport { MenuContext } from \"./Menu\";\nimport { StyledMenu } from \"./StyledMenu\";\nimport { renderMenuNodes } from \"./renderMenuNodes\";\n\nexport function useSubmenu<T>(\n  {\n    rootKey,\n    parentState,\n    keyboardDelegate,\n  }: { rootKey: React.Key; parentState: TreeState<T> } & Pick<\n    AriaMenuOptions<T>,\n    \"keyboardDelegate\"\n  >,\n  state: TreeState<T>,\n  ref: React.RefObject<HTMLElement>\n) {\n  const rootItem = state.collection.getItem(rootKey);\n  const {\n    submenuBehavior,\n    autoFocus = true,\n    onClose,\n    onAction,\n  } = useContext(MenuContext);\n  let { menuProps } = useMenu(\n    {\n      \"aria-label\": rootItem?.[\"aria-label\"] || rootItem?.textValue,\n      onAction,\n      onClose,\n      selectedKeys: state.selectionManager.selectedKeys,\n      keyboardDelegate:\n        keyboardDelegate ||\n        new MenuKeyboardDelegate(\n          rootKey,\n          state.collection,\n          state.disabledKeys,\n          ref\n        ),\n      autoFocus,\n    },\n    state,\n    ref\n  );\n  const { submenuProps } = useSubmenuAria({ rootKey }, parentState, ref);\n\n  const submenuBehaviorProps = {\n    onKeyDown: (e: React.KeyboardEvent) => {\n      if (e.key === \"Escape\") {\n        // Close the menu and submenu root node.\n        state.toggleKey(rootKey);\n        state.selectionManager.setFocusedKey(rootKey);\n        parentState.selectionManager.setFocused(true);\n        if (submenuBehavior !== \"default\") {\n          e.stopPropagation();\n        }\n        return;\n      }\n    },\n  };\n\n  useEffect(() => {\n    setTimeout(() => {\n      // we need this hack until the nested menu is properly supported. That's because when the element is hovered\n      // it sets the focus key, which will move focus to that item.\n      // noinspection PointlessBooleanExpressionJS seems to be false positive. autoFocus can be \"first\" or \"last\"\n      if (autoFocus === true) {\n        ref.current?.focus();\n      }\n    });\n  }, []);\n\n  return {\n    submenuProps: mergeProps(menuProps, submenuProps, submenuBehaviorProps),\n  };\n}\n\nexport interface SubmenuProps<T> {\n  parentState: TreeState<T>;\n  rootKey: React.Key;\n}\n\nexport function Submenu<T>({ parentState, rootKey }: SubmenuProps<T>) {\n  const ref = useRef<HTMLUListElement>(null);\n  const state = useSubmenuState(parentState);\n  const rootItem = state.collection.getItem(rootKey);\n\n  const { submenuProps } = useSubmenu({ rootKey, parentState }, state, ref);\n\n  return (\n    <StyledMenu {...submenuProps} ref={ref}>\n      {renderMenuNodes(state, [...(rootItem?.childNodes || [])])}\n    </StyledMenu>\n  );\n}\n","import { Collection, Node } from \"@react-types/shared\";\nimport { TreeState } from \"@react-stately/tree\";\nimport React, { Key, RefObject } from \"react\";\nimport { useKeyboard } from \"@react-aria/interactions\";\nimport { ListKeyboardDelegate } from \"@react-aria/selection\";\n\nexport class MenuKeyboardDelegate<T> extends ListKeyboardDelegate<T> {\n  private keys: React.Key[];\n  constructor(\n    rootKey: Key | null,\n    private collection: Collection<Node<T>>,\n    disabledKeys: Set<React.Key>,\n    ref: React.RefObject<HTMLElement>,\n    collator?: Intl.Collator\n  ) {\n    super(collection, disabledKeys, ref, collator);\n    this.keys = [...collection.getKeys()]\n      .map((key) => collection.getItem(key))\n      .flatMap((item) => {\n        if (item.parentKey == rootKey) {\n          if (item.type === \"item\") {\n            return [item.key];\n          } else if (item.type === \"section\") {\n            return [...item.childNodes].map(({ key }) => key);\n          }\n        }\n        return [];\n      });\n  }\n\n  getFirstKey(): React.Key {\n    return this.keys[0];\n  }\n  getLastKey(): React.Key {\n    return this.keys.slice(-1)[0];\n  }\n\n  getKeyBelow(key: React.Key): React.Key {\n    const keyBelow = super.getKeyBelow(key);\n    // @ts-expect-error: getKeyBelow should be allowed to return null, but typing is currently inaccurate in react-aria\n    return this.keys.includes(keyBelow) ? keyBelow : null;\n  }\n  getKeyAbove(key: React.Key): React.Key {\n    const keyAbove = super.getKeyAbove(key);\n    // @ts-expect-error: getKeyBelow should be allowed to return null, but typing is currently inaccurate in react-aria\n    return this.keys.includes(keyAbove) ? keyAbove : null;\n  }\n}\n\n/**\n * Behavior accessibility of submenus:\n * - Closing submenu on ArrowLeft key press.\n *   Note that it can't be implemented in useMenuItem, because the focus might be on no the submenu itself and not any\n *   of its items\n * @param rootKey: Key of the root node, the submenu is created from its children\n * @param state\n * @param ref\n */\nexport function useSubmenu<T>(\n  { rootKey }: { rootKey: Key },\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n) {\n  const { keyboardProps: submenuProps } = useKeyboard({\n    onKeyDown: (e) => {\n      // Keyboard events bubble through portals. Don't handle keyboard events\n      // for elements outside the collection (e.g. menus).\n      if (!ref.current?.contains(e.target as Element)) {\n        e.continuePropagation();\n        return;\n      }\n      const root = state.collection.getItem(rootKey);\n      if (e.key === \"ArrowLeft\" && state.expandedKeys.has(root.key)) {\n        state.toggleKey(root.key);\n        state.selectionManager.setFocused(true);\n        return;\n      }\n      e.continuePropagation();\n    },\n  });\n\n  return {\n    submenuProps,\n  };\n}\n","import { TreeState } from \"@react-stately/tree\";\nimport { Key, useRef, useState } from \"react\";\nimport {\n  MultipleSelectionState,\n  SelectionManager,\n} from \"@react-stately/selection\";\n\n/**\n * Creates a TreeState corresponding to the submenu, from the state of a parent (sub)menu.\n * The collection and everything is the same, and the only difference from the parent state is selection manager\n * having a separate focused state to keep the focused state of each menu container separately, as the submenus\n * are usually rendered in separate overlays.\n */\nexport function useSubmenuState<T>(parentState: TreeState<T>) {\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a re-render. So, we have both a ref (sync) and state (async).\n  const [, setFocused] = useState(false);\n  const [, setFocusedKey] = useState<Key | null>(null);\n  const isFocusedRef = useRef(false);\n  const focusedKeyRef = useRef<Key | null>(null);\n\n  const state: MultipleSelectionState = {\n    // @ts-expect-error state is private\n    ...parentState.selectionManager.state,\n    setFocused: (isFocused: boolean) => {\n      isFocusedRef.current = isFocused;\n      setFocused(isFocused);\n    },\n    setFocusedKey(key: Key) {\n      focusedKeyRef.current = key;\n      setFocusedKey(key);\n    },\n  };\n  Object.defineProperties(state, {\n    isFocused: {\n      get() {\n        return isFocusedRef.current;\n      },\n    },\n    focusedKey: {\n      get() {\n        return focusedKeyRef.current!;\n      },\n    },\n  });\n\n  return {\n    ...parentState,\n    selectionManager: new SelectionManager(parentState.collection, state),\n  };\n}\n","import React from \"react\";\nimport { useMenuSection } from \"@react-aria/menu\";\nimport { Node } from \"@react-types/shared\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nimport { renderMenuNodes } from \"./renderMenuNodes\";\n\nexport interface MenuSectionProps<T> {\n  item: Node<T>;\n  state: TreeState<T>;\n  filter?: (node: Node<T>) => boolean;\n}\n\nconst StyledMenuHeading = styled.div`\n  cursor: default;\n  padding: 2px 0 2px 12px;\n  font-weight: bold;\n  font-size: 0.8125rem;\n  color: ${({ theme }) =>\n    theme.color(\n      \"MenuItem.disabledForeground\"\n    )}; // TODO: make sure about it. It's probably not correct color\n`;\n\nconst StyledMenuSectionItemsContainer = styled.ul`\n  padding: 0;\n  margin: 0;\n`;\n\nexport const MenuSection = <T extends unknown>({\n  item,\n  state,\n  filter = () => true,\n}: MenuSectionProps<T>): React.ReactElement => {\n  let { itemProps, headingProps, groupProps } = useMenuSection({\n    heading: item.rendered,\n    \"aria-label\": item[\"aria-label\"],\n  });\n\n  const nodes = [...item.childNodes].filter(filter);\n  if (nodes.filter(({ type }) => type === \"item\").length === 0) {\n    return <></>;\n  }\n  return (\n    <>\n      <li {...itemProps}>\n        {item.rendered && (\n          <StyledMenuHeading {...headingProps}>\n            {item.rendered}\n          </StyledMenuHeading>\n        )}\n        <StyledMenuSectionItemsContainer {...groupProps}>\n          {renderMenuNodes(state, nodes)}\n        </StyledMenuSectionItemsContainer>\n      </li>\n    </>\n  );\n};\n","import React from \"react\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { Node } from \"@react-types/shared\";\nimport { ListDivider } from \"@intellij-platform/core/List/ListDivider\"; // private import\n\nimport { MenuItem } from \"./MenuItem\";\nimport { MenuSection } from \"./MenuSection\";\n\nexport function renderMenuNodes<T>(\n  state: TreeState<T>,\n  nodes: Node<T>[],\n  filter: (node: Node<T>) => boolean = () => true\n) {\n  return nodes.filter(filter).map((node) => {\n    switch (node.type) {\n      case \"item\":\n        return <MenuItem key={node.key} item={node} state={state} />;\n      case \"section\":\n        return (\n          <>\n            {node.props.hasDivider && (\n              <ListDivider key={node.key + \"-divider\"} />\n            )}\n            <MenuSection\n              key={node.key}\n              item={node}\n              state={state}\n              filter={filter}\n            />\n          </>\n        );\n      case \"divider\":\n        return <ListDivider key={node.key} />;\n    }\n  });\n}\n","import React, { useContext, useRef } from \"react\";\nimport { Overlay as AriaOverlay, OverlayProps } from \"@react-aria/overlays\";\n\nconst ParentOverlayContext = React.createContext<HTMLElement | null>(null);\n\n/**\n * A (drop-in replacement) wrapper around Overlay, which makes sure overlays created in nested\n * react components will be ported to the same top level container. This is especially useful to detect\n * \"outside clicks\" when overlays are nested. The most common example would be nested menu in popup.\n *\n */\nexport function Overlay({\n  children,\n  OverlayComponent = AriaOverlay,\n}: {\n  children: React.ReactNode;\n  OverlayComponent?: React.ComponentType<OverlayProps>;\n}) {\n  const root = useContext(ParentOverlayContext);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  if (root) {\n    return (\n      <OverlayComponent portalContainer={root}>{children}</OverlayComponent>\n    );\n  }\n  return (\n    <ParentOverlayContext.Provider value={containerRef.current}>\n      <OverlayComponent>\n        <div ref={containerRef} data-overlay-root=\"\">\n          {children}\n        </div>\n      </OverlayComponent>\n    </ParentOverlayContext.Provider>\n  );\n}\n\n/**\n * Returns true, if element1 and element2 are in nested overlays. \"Nested\" being in terms of React component tree.\n * Useful for detecting \"outside click\" when overlay components are nested in each other.\n */\nexport function areInNestedOverlays(\n  element1: Element | null,\n  element2: Element | null\n) {\n  const overlayRoot1 = element1?.closest(\"[data-overlay-root]\");\n  const overlayRoot2 = element2?.closest(\"[data-overlay-root]\");\n  return Boolean(overlayRoot1) && overlayRoot1 === overlayRoot2;\n}\n","import { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport React from \"react\";\nimport { styled } from \"../styled\";\n\nexport interface SpeedSearchPopupProps {\n  children: string | undefined;\n  match?: boolean;\n  active: boolean | undefined;\n}\n\nconst StyledSearchIcon = styled(PlatformIcon)`\n  margin-right: 10px;\n  vertical-align: middle;\n`;\n\n/**\n * The little popup view shown in the top left corner of list, tree, etc., which shows the search\n * query.\n * @see SpeedSearchInput\n */\nexport const SpeedSearchPopup = React.forwardRef<\n  HTMLElement,\n  SpeedSearchPopupProps\n>(({ active, match, children }, ref) =>\n  active ? (\n    <StyledSpeedSearchPopup ref={ref} noMatch={!match}>\n      <StyledSearchIcon icon={\"actions/search\"} />\n      {(children || \"\").replace(/ /g, \"\\u00A0\")}\n    </StyledSpeedSearchPopup>\n  ) : null\n);\n\nconst StyledSpeedSearchPopup = styled.span<{ noMatch?: boolean }>`\n  // ref: https://github.com/JetBrains/intellij-community/blob/e3c7d96daba1d5d84d5650bde6c220aed225bfda/platform/platform-impl/src/com/intellij/ui/SpeedSearchBase.java#L53-L53\n  box-sizing: border-box;\n  position: absolute;\n  background: ${({ theme }) =>\n    theme.color(\n      \"SpeedSearch.background\",\n      theme.dark ? \"rgb(111,111,111)\" : \"#fff\"\n    )};\n  border: 1px solid\n    ${({ theme }) =>\n      theme.color(\n        \"SpeedSearch.borderColor\",\n        theme.dark ? \"rgb(64, 64, 64)\" : \"rgb(192, 192, 192)\"\n      )};\n  color: ${({ noMatch, theme }) =>\n    noMatch\n      ? theme.color(\"SpeedSearch.errorForeground\", theme.commonColors.red)\n      : theme.color(\n          \"SpeedSearch.foreground\",\n          theme.commonColors.tooltipForeground\n        )};\n  z-index: 1;\n  padding: 3px 7px;\n  height: 25px;\n  line-height: 1.2;\n  transform: translateY(-100%);\n`;\n","import React, { useRef } from \"react\";\n\nfunction isTypeableElement(elem: HTMLElement): boolean {\n  const nonTypeableInputTypes: Array<HTMLInputElement[\"type\"]> = [\n    \"checkbox\",\n    \"radio\",\n    \"button\",\n  ];\n  return (\n    elem.isContentEditable ||\n    (elem instanceof HTMLInputElement &&\n      !nonTypeableInputTypes.includes(elem.type)) ||\n    elem instanceof HTMLTextAreaElement\n  );\n}\n\n/**\n * Main use case is for a list of item, which can have keyboard focus, be filterable and capture\n * typing if the corresponding keyboard events are not happening on an inner element (like an input)\n * that already handles typing.\n * @param value\n * @param onChange\n * TODO: add support for removing word by word by alt+backspace like native text fields.\n * TODO: add support for removing the whole content by command/ctrl+backspace.\n */\nexport function useGhostInput({\n  value,\n  onChange,\n}: {\n  value: string;\n  onChange: (value: string) => void;\n}) {\n  const valueRef = useRef(value);\n  valueRef.current = value;\n  const onKeyDown = (event: React.KeyboardEvent | KeyboardEvent) => {\n    if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      (!(event.target instanceof HTMLElement) ||\n        !isTypeableElement(event.target))\n    ) {\n      if (event.key.length === 1) {\n        // Seems reasonable to prevent default here generally, but the specific case this is added for is the space key,\n        // scrolling the page.\n        event.preventDefault();\n        return onChange(`${valueRef.current}${event.key}`);\n      }\n      if (event.key === \"Backspace\") {\n        const sliceEnd = event.metaKey ? 0 : -1;\n        onChange(valueRef.current.slice(0, sliceEnd));\n      }\n    }\n  };\n  return { onKeyDown } as const;\n}\n","import { useGhostInput } from \"./useGhostInput\";\nimport { useFocusWithin, useKeyboard } from \"@react-aria/interactions\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport { ControlledStateProps } from \"../type-utils\";\nimport { RefObject } from \"react\";\n\nexport interface SpeedSearchState {\n  /**\n   * Whether speed search is active. Speed search becomes active when the user starts to type and becomes inactive\n   * when Escape is pressed, or when the speed search container is blurred and `stickySearch` is false.\n   * Whenever speed search becomes inactive, search text is also cleared.\n   * Note that speed search can be active while search term is empty.\n   */\n  active: boolean;\n  setActive: (value: boolean) => void;\n  searchTerm: string;\n  setSearchTerm: (value: string) => void;\n  /**\n   * clears search term and sets active to false\n   */\n  clear: () => void;\n}\n\nexport interface SpeedSearchStateProps\n  extends ControlledStateProps<{\n    searchTerm: string;\n    active: boolean;\n  }> {}\n\nexport function useSpeedSearchState(\n  props: SpeedSearchStateProps\n): SpeedSearchState {\n  const [active, setActive] = useControlledState(\n    props.active!,\n    props.active || false,\n    props.onActiveChange!\n  );\n  const [searchTerm, setSearchTerm] = useControlledState(\n    props.searchTerm!,\n    props.defaultSearchTerm || \"\",\n    props.onSearchTermChange!\n  );\n\n  return {\n    active,\n    searchTerm,\n    setActive,\n    setSearchTerm,\n    clear: () => {\n      setSearchTerm(\"\");\n      setActive(false);\n    },\n  };\n}\n\nexport interface SpeedSearchProps {\n  stickySearch?: boolean;\n}\n\n/**\n * TODO: description\n * IMPORTANT: making the container element focusable is not a part of this hook. But it's a prerequisite for it to work.\n * Previously, a tabIndex:-1 was passed as a container prop, but it turns out it's not that simple. For collections for\n * example we usually want tab index to be 0 once it's not focused and then when an item is focused, we want it to be\n * -1, and such kind of logics are handled in their respective hooks. So, making the container focusable and how to do\n * it is NOT this hook's responsibility anymore.\n */\nexport function useSpeedSearch(\n  { stickySearch }: SpeedSearchProps,\n  { searchTerm, active, setActive, setSearchTerm }: SpeedSearchState,\n  ref: RefObject<HTMLElement>\n) {\n  const { onKeyDown: ghostInputKeydown } = useGhostInput({\n    value: searchTerm,\n    onChange: (value) => {\n      const trimmedValue = value.trimStart();\n      setSearchTerm(trimmedValue);\n      if (!active && trimmedValue !== \"\") {\n        setActive(true);\n      }\n    },\n  });\n  const clear = () => {\n    setSearchTerm(\"\");\n    setActive(false);\n  };\n\n  const {\n    keyboardProps: { onKeyDown, onKeyUp },\n  } = useKeyboard({\n    onKeyDown: (e) => {\n      if (!ref.current?.contains(e.target as HTMLElement)) {\n        // In case events are propagated through portals\n        return;\n      }\n      if ((e.key === \"a\" && e.metaKey) || e.ctrlKey) {\n        e.preventDefault();\n      }\n      if (e.key === \"Escape\") {\n        if (searchTerm) {\n          clear();\n          return;\n        }\n      } else {\n        ghostInputKeydown(e);\n      }\n      e.continuePropagation();\n    },\n  });\n\n  const {\n    focusWithinProps: { onFocus, onBlur },\n  } = useFocusWithin({\n    onFocusWithinChange: (focused) => {\n      if (!focused && !stickySearch) {\n        clear();\n      }\n    },\n  });\n\n  return {\n    containerProps: {\n      onFocus,\n      onBlur,\n      onKeyDown,\n      onKeyUp,\n    },\n  };\n}\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nexport const StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","export type TextRange = { from: number; to: number };\n\nexport function isEmptyRange(range: TextRange) {\n  return range.from > range.to;\n}\n\nexport function getAllRanges(\n  ranges: TextRange[],\n  length: number\n): Array<[TextRange, boolean]> {\n  const result: Array<[TextRange, boolean]> = [];\n  if (!ranges?.length) {\n    return [[{ from: 0, to: length - 1 }, false]];\n  }\n  if (ranges[0].from > 0) {\n    result.push([{ from: 0, to: ranges[0].from - 1 }, false]);\n  }\n  ranges.forEach(({ from, to }, index) => {\n    result.push([{ from, to }, true]);\n    const gapRange: TextRange = ranges[index + 1]\n      ? { from: to + 1, to: ranges[index + 1].from - 1 }\n      : { from: to + 1, to: length - 1 };\n    if (!isEmptyRange(gapRange)) {\n      result.push([gapRange, false]);\n    }\n  });\n  return result;\n}\n\nexport function createRangesFromIndices(indices: number[]): TextRange[] {\n  return indices.reduce((ranges, index) => {\n    const lastRange = ranges.slice(-1)[0];\n    if (lastRange?.to === index - 1) {\n      return [...ranges.slice(0, -1), { from: lastRange.from, to: index }];\n    }\n    return [...ranges, { from: index, to: index }];\n  }, [] as TextRange[]);\n}\n","import React from \"react\";\nimport { getAllRanges, TextRange } from \"../TextRange\";\nimport { styled } from \"../styled\";\n\nconst HighlightedMatch = styled.span`\n  background: ${({ theme }) =>\n    `linear-gradient(${theme.color(\n      \"SearchMatch.startBackground\",\n      \"#ffeaa2b3\"\n    )}, ${theme.color(\"SearchMatch.endBackground\", \"#ffd042b3\")})`};\n  color: #000;\n  border-radius: 3px;\n`;\n\n/**\n * Renders the children (which must be a string), with highlights wrapped in spans with the highlight style.\n * Note: this component doesn't render a container. It just highlights the specified ranges.\n */\nexport function TextWithHighlights({\n  children,\n  highlights,\n}: {\n  children: string;\n  highlights: TextRange[] | null;\n}): React.ReactElement {\n  const parts: Array<[TextRange, boolean]> = highlights\n    ? getAllRanges(highlights, children.length)\n    : [[{ from: 0, to: children.length }, false]];\n  return (\n    <>\n      {parts.map(([{ from, to }, highlighted]) => {\n        const text = children.slice(from, to + 1);\n        return (\n          // TODO: key\n          <React.Fragment key={`${from}_${to}`}>\n            {highlighted ? <HighlightedMatch>{text}</HighlightedMatch> : text}\n          </React.Fragment>\n        );\n      })}\n    </>\n  );\n}\n","import React from \"react\";\nimport { Node } from \"@react-types/shared\";\nimport { TreeNode } from \"../TreeNode\";\nimport { SpeedSearchItemHighlightsProvider } from \"@intellij-platform/core/CollectionSpeedSearch\";\n\nexport const SpeedSearchTreeNode = <T extends object>({\n  item,\n}: {\n  item: Node<T>;\n}) => {\n  return (\n    <SpeedSearchItemHighlightsProvider itemKey={item.key}>\n      <TreeNode key={item.key} item={item} />\n    </SpeedSearchItemHighlightsProvider>\n  );\n};\n","import React, { ForwardedRef } from \"react\";\nimport { Node } from \"@react-types/shared\";\nimport { Virtualizer } from \"@react-aria/virtualizer\";\nimport { CollectionSpeedSearchContext } from \"@intellij-platform/core/CollectionSpeedSearch\";\nimport { SpeedSearchProps } from \"@intellij-platform/core/SpeedSearch\";\nimport { useCollectionRef } from \"@intellij-platform/core/Collections/useCollectionRef\";\nimport useForwardedRef from \"@intellij-platform/core/utils/useForwardedRef\";\nimport { StyledTree } from \"../StyledTree\";\nimport { SpeedSearchPopup } from \"../../SpeedSearch/SpeedSearchPopup\";\nimport { useTreeState } from \"../useTreeState\";\nimport { TreeProps } from \"../Tree\";\nimport { useTreeVirtualizer } from \"../useTreeVirtualizer\";\nimport { TreeContext } from \"../TreeContext\";\nimport { useSpeedSearchTree } from \"./useSpeedSearchTree\";\nimport { SpeedSearchTreeNode } from \"./SpeedSearchTreeNode\";\n\nexport type SpeedSearchTreeProps<T extends object> = TreeProps<T> &\n  SpeedSearchProps;\n\nexport const SpeedSearchTree = React.forwardRef(\n  <T extends object>(\n    { fillAvailableSpace = false, treeRef, ...props }: SpeedSearchTreeProps<T>,\n    forwardedRef: ForwardedRef<HTMLDivElement>\n  ) => {\n    const state = useTreeState(\n      { ...props, disallowEmptySelection: !props.allowEmptySelection },\n      treeRef\n    );\n    useCollectionRef(props, state);\n    const ref = useForwardedRef(forwardedRef);\n    const {\n      treeProps,\n      treeContext,\n      speedSearchContextValue,\n      searchPopupProps,\n    } = useSpeedSearchTree({ ...props, isVirtualized: true }, state, ref);\n\n    const { virtualizerProps } = useTreeVirtualizer({ state });\n\n    // NOTE: SpeedSearchPopup can be rendered as a portal with proper positioning (useOverlayPosition), if overflow\n    // issues required it.\n    return (\n      <TreeContext.Provider value={treeContext}>\n        <CollectionSpeedSearchContext.Provider value={speedSearchContextValue}>\n          <SpeedSearchPopup {...searchPopupProps} />\n          <StyledTree\n            as={Virtualizer}\n            ref={ref}\n            fillAvailableSpace={fillAvailableSpace}\n            {...virtualizerProps}\n            {...treeProps}\n          >\n            {(type: string, item: unknown) => (\n              <SpeedSearchTreeNode\n                key={(item as Node<T>).key}\n                item={item as Node<T>}\n              />\n            )}\n          </StyledTree>\n        </CollectionSpeedSearchContext.Provider>\n      </TreeContext.Provider>\n    );\n  }\n);\n","import { RefObject } from \"react\";\nimport { useKeyboard } from \"@react-aria/interactions\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { useCollectionSpeedSearch } from \"../../CollectionSpeedSearch/useCollectionSpeedSearch\";\nimport { SpeedSearchProps } from \"../../SpeedSearch/useSpeedSearch\";\nimport { TreeKeyboardDelegate } from \"../TreeKeyboardDelegate\";\nimport { SelectableTreeProps, useSelectableTree } from \"../useSelectableTree\";\nimport { hasAnyModifier } from \"@intellij-platform/core/utils/keyboard-utils\";\n\ninterface UseSpeedSearchTreeProps<T>\n  extends SpeedSearchProps,\n    SelectableTreeProps<T> {}\n\nexport function useSpeedSearchTree<T>(\n  props: UseSpeedSearchTreeProps<T>,\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n) {\n  const {\n    containerProps,\n    keyboardDelegate,\n    selectionManager,\n    speedSearch,\n    ...collectionSpeedSearch\n  } = useCollectionSpeedSearch({\n    collection: state.collection,\n    selectionManager: state.selectionManager,\n    stickySearch: props.stickySearch,\n    keyboardDelegate: new TreeKeyboardDelegate(\n      state.collection,\n      state.disabledKeys,\n      ref\n    ),\n    ref,\n    // TODO: maybe allow control over speed search via other props\n  });\n\n  // Speed search is cleared on \"Enter\" key. Alternatively we could wrap onAction and onToggle props\n  // but this seemed more reasonable\n  // NOTE: It may make sense for this behaviour to be pulled up to useCollectionSpeedSearch.\n  const { keyboardProps: speedSearchKeyboardProps } = useKeyboard({\n    onKeyDown: (e) => {\n      if (\n        [\"Enter\", \"ArrowLeft\", \"ArrowRight\"].includes(e.key) &&\n        !hasAnyModifier(e)\n      ) {\n        speedSearch.clear();\n      } else {\n        e.continuePropagation();\n      }\n    },\n  });\n\n  const { treeProps, ...selectableTree } = useSelectableTree(\n    { ...props, keyboardDelegate },\n    { ...state, selectionManager },\n    ref\n  );\n\n  return {\n    treeProps: mergeProps(treeProps, containerProps, speedSearchKeyboardProps),\n    ...collectionSpeedSearch,\n    ...selectableTree,\n  };\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport { StyledList } from \"@intellij-platform/core/List/StyledList\";\n\nexport const StyledTree = styled(StyledList)`\n  background: ${({ theme }) => theme.color(\"Tree.background\")};\n`;\n","import React, { Key, MutableRefObject } from \"react\";\nimport { TreeState } from \"@react-stately/tree\";\n\nexport type TreeContextType<T> = {\n  state: TreeState<T>;\n  focused: boolean;\n  onActionRef: MutableRefObject<((key: Key) => void) | undefined>;\n};\n\nexport const TreeContext = React.createContext<TreeContextType<any> | null>(\n  null\n);\n","import { ListKeyboardDelegate } from \"@react-aria/selection\";\nimport { Collection, Node } from \"@react-types/shared\";\nimport React, { Key, RefObject } from \"react\";\n\nexport class TreeKeyboardDelegate<T> extends ListKeyboardDelegate<T> {\n  constructor(\n    private collection: Collection<Node<T>>,\n    private disabledKeys: Set<Key>,\n    ref: RefObject<HTMLElement>,\n    collator?: Intl.Collator\n  ) {\n    super(collection, disabledKeys, ref, collator);\n  }\n\n  getKeyLeftOf(key: React.Key): React.Key {\n    const item = this.collection.getItem(key);\n    return item.parentKey ?? this.getKeyAbove(key);\n  }\n\n  getKeyRightOf(key: React.Key): React.Key {\n    return this.getKeyBelow(key);\n  }\n}\n","import { LafIcon } from \"../Icon\";\nimport React, { ComponentProps, useMemo } from \"react\";\nimport { styled } from \"../styled\";\n\nexport const TREE_ICON_SIZE = 16;\nconst StyledTreeNodeIcon = styled(LafIcon)`\n  margin-left: -20px;\n  margin-right: 4px;\n  margin-top: -1px; // the svg path seems to have uneven vertical padding. This is to compensate for that.\n  flex-shrink: 0;\n  align-self: center;\n`;\n\ntype TreeNodeIconProps = ComponentProps<typeof StyledTreeNodeIcon> & {\n  selected: boolean;\n  expanded: boolean;\n};\nconst getIcon = (selected: boolean, expanded: boolean) => {\n  const modifiers = { Selected: selected };\n  if (expanded) {\n    return {\n      themePath: selected ? \"Tree.expandedSelectedIcon\" : \"Tree.expandedIcon\",\n      iconPath: { name: \"treeExpanded\", modifiers },\n    };\n  }\n  if (!expanded) {\n    return {\n      themePath: selected ? \"Tree.collapsedSelectedIcon\" : \"Tree.collapsedIcon\",\n      iconPath: { name: \"treeCollapsed\", modifiers },\n    };\n  }\n};\n\nexport function TreeNodeIcon({\n  selected,\n  expanded,\n  ...props\n}: TreeNodeIconProps) {\n  const icon = useMemo(() => getIcon(selected, expanded), [selected, expanded]);\n  return (\n    <StyledTreeNodeIcon\n      icon={icon?.iconPath}\n      themePath={icon?.themePath}\n      size={TREE_ICON_SIZE}\n      {...props}\n    />\n  );\n}\n","import { Key } from \"react\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { PressProps } from \"@react-aria/interactions\";\n\nexport function useTreeNodeToggleButton<T>({\n  collection,\n  toggleKey,\n  selectionManager,\n  key,\n}: { key: Key } & Pick<\n  TreeState<T>,\n  \"collection\" | \"toggleKey\" | \"selectionManager\"\n>): { treeNodeToggleButtonProps: PressProps } {\n  return {\n    treeNodeToggleButtonProps: {\n      preventFocusOnPress: true,\n      onPress: () => {\n        toggleKey(key);\n\n        // The rest is for deselecting selected descendants and selecting the toggled node, if there\n        // is at least one of such currently selected descendants. This is the exact behavior\n        // of Tree in Intellij Platform, and hence implemented here.\n        const selectedDescendantKeys = [\n          ...selectionManager.selectedKeys,\n        ].filter((key: Key) => {\n          let parentKey = collection.getItem(key)?.parentKey;\n          while (parentKey) {\n            if (parentKey === key) {\n              return true;\n            }\n            parentKey = collection.getItem(parentKey)?.parentKey;\n          }\n          return false;\n        });\n        selectedDescendantKeys.forEach((key) =>\n          selectionManager.toggleSelection(key)\n        );\n        // if any of the descendants are selected\n        if (\n          !selectionManager.isSelected(key) &&\n          selectedDescendantKeys.length > 0\n        ) {\n          selectionManager.toggleSelection(key);\n        }\n      },\n    },\n  };\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { StyledListItem } from \"@intellij-platform/core/List/StyledListItem\";\nimport { TREE_ICON_SIZE } from \"./TreeNodeIcon\";\n\nexport const StyledTreeNode = styled(StyledListItem).attrs({ as: \"div\" })<{\n  level: number;\n}>`\n  // There are some theme properties for tree node padding (theme.ui.Tree.leftChildIndent and\n  // theme.ui.Tree.leftChildIndent), but they doesn't seem to be applicable.\n  padding-left: ${({ level }) => `${(level + 1) * TREE_ICON_SIZE + 8}px`};\n  padding-right: 0.25rem;\n  ${({ containerFocused, selected, disabled, theme }) => {\n    let backgroundColor;\n    let color = disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\n          \"Tree.foreground\" as UnknownThemeProp<\"Tree.foreground\">,\n          theme.commonColors.labelForeground\n        );\n    if (selected) {\n      if (containerFocused) {\n        color = theme.asCurrentForeground(\n          theme.color(\n            \"Tree.selectionForeground\" as UnknownThemeProp<\"Tree.selectionForeground\">\n          ) || theme.commonColors.labelSelectedForeground\n        ) /* Prioritizing \"*.selectionForeground\" over labelSelectedForeground*/;\n        backgroundColor = theme.color(\n          \"Tree.selectionBackground\" as UnknownThemeProp<\"Tree.selectionBackground\">\n        );\n      } else {\n        color = theme.color(\n          \"Tree.selectionInactiveForeground\" as UnknownThemeProp<\"Tree.selectionInactiveForeground\">,\n          color\n        );\n        backgroundColor = theme.color(\n          \"Tree.selectionBackgroundInactive\" as UnknownThemeProp<\"Tree.selectionBackgroundInactive\">\n        );\n      }\n    }\n    return {\n      backgroundColor,\n      color,\n    };\n  }}\n`;\n","import { usePress } from \"@react-aria/interactions\";\nimport { Node } from \"@react-types/shared\";\nimport React, { useContext, useRef } from \"react\";\nimport { ItemStateContext } from \"../Collections/ItemStateContext\";\nimport { TreeNodeIcon } from \"./TreeNodeIcon\";\nimport { useTreeNode } from \"./useTreeNode\";\nimport { useTreeNodeToggleButton } from \"./useTreeNodeToggleButton\";\nimport { TreeContext } from \"./TreeContext\";\nimport { StyledTreeNode } from \"@intellij-platform/core/Tree/StyledTreeNode\";\n\ntype TreeNodeProps<T> = {\n  item: Node<T>;\n  showAsFocused?: boolean;\n};\n\nexport function TreeNode<T>({ item }: TreeNodeProps<T>) {\n  const ref = useRef(null);\n  const {\n    state: {\n      collection,\n      selectionManager,\n      expandedKeys,\n      disabledKeys,\n      toggleKey,\n    },\n    focused: containerFocused,\n    onActionRef: { current: onAction },\n  } = useContext(TreeContext)!;\n\n  const isSelected = selectionManager.isSelected(item.key);\n  const expanded = expandedKeys.has(item.key);\n  const isDisabled = disabledKeys.has(item.key);\n\n  const { pressProps: togglePressProps } = usePress({\n    ...useTreeNodeToggleButton({\n      key: item.key,\n      collection,\n      selectionManager,\n      toggleKey,\n    }).treeNodeToggleButtonProps,\n    isDisabled,\n  });\n\n  const { treeNodeProps } = useTreeNode({\n    item,\n    ref,\n    toggleKey,\n    onAction,\n    selectionManager,\n    disabled: isDisabled,\n  });\n\n  /**\n   * NOTE: TreeNode intentionally is not designed in a recursive way for two main reasons:\n   * - Performance\n   * - Better support for virtualization\n   * So instead of rendering TreeNode for childNodes, if the node is expanded, we expect parent\n   * to render children. It's not a layout issue since we don't need any nesting in terms of\n   * layout of nested items. In terms of layout, a tree will be rendered similar to a flat list,\n   * but with more indentation for nested nodes.\n   */\n  return (\n    <>\n      <StyledTreeNode\n        ref={ref}\n        {...treeNodeProps}\n        containerFocused={containerFocused}\n        disabled={isDisabled}\n        selected={isSelected}\n        aria-disabled={isDisabled}\n        aria-selected={isSelected}\n        level={item.level}\n      >\n        {[...item.childNodes].length > 0 && (\n          <TreeNodeIcon\n            selected={isSelected}\n            expanded={expanded}\n            {...togglePressProps}\n          />\n        )}\n        <ItemStateContext.Provider\n          value={{\n            isDisabled,\n            isSelected,\n            isContainerFocused: containerFocused,\n            node: item,\n          }}\n        >\n          {item.rendered}\n        </ItemStateContext.Provider>\n      </StyledTreeNode>\n    </>\n  );\n}\n","import { usePress } from \"@react-aria/interactions\";\nimport { useSelectableItem } from \"@intellij-platform/core/selection\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport { Node } from \"@react-types/shared\";\nimport { Key, RefObject } from \"react\";\n\nexport function useTreeNode<T>({\n  item,\n  ref,\n  selectionManager,\n  disabled,\n  toggleKey,\n  onAction,\n}: {\n  item: Node<T>;\n  ref: RefObject<HTMLElement>;\n  disabled: boolean;\n  toggleKey: (key: Key) => void;\n  onAction?: (key: Key) => void;\n  selectionManager: SelectionManager;\n}) {\n  const {\n    pressProps: { onKeyDown, ...pressProps },\n  } = usePress({\n    ...useSelectableItem({\n      key: item.key,\n      ref,\n      selectionManager,\n      isVirtualized: false,\n    }).itemProps,\n    isDisabled: disabled,\n    preventFocusOnPress: false,\n  });\n\n  const onDoubleClick = () => {\n    if ([...item.childNodes].length > 0) {\n      toggleKey(item.key);\n    } else {\n      onAction?.(item.key);\n    }\n  };\n  const ariaProps = {\n    role: \"treeitem\",\n  };\n\n  return {\n    treeNodeProps: mergeProps(pressProps, { onDoubleClick }, ariaProps),\n  };\n}\n","import React, { Key, RefObject, useMemo, useState } from \"react\";\nimport {\n  DOMProps,\n  KeyboardDelegate,\n  KeyboardEvent,\n  Node,\n} from \"@react-types/shared\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { useFocusWithin, useKeyboard } from \"@react-aria/interactions\";\nimport { filterDOMProps, mergeProps } from \"@react-aria/utils\";\nimport { useCollator } from \"@react-aria/i18n\";\nimport { useSelectableCollection } from \"@intellij-platform/core/selection\";\nimport { TreeKeyboardDelegate } from \"./TreeKeyboardDelegate\";\nimport { useCollectionAutoScroll } from \"../Collections/useCollectionAutoScroll\";\nimport { useLatest } from \"@intellij-platform/core/utils/useLatest\";\nimport { TreeContextType } from \"./TreeContext\";\nimport { hasAnyModifier } from \"@intellij-platform/core/utils/keyboard-utils\";\nimport { FocusEvents } from \"@react-types/shared/src/events\";\nimport { FocusStrategy } from \"@react-types/shared/src/selection\";\n\nexport interface SelectableTreeProps<T>\n  extends DOMProps,\n    Omit<FocusEvents, \"onFocusChange\"> {\n  isVirtualized?: boolean;\n  keyboardDelegate?: KeyboardDelegate;\n  /**\n   * Called when the action associated with a leaf tree node should be taken.\n   * The exact UI interaction is abstracted away, but it's either Enter key or double click.\n   */\n  onAction?: (key: Key) => void;\n  onNodeKeyDown?: (event: KeyboardEvent, node: Node<T>) => void;\n\n  allowEmptySelection?: boolean;\n\n  autoFocus?: boolean | FocusStrategy;\n\n  showAsFocused?: boolean;\n}\n\n/**\n * NOTE: at the time of writing this hook, react-aria didn't have support for Tree. When useTree is implemented in\n * react-aria, it makes sense to refactor this and use that. There will still be something on top of it here.\n */\nexport function useSelectableTree<T>(\n  {\n    onAction,\n    onFocus,\n    onBlur,\n    autoFocus,\n    showAsFocused,\n    ...props\n  }: SelectableTreeProps<T>,\n  state: TreeState<T>,\n  ref: RefObject<HTMLElement>\n) {\n  const domProps = filterDOMProps(props);\n  const collator = useCollator({ usage: \"search\", sensitivity: \"base\" });\n\n  const [focused, setFocused] = useState(false);\n  const {\n    collectionProps: {\n      // preventDefault in onMouseDown prevents collection from getting focused.\n      // Maybe it should be removed from useSelectableCollection, now that it lives here\n      onMouseDown,\n      onKeyDown: selectionKeyDown,\n      ...collectionProps\n    },\n  } = useSelectableCollection({\n    ref,\n    selectionManager: state.selectionManager,\n    disallowEmptySelection: !props.allowEmptySelection,\n    selectOnFocus: true,\n    autoFocus,\n    keyboardDelegate: useMemo(\n      () =>\n        props.keyboardDelegate ||\n        new TreeKeyboardDelegate(\n          state.collection,\n          state.disabledKeys,\n          ref,\n          collator\n        ),\n      [state.collection, state.disabledKeys, props.keyboardDelegate]\n    ),\n  });\n  const { focusWithinProps } = useFocusWithin({\n    onFocusWithinChange: setFocused,\n  });\n\n  useCollectionAutoScroll(\n    {\n      isVirtualized: props.isVirtualized,\n      selectionManager: state.selectionManager,\n    },\n    ref\n  );\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    const focusedKey = state.selectionManager.focusedKey;\n    if (focusedKey == null) {\n      event.continuePropagation();\n      return;\n    }\n    const item = state.collection.getItem(focusedKey);\n    const isExpandable = item.hasChildNodes;\n    const expanded = state.expandedKeys.has(focusedKey);\n    const isDisabled = state.disabledKeys.has(focusedKey);\n    if (isDisabled) {\n      event.continuePropagation();\n      return;\n    }\n\n    props?.onNodeKeyDown?.(event, item);\n\n    const shouldToggle =\n      !hasAnyModifier(event) &&\n      (event.key === \"Enter\" ||\n        (event.key === \"ArrowLeft\" && expanded) ||\n        (event.key === \"ArrowRight\" && !expanded));\n\n    if (isExpandable && shouldToggle) {\n      event.preventDefault();\n      state.toggleKey(focusedKey);\n    } else if (event.key === \"Enter\") {\n      onAction?.(focusedKey);\n    } else {\n      // selectionKeyDown currently doesn't report back if it handled the event or not. We could have conditionally\n      // continued propagation if the event was not handled. Then we could change Speed Search impl to only handle\n      // inputs when the propagation is not prevented.\n      // Also, selectionKeyDown is not accurate in handling actions like \"select all\". e.g. it takes 'cmd+shift+a' too,\n      // as select all which can conflict with action system. So we don't call it if there are multiple modifiers.\n      const hasAtMostOneModifier =\n        [event.metaKey, event.ctrlKey, event.shiftKey, event.altKey].filter(\n          (i) => i\n        ).length < 2;\n      if (hasAtMostOneModifier) {\n        selectionKeyDown?.(event);\n      }\n      event.continuePropagation();\n    }\n  };\n  const { keyboardProps } = useKeyboard({\n    onKeyDown,\n  });\n\n  //////////////////////////////// providing context value ////////////////////////////////\n  const onActionRef = useLatest(onAction);\n\n  const {\n    selectionManager,\n    collection,\n    expandedKeys,\n    disabledKeys,\n    toggleKey,\n  } = state;\n  const treeContext = useMemo<TreeContextType<T>>(\n    () => ({\n      state: {\n        collection,\n        selectionManager,\n        expandedKeys,\n        disabledKeys,\n        toggleKey,\n      },\n      focused: Boolean(focused || showAsFocused),\n      onActionRef,\n    }),\n    [\n      selectionManager,\n      collection,\n      expandedKeys,\n      disabledKeys,\n      toggleKey,\n      focused,\n      showAsFocused,\n      onActionRef,\n    ]\n  );\n  ////////////////////////////////////////////////////////////////////////////////////////\n\n  return {\n    // order of merging here is important. navigation handling should precede selection handling\n    treeProps: mergeProps(\n      focusWithinProps,\n      collectionProps,\n      keyboardProps,\n      domProps,\n      { onFocus, onBlur, role: \"tree\" }\n    ),\n    treeContext,\n    focused,\n  };\n}\n","//@ts-nocheck\n/**\n * Not exported from @react-stately/tree, but needed in the custom implementation of useTreeState\n */\n\nimport { Key } from \"react\";\nimport { Collection, Node } from \"@react-types/shared\";\n\nexport class TreeCollection<T> implements Collection<Node<T>> {\n  private keyMap: Map<Key, Node<T>> = new Map();\n  private iterable: Iterable<Node<T>>;\n  private firstKey: Key;\n  private lastKey: Key;\n\n  constructor(\n    nodes: Iterable<Node<T>>,\n    { expandedKeys }: { expandedKeys?: Set<Key> } = {}\n  ) {\n    this.iterable = nodes;\n    expandedKeys = expandedKeys || new Set();\n\n    let visit = (node: Node<T>) => {\n      this.keyMap.set(node.key, node);\n\n      if (\n        node.childNodes &&\n        (node.type === \"section\" || expandedKeys.has(node.key))\n      ) {\n        for (let child of node.childNodes) {\n          visit(child);\n        }\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let last: Node<T>;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n\n      if (node.type === \"item\") {\n        node.index = index++;\n      }\n\n      last = node;\n\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n\n    this.lastKey = last?.key;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    return this.lastKey;\n  }\n\n  getItem(key: Key) {\n    return this.keyMap.get(key);\n  }\n\n  at(idx: number) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n}\n","import { Node } from \"@react-types/shared\";\nimport { Key } from \"react\";\n\n/**\n * given a node, returns keys of all consecutive single children\n */\nexport function getSingleChildrenKeys<T>(\n  node: Node<T> | null | undefined\n): Key[] {\n  return getSingleChildrenKeysRecursive(node, []);\n}\n\nfunction getSingleChildrenKeysRecursive<T>(\n  node: Node<T> | null | undefined,\n  previousKeys: Key[]\n): Key[] {\n  if (!node) {\n    return [];\n  }\n  const childNodesIterator: Iterator<\n    Node<T>,\n    Node<T> | undefined\n  > = node.childNodes[Symbol.iterator]();\n  const { value: firstChild, done } = childNodesIterator.next();\n  const noMoreChildren = done || childNodesIterator.next().value == null;\n  if (firstChild != null && noMoreChildren && isExpandable(firstChild)) {\n    return getSingleChildrenKeysRecursive(\n      firstChild,\n      previousKeys.concat((firstChild as Node<T>).key)\n    );\n  }\n  return previousKeys;\n}\n\nconst isExpandable = <T>(node: Node<T>) =>\n  node.hasChildNodes || !isEmptyIterable(node.childNodes);\n\nfunction isEmptyIterable(iterable: Iterable<unknown> | undefined | null) {\n  for (const _ of iterable || []) {\n    // eslint-disable-line no-unused-vars, no-unreachable-loop\n    return false;\n  }\n  return true;\n}\n","import {\n  MultipleSelectionState,\n  SelectionManager,\n  SelectionManagerOptions,\n} from \"@react-stately/selection\";\nimport { Collection, Node } from \"@react-types/shared\";\nimport React, { Key } from \"react\";\n\nexport class TreeSelectionManager extends SelectionManager {\n  private readonly collection: Collection<Node<unknown>>;\n\n  constructor(\n    collection: Collection<Node<unknown>>,\n    state: MultipleSelectionState,\n    options?: SelectionManagerOptions\n  ) {\n    super(collection, state, options);\n    this.collection = collection;\n  }\n\n  expandSelection() {\n    if (this.focusedKey) {\n      const node = this.collection.getItem(this.focusedKey);\n      const { expandKeys } = this.getExpandAndShrinkKeys(node);\n      if (expandKeys.length > 0) {\n        this.setSelectedKeys([...this.selectedKeys, ...expandKeys]);\n      }\n    }\n  }\n  shrinkSelection() {\n    if (this.focusedKey) {\n      const node = this.collection.getItem(this.focusedKey);\n      const { shrinkKeys } = this.getExpandAndShrinkKeys(node);\n      if (shrinkKeys.length > 0) {\n        this.setSelectedKeys(\n          [...this.selectedKeys].filter((key) => !shrinkKeys.includes(key))\n        );\n      }\n    }\n  }\n\n  private getExpandAndShrinkKeys(node: Node<unknown>) {\n    return this.recursivelyGetExpandAndShrinkKeys(\n      node,\n      [...this.collection.getKeys()],\n      null\n    );\n  }\n  /**\n   * Starting from a node, traverses the tree up, until it reaches the root of the fully selected subtree that includes\n   * the starting node. The root itself may or may not be selected. Returns:\n   * - keys to be added to selection, when expanding selection\n   * - keys to be removed from selection, when shrinking selection\n   */\n  private recursivelyGetExpandAndShrinkKeys(\n    node: Node<unknown>,\n    keys: Array<Key>,\n    previousChild: Key | null\n  ): { expandKeys: Key[]; shrinkKeys: Key[] } {\n    const parent =\n      node && node.parentKey ? this.collection.getItem(node.parentKey) : null;\n    const newKeys = keys.filter((key) => key !== previousChild);\n    const parentDescendants = parent\n      ? getAllDescendants(parent, newKeys).map(({ key }) => key)\n      : this.getAllRoots().flatMap((key) =>\n          key !== node.key\n            ? getAllDescendants(this.collection.getItem(key), newKeys)\n                .map(({ key }) => key)\n                .concat(key)\n            : []\n        );\n    if (parent && parentDescendants.every((key) => this.isSelected(key))) {\n      return this.recursivelyGetExpandAndShrinkKeys(parent, keys, node.key);\n    }\n    const descendants = getAllDescendants(\n      node,\n      keys.filter((key) => key !== previousChild)\n    ).map(({ key }) => key);\n\n    return {\n      expandKeys: descendants.some((key) => !this.isSelected(key))\n        ? descendants\n        : !this.isSelected(node.key)\n        ? [node.key]\n        : parentDescendants,\n      shrinkKeys:\n        parentDescendants.length > 0 &&\n        parentDescendants.every((key) => this.isSelected(key))\n          ? parentDescendants\n          : this.isSelected(node.key) && previousChild\n          ? [node.key]\n          : descendants.filter((key) => this.isSelected(key)),\n    };\n  }\n\n  private getAllRoots() {\n    return [...this.collection.getKeys()].filter(\n      (key) => this.collection.getItem(key).parentKey == null\n    );\n  }\n}\n\nfunction getAllDescendants<T>(\n  node: Node<T>,\n  stopKeys: Array<React.Key>\n): Node<T>[] {\n  const childNodes = (node.hasChildNodes ? [...node.childNodes] : []).filter(\n    (node) => stopKeys.includes(node.key)\n  );\n  return node.hasChildNodes\n    ? childNodes.concat(\n        childNodes.map((node) => getAllDescendants(node, stopKeys)).flat()\n      )\n    : [];\n}\n","import { Collection, Node } from \"@react-types/shared\";\nimport { TreeProps as _TreeProps, TreeState } from \"@react-stately/tree\";\nimport {\n  TreeRefValue,\n  useTreeRef,\n} from \"@intellij-platform/core/Tree/useTreeRef\";\nimport { ForwardedRef, Key, useEffect, useMemo } from \"react\";\nimport { useMultipleSelectionState } from \"@react-stately/selection\";\nimport { useCollection } from \"@react-stately/collections\";\nimport { useControlledState } from \"@react-stately/utils\";\nimport {\n  CollectionCacheInvalidationProps,\n  useCollectionCacheInvalidation,\n} from \"@intellij-platform/core/Collections/useCollectionCacheInvalidation\";\nimport { TreeCollection as _TreeCollection } from \"./__copied__TreeCollection\";\nimport { getSingleChildrenKeys } from \"./getSingleChildrenKeys\";\nimport { TreeSelectionManager } from \"@intellij-platform/core/Tree/TreeSelectionManager\";\nimport { notNull } from \"@intellij-platform/core/utils/array-utils\";\n\nexport class TreeCollection<T> extends _TreeCollection<T> {\n  public readonly rootKeys: Key[];\n  constructor(\n    nodes: Iterable<Node<T>>,\n    { expandedKeys }: { expandedKeys: Set<Key> }\n  ) {\n    super(nodes, { expandedKeys });\n    this.rootKeys = Array.from(nodes).map(({ key }) => key);\n  }\n\n  getAllExpandableKeys(): Set<Key> {\n    const rootNodes = this.rootKeys\n      .map((key) => this.getItem(key))\n      .filter(notNull);\n    return this.recursivelyAddExpandableKeys(rootNodes, new Set<Key>());\n  }\n\n  private recursivelyAddExpandableKeys(\n    nodes: Iterable<Node<T>>,\n    result: Set<Key>\n  ) {\n    for (const node of nodes) {\n      if (node?.hasChildNodes) {\n        result.add(node.key);\n        this.recursivelyAddExpandableKeys(node.childNodes, result);\n      }\n    }\n    return result;\n  }\n}\nexport interface TreeProps<T>\n  extends _TreeProps<T>,\n    CollectionCacheInvalidationProps {\n  childExpansionBehaviour?: \"multi\" | \"single\";\n}\n/**\n * Provides state management for tree-like components. Handles building a collection\n * of items from props, item expanded state, and manages multiple selection state.\n *\n * Similar to (and initially copied from) useTreeState from @react-stately/tree, but with the following changes:\n * - Supports exposing some imperative API via ref.\n *   Could be done via a wrapper too.\n * - Different onToggle implementation with two adjustments to match Intellij Platform:\n *   - Collapsing a key collapses all descendants as well.\n *   - Expanding a single-child node will recursively expand all single-child descendants.\n *   Couldn't be done with a wrapper in a clean and optimal way. Access to setExpandedKey is not provided. We would need\n *   to either maintain a new state for expanded keys and ignore the one returned from the wrapped hook, or\n *   inefficiently call the returned `toggleKey` function many times.\n * - Supports collection invalidation via CollectionCacheInvalidationProps\n *   Perhaps not the most important addition, but not possible to be done via a wrapper.\n * - Uses TreeSelectionManager instead of the default SelectionManager, which implements expand/shrink selection.\n *   Could be done in a wrapper, with a little hack. Would need to replace selection manager.\n * - returned `collection` is of type `TreeCollection` (which is an improved version of react-stately `TreeCollection`),\n *   instead of the more generic `Collection`.\n */\nexport function useTreeState<T extends object>(\n  { childExpansionBehaviour = \"multi\", ...props }: TreeProps<T>,\n  treeRef?: ForwardedRef<TreeRefValue>\n): TreeState<T> {\n  let [expandedKeys, setExpandedKeys] = useControlledState(\n    props.expandedKeys ? new Set(props.expandedKeys) : undefined!,\n    props.defaultExpandedKeys ? new Set(props.defaultExpandedKeys) : new Set(),\n    props.onExpandedChange!\n  );\n\n  let selectionState = useMultipleSelectionState({\n    ...props,\n    selectionBehavior: \"replace\",\n  });\n  let disabledKeys = useMemo(\n    () => (props.disabledKeys ? new Set(props.disabledKeys) : new Set<Key>()),\n    [props.disabledKeys]\n  );\n\n  const context = useCollectionCacheInvalidation(props);\n\n  // @ts-expect-error imprecise typing in @react-stately/selection\n  let tree = useCollection<T, TreeCollection<T>>(\n    props,\n    (nodes) => new TreeCollection(nodes, { expandedKeys }),\n    context,\n    [expandedKeys]\n  );\n\n  const selectionManager = new TreeSelectionManager(\n    tree as Collection<Node<T>>,\n    selectionState\n  );\n\n  useTreeRef({ selectionManager, setExpandedKeys, tree }, treeRef);\n\n  // Reset focused key if that item is deleted from the collection.\n  useEffect(() => {\n    if (\n      selectionState.focusedKey != null &&\n      !tree.getItem(selectionState.focusedKey)\n    ) {\n      // @ts-expect-error imprecise typing in @react-stately/selection\n      selectionState.setFocusedKey(null);\n    }\n  }, [tree, selectionState.focusedKey]);\n\n  const toggleKey = (key: Key) => {\n    let newExpandedKeys = toggleTreeNode(\n      tree as Collection<Node<T>>,\n      expandedKeys,\n      key\n    );\n    if (childExpansionBehaviour === \"single\") {\n      const expandedSiblings = getSiblings(tree, key).filter(\n        (aKey) => aKey !== key && expandedKeys.has(aKey)\n      );\n      newExpandedKeys = expandedSiblings.reduce((expandedKeys, expandedKey) => {\n        return toggleTreeNode(\n          tree as Collection<Node<T>>,\n          expandedKeys,\n          expandedKey\n        );\n      }, newExpandedKeys);\n    }\n    setExpandedKeys(newExpandedKeys);\n  };\n\n  return {\n    collection: tree as Collection<Node<T>>,\n    expandedKeys,\n    disabledKeys,\n    toggleKey,\n    selectionManager,\n  };\n}\n\nfunction getChildItems<T>(node: Node<T>): Node<T>[] {\n  const childNodes = [...(node.childNodes || [])];\n  const childItems = childNodes.filter(({ type }) => type === \"item\");\n  const sectionItems = childNodes.filter(({ type }) => type === \"section\");\n\n  return childItems.concat(sectionItems.flatMap(getChildItems));\n}\n\nfunction getRootItemKeys(tree: TreeCollection<unknown>) {\n  return tree.rootKeys\n    .map((key) => tree.getItem(key))\n    .filter(notNull)\n    .flatMap(getChildItems)\n    .map(({ key }) => key);\n}\n/**\n * Returns the siblings of an item in tree, ignoring sections.\n * Disclaimer: The code is done quick and dirty and in a rush. Unpleasant code, good candidate for refactoring :D\n */\nfunction getSiblings(tree: TreeCollection<unknown>, key: Key): Key[] {\n  const parentKey = tree.getItem(key)?.parentKey;\n  if (!parentKey) {\n    return [...tree.rootKeys].concat(getRootItemKeys(tree));\n  }\n  let parent = parentKey ? tree.getItem(parentKey) : null;\n  if (parent?.type === \"item\") {\n    return getChildItems(parent).map(({ key }) => key);\n  }\n  const siblings: Key[] = [];\n  while (parent) {\n    siblings.push(...getChildItems(parent).map(({ key }) => key));\n    if (parent.type === \"section\") {\n      if (parent.parentKey) {\n        parent = tree.getItem(parent.parentKey);\n      } else {\n        siblings.push(...getRootItemKeys(tree));\n        parent = null;\n      }\n    } else {\n      parent = null;\n    }\n  }\n  return Array.from(new Set(siblings));\n}\nfunction toggleTreeNode(\n  tree: Collection<Node<unknown>>,\n  expandedKeys: Set<Key>,\n  key: Key\n): Set<Key> {\n  // toggling a non-expandable node should be no-op\n  if (!expandedKeys.has(key) && !tree.getItem(key).hasChildNodes) {\n    return expandedKeys;\n  }\n  const newKeys = toggleKey(expandedKeys, key);\n  // In Intellij impl, when a node is collapsed, all descendants are also collapsed. In other words, keys that are\n  // not a part of the list of visible nodes, will be excluded from the expanded keys, with the toggle action.\n  for (const aKey of newKeys) {\n    if (tree.getItem(aKey) == null) {\n      newKeys.delete(aKey);\n    }\n  }\n\n  // If we are toggling it open, expand all expandable single-child items\n  if (newKeys.has(key)) {\n    for (const aKey of getSingleChildrenKeys(tree.getItem(key))) {\n      newKeys.add(aKey);\n    }\n  }\n  return newKeys;\n}\n\nfunction toggleKey(set: Set<Key>, key: Key): Set<Key> {\n  let res = new Set(set);\n  if (res.has(key)) {\n    res.delete(key);\n  } else {\n    res.add(key);\n  }\n\n  return res;\n}\n","import { usePrevious } from \"@intellij-platform/core/utils/usePrevious\";\nimport { CacheInvalidationContext } from \"./Item\";\n\nexport interface CollectionCacheInvalidationProps {\n  /**\n   * Defines cache invalidation policy for items. By default, the render result is cached based on the item objects.\n   * This is equivalent of passing false or not passing anything for `cacheInvalidation`. If `true` is passed, it will\n   * always invalidate the render result, causing the collection to be recreated on each re-render. It can\n   * considerably affect performance in large collections. in addition to boolean value, an object with the list of\n   * invalidators can also be passed. renderer function is called each time any of the invalidators are changed.\n   * Think of it as [dependency array in react hooks](https://reactjs.org/docs/hooks-reference.html#usememo). Except\n   * that the length of the array can also safely change.\n   */\n  cacheInvalidation?: boolean | { invalidators: ReadonlyArray<unknown> };\n}\n\n/**\n * Allows cache invalidation options based on input props, for components that use collection\n */\nexport const useCollectionCacheInvalidation = ({\n  cacheInvalidation,\n}: CollectionCacheInvalidationProps): CacheInvalidationContext => {\n  const invalidators =\n    typeof cacheInvalidation === \"object\" ? cacheInvalidation.invalidators : [];\n  const lastInvalidators = usePrevious(invalidators);\n\n  const invalidated =\n    typeof cacheInvalidation === \"object\"\n      ? cacheInvalidation.invalidators.length !== lastInvalidators.length ||\n        cacheInvalidation.invalidators.some(\n          (anInvalidator, index) => anInvalidator !== lastInvalidators[index]\n        )\n      : cacheInvalidation;\n\n  return {\n    invalidated,\n  };\n};\n","import { ForwardedRef, Key, useImperativeHandle } from \"react\";\nimport { useLatest } from \"@intellij-platform/core/utils/useLatest\";\nimport { TreeSelectionManager } from \"./TreeSelectionManager\";\nimport { TreeCollection } from \"./useTreeState\";\n\nexport interface TreeRefValue {\n  focus(key: Key): void;\n  replaceSelection(key: Key): void;\n\n  /**\n   * Extends selection to all siblings of the currently focused node.\n   */\n  expandSelection(): void;\n  /**\n   * Shrinks selection towards currently focused node.\n   */\n  shrinkSelection(): void;\n\n  expandAll(): void;\n  collapseAll(): void;\n}\n\n/**\n * Sets up a tree ref for imperatively working with tree from outside. For imperatively focusing, expanding to\n * specific key, etc.\n */\nexport function useTreeRef<T extends {}>(\n  props: {\n    tree: TreeCollection<T>;\n    selectionManager: TreeSelectionManager;\n    setExpandedKeys: (keys: Set<Key>) => void;\n  },\n  forwardedRef?: ForwardedRef<TreeRefValue>\n) {\n  const latestState = useLatest(props);\n\n  useImperativeHandle(\n    forwardedRef,\n    () => {\n      return {\n        replaceSelection: (key: Key) => {\n          latestState.current.selectionManager.replaceSelection(key);\n        },\n        focus: (key: Key) => {\n          const selectionManager = latestState.current.selectionManager;\n          selectionManager.setFocused(true);\n          /**\n           * NOTE: we set focus key to null and set it to key again, to make sure scroll into view works even when\n           * the key is currently focused but not in view. It wouldn't be needed if there was an imperative handle\n           * for scrolling an item into view, but it's only implemented in way that is reactive to changes to the\n           * focused key. {@see useCollectionAutoScroll}\n           */\n          // @ts-expect-error: setFocusedKey typing mistakenly doesn't accept null, while it should\n          selectionManager.setFocusedKey(null);\n          setTimeout(() => {\n            selectionManager.setFocusedKey(key);\n          });\n        },\n        expandSelection() {\n          latestState.current.selectionManager.expandSelection();\n        },\n        shrinkSelection() {\n          latestState.current.selectionManager.shrinkSelection();\n        },\n        expandAll() {\n          latestState.current.setExpandedKeys(\n            latestState.current.tree.getAllExpandableKeys()\n          );\n        },\n        collapseAll() {\n          const { tree, setExpandedKeys, selectionManager } =\n            latestState.current;\n          const focusedKey = selectionManager.focusedKey;\n          setExpandedKeys(new Set());\n\n          // Find the root node that is a grandparent of focused node, and focus/select it.\n          // NOTE: this behaviour of updating selection when nodes are collapsed is something to be fixed in general,\n          // and then this custom logic here would be not necessary.\n          if (focusedKey && !tree.rootKeys.includes(focusedKey)) {\n            let item = tree.getItem(focusedKey);\n            while (item?.parentKey != null) {\n              item = tree.getItem(item.parentKey);\n            }\n            if (item) {\n              selectionManager.setFocusedKey(item.key);\n              if (selectionManager.isSelected(focusedKey)) {\n                selectionManager.select(item.key);\n              }\n            }\n          }\n        },\n      };\n    },\n    []\n  );\n}\n","import { LayoutNode, ListLayout } from \"@react-stately/layout\";\nimport React, { Key } from \"react\";\nimport { InvalidationContext, Rect, Size } from \"@react-stately/virtualizer\";\nimport { Node } from \"@react-types/shared\";\n\n/**\n * Extends `ListLayout` and allows items of the list to have width based on the content. `ListLayout` by default\n * sets width based on the virtualizer's visible rect. This means the overflow of list items will be clipped.\n * In `VariableWidthListLayout`, the width of the list depends on the content of the visible items.\n *\n * NOTE: At the time of writing this class, Virtualization in @react-aria and @react-stately don't have proper\n * documentation, and it wasn't clear if there could be better ways of letting list's width grow based on the content.\n * Also, this implementation currently lacks support for sections. `buildSection()` would most probably need to be\n * overridden like how `buildItem` is.\n */\nexport class VariableWidthListLayout<T> extends ListLayout<T> {\n  /**\n   * content width of items are stored here, if the content width is bigger than the Virtualizer's visible rect's width.\n   */\n  keyToWidth = new Map<Key, number>();\n  private visibleContentWidth: number = 0;\n\n  buildItem(node: Node<T>, x: number, y: number): LayoutNode {\n    const layoutNode = super.buildItem(node, x, y);\n    if (this.visibleContentWidth) {\n      layoutNode.layoutInfo.rect.width = this.visibleContentWidth;\n    }\n    return layoutNode;\n  }\n\n  buildCollection(): LayoutNode[] {\n    this.visibleContentWidth = this.getVisibleContentWidth();\n    // in buildChild, if invalidateEverything is false and y is not changed, it will reuse the existing layoutInfo.\n    // which can be problematic, if it was created in a time when the visible content width was different.\n    // A more efficient approach (instead of rebuilding the whole collection), might be to set layout width to\n    // visibleContentWidth, in getVisibleLayoutInfos, if mutation is ok.\n    // UPDATE: using getFinalLayoutInfo seems to be a legitimate last minute way to mutate layout infos.\n    this.invalidateEverything =\n      this.contentSize?.width !== this.visibleContentWidth;\n    const layoutNodes = super.buildCollection();\n    this.contentSize.width = this.visibleContentWidth;\n    return layoutNodes;\n  }\n\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    return (\n      super.shouldInvalidate(newRect, oldRect) ||\n      this.getVisibleContentWidth() !== this.visibleContentWidth\n    );\n  }\n\n  // Setting lastWidth doesn't seem to be important, but we set it based on the content anyway.\n  validate(invalidationContext: InvalidationContext<Node<T>, unknown>) {\n    super.validate(invalidationContext);\n    this.lastWidth = this.contentSize.width;\n  }\n\n  updateItemSize(key: React.Key, size: Size): boolean {\n    const changed = super.updateItemSize(key, size);\n    const layoutInfo = this.layoutInfos.get(key);\n    if (layoutInfo && size.width > this.contentSize.width) {\n      this.keyToWidth.set(key, size.width);\n      return true;\n    } else {\n      this.keyToWidth.delete(key);\n      return changed;\n    }\n  }\n\n  private getVisibleContentWidth() {\n    return Math.max(\n      this.virtualizer.visibleRect.width,\n      ...this.virtualizer.visibleViews.map((view) => {\n        const layoutInfo = view.layoutInfo;\n        const itemContentWidth =\n          layoutInfo && this.keyToWidth.get(layoutInfo.key);\n        if (\n          itemContentWidth &&\n          layoutInfo.rect.intersects(this.virtualizer.getVisibleRect())\n        ) {\n          return itemContentWidth;\n        }\n        return 0;\n      })\n    );\n  }\n}\n","import React, { HTMLAttributes, useMemo } from \"react\";\nimport { LayoutNode } from \"@react-stately/layout\";\nimport { Node } from \"@react-types/shared\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { VirtualizerProps } from \"@react-aria/virtualizer\";\nimport { LayoutInfo, Rect } from \"@react-stately/virtualizer\";\nimport { VariableWidthListLayout } from \"@intellij-platform/core/VariableWidthListLayout\";\n\nclass FlattenedTreeLayout<T> extends VariableWidthListLayout<T> {\n  buildChild(node: Node<T>, x: number, y: number): LayoutNode {\n    const layoutNode = super.buildChild(node, x, y);\n    if (\n      node.parentKey &&\n      this.collection.getItem(node.parentKey)?.type === \"item\"\n    ) {\n      layoutNode.layoutInfo.parentKey = null;\n    }\n    return layoutNode;\n  }\n\n  getVisibleLayoutInfos(rect: Rect): LayoutInfo[] {\n    return super\n      .getVisibleLayoutInfos(rect)\n      .filter((layoutInfo) => this.collection.getItem(layoutInfo.key) != null);\n  }\n}\n\nexport const useTreeVirtualizer = <T extends object>({\n  state,\n}: {\n  state: TreeState<T>;\n}): {\n  virtualizerProps: Omit<\n    VirtualizerProps<any, unknown>,\n    \"children\" | keyof HTMLAttributes<HTMLElement>\n  >;\n} => {\n  const layout = useMemo(\n    () =>\n      new FlattenedTreeLayout({\n        /**\n         * there is currently no documentation available for these fields, but setting `rowHeight` enforces it, which\n         * wouldn't be good for custom tree UI with a different row height.\n         * wrong estimatedRowHeight seems to only affect small scrollbar position inaccuracy, which is a minor issue\n         * and not even noticeable in most cases. Also, it seems it slightly improves the performance if it exactly\n         * matches the real row height. But not even sure.\n         */\n        estimatedRowHeight: 20,\n      }),\n    []\n  );\n  layout.collection = state.collection;\n  layout.disabledKeys = state.disabledKeys;\n\n  return {\n    virtualizerProps: {\n      focusedKey: state.selectionManager.focusedKey,\n      collection: state.collection,\n      layout,\n      // Not clear how this sizeToFit is supposed to work, due to lack of documentation, but don't be tempted to\n      // think it solves the problem VariableWidthListLayout is trying to solve, because it doesn't :D\n      // Also, note that setting this to \"width\" prevents re-layout when container width is increased, which\n      // causes issues.\n      sizeToFit: \"height\",\n      scrollToItem: (key) => {\n        return layout.virtualizer.scrollToItem(key, {\n          shouldScrollX: false,\n          duration: 0,\n        });\n      },\n      scrollDirection: \"both\",\n    },\n  };\n};\n","export function isWordSeparator(c: string) {\n  return (\n    isWhitespace(c) || c == \"_\" || c == \"-\" || c == \":\" || c == \"+\" || c == \".\"\n  );\n}\n\nexport function isWhitespace(char: string): boolean {\n  return /^\\s*$/.test(char);\n}\n\nexport function isUpperCase(str: string) {\n  return str.toUpperCase() === str && str.toLowerCase() !== str;\n}\n","import { createRangesFromIndices, TextRange } from \"./TextRange\";\nimport {\n  isUpperCase,\n  isWhitespace,\n  isWordSeparator,\n} from \"./utils/string-utils\";\n\nfunction isMeaningfulChar(ch: string) {\n  return !isWordSeparator(ch) && !isWhitespace(ch);\n}\n\n// Simplified version of https://github.com/JetBrains/intellij-community/blob/master/platform/util/text-matching/src/com/intellij/psi/codeStyle/MinusculeMatcherImpl.java\nexport const minusculeMatch = (\n  input: string,\n  rawPattern: string\n): Array<TextRange> | null => {\n  const isStarts = input.split(\"\").map(isStart);\n  const pattern = rawPattern.split(\"\").filter(isMeaningfulChar).join(\"\");\n  const matches: Array<{ patternIndex: number; inputIndex: number }> = [];\n  let continuous = false;\n  let inputIndex = 0,\n    patternIndex = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (matches.length === pattern.length) {\n      return createRangesFromIndices(matches.map(({ inputIndex: i }) => i));\n    }\n    if (inputIndex > input.length - 1) {\n      if (matches.length > 0) {\n        // TODO: the same character match can be popped out and in several times, if something\n        //  is popped out, it should never be added back again, since it's already examined without\n        //  a full match.\n        const lastMatch = matches.pop()!;\n        inputIndex = lastMatch.inputIndex + 1;\n        patternIndex = lastMatch.patternIndex;\n        continue;\n      }\n      break;\n    }\n    if (!isMeaningfulChar(input[inputIndex])) {\n      inputIndex++;\n      continue;\n    }\n    if (\n      pattern[patternIndex].toLowerCase() === input[inputIndex].toLowerCase() &&\n      (continuous || isStarts[inputIndex] || matches.length === 0)\n    ) {\n      matches.push({ patternIndex, inputIndex });\n      continuous = true;\n      patternIndex++;\n      inputIndex++;\n    } else {\n      continuous = false;\n      inputIndex++;\n    }\n  }\n  return null;\n};\n\nfunction isStart(char: string, index: number, chars: string[]): boolean {\n  const previousChar = chars[index - 1];\n  return (\n    index === 0 ||\n    (isWordSeparator(previousChar) && !isWordSeparator(char)) ||\n    (isUpperCase(char) && !isUpperCase(previousChar))\n  );\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, {\n  FocusEvent,\n  HTMLAttributes,\n  Key,\n  KeyboardEvent,\n  RefObject,\n  useEffect,\n} from \"react\";\nimport { focusSafely, getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { FocusStrategy, KeyboardDelegate } from \"@react-types/shared\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { MultipleSelectionManager } from \"@react-stately/selection\";\nimport { useLocale } from \"@react-aria/i18n\";\nimport { useTypeSelect } from \"@react-aria/selection\";\nimport { isCtrlKeyPressed } from \"../utils/keyboard-utils\";\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager;\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate;\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>;\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy;\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean;\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean;\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean;\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean;\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean;\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean;\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean;\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>;\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(\n  options: SelectableCollectionOptions\n): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = false,\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n  } = options;\n  let { direction } = useLocale();\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (e.altKey || !ref.current?.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (\n      key: Key | undefined,\n      childFocus?: FocusStrategy\n    ) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === \"multiple\") {\n          manager.extendSelection(key);\n        } else if (selectOnFocus) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case \"ArrowDown\": {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey =\n            manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case \"ArrowUp\": {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey =\n            manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case \"ArrowLeft\": {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey, direction === \"rtl\" ? \"first\" : \"last\");\n        }\n        break;\n      }\n      case \"ArrowRight\": {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey, direction === \"rtl\" ? \"last\" : \"first\");\n        }\n        break;\n      }\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(\n            manager.focusedKey,\n            isCtrlKeyPressed(e)\n          );\n          // @ts-expect-error ignored strictness error in copied code\n          manager.setFocusedKey(firstKey);\n          if (\n            isCtrlKeyPressed(e) &&\n            e.shiftKey &&\n            manager.selectionMode === \"multiple\"\n          ) {\n            // @ts-expect-error ignored strictness error in copied code\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            // @ts-expect-error ignored strictness error in copied code\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(\n            manager.focusedKey,\n            isCtrlKeyPressed(e)\n          );\n          // @ts-expect-error ignored strictness error in copied code\n          manager.setFocusedKey(lastKey);\n          if (\n            isCtrlKeyPressed(e) &&\n            e.shiftKey &&\n            manager.selectionMode === \"multiple\"\n          ) {\n            // @ts-expect-error ignored strictness error in copied code\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            // @ts-expect-error ignored strictness error in copied code\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          // @ts-expect-error ignored strictness error in copied code\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"a\":\n        if (\n          isCtrlKeyPressed(e) &&\n          manager.selectionMode === \"multiple\" &&\n          disallowSelectAll !== true\n        ) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case \"Escape\":\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case \"Tab\": {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {\n              tabbable: true,\n            });\n            let next: HTMLElement | undefined;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              next.focus();\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      let key: Key | undefined;\n      if (\n        relatedTarget &&\n        e.currentTarget.compareDocumentPosition(relatedTarget) &\n          Node.DOCUMENT_POSITION_FOLLOWING\n      ) {\n        // @ts-expect-error ignored strictness error in copied code\n        key = manager.lastSelectedKey ?? delegate.getLastKey?.();\n      } else {\n        // @ts-expect-error ignored strictness error in copied code\n        key = manager.firstSelectedKey ?? delegate.getFirstKey?.();\n      }\n      if (key != null) {\n        manager.setFocusedKey(key);\n      }\n    }\n  };\n\n  let onBlur = (e: FocusEvent) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  useEffect(() => {\n    if (autoFocus) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === \"first\") {\n        focusedKey = delegate.getFirstKey?.();\n      }\n      if (autoFocus === \"last\") {\n        focusedKey = delegate.getLastKey?.();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus && ref.current) {\n        focusSafely(ref.current);\n      }\n\n      ///////////////////////////////////////////////////// MODIFICATION ///////////////////////////////////////////////\n      // Fixing https://github.com/adobe/react-spectrum/issues/4391\n      if (\n        options.selectOnFocus &&\n        (autoFocus === \"first\" || autoFocus === \"last\")\n      ) {\n        manager.replaceSelection(focusedKey);\n      }\n      /////////////////////////////////////////////////// END OF MODIFICATION //////////////////////////////////////////\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e: React.MouseEvent) {\n      // Prevent focus going to the collection when clicking on the scrollbar.\n      e.preventDefault();\n    },\n  };\n\n  let { typeSelectProps } = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager,\n    onTypeSelect: selectOnFocus\n      ? (key) => {\n          manager.replaceSelection(key);\n        }\n      : undefined,\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number | undefined;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex,\n    },\n  };\n}\n","import { useSelectableItem as useOriginalSelectableItem } from \"@react-aria/selection\";\nimport { MouseEventHandler } from \"react\";\nimport { mergeProps } from \"@react-aria/utils\";\n\n/**\n * A wrapper around useSelectableItem, which adjusts for intellij platform nuances:\n * - Selects item with right clicks as well, which allows ContextMenuContainer to be used with any collection component\n *   without the need for built-in context-menu support in such components. We won't need this if we move to a built-in\n *   context-menu support for List,Tree, etc.\n * @private\n */\nexport const useSelectableItem: typeof useOriginalSelectableItem = (\n  options\n) => {\n  const onContextMenu: MouseEventHandler<HTMLElement> = (e) => {\n    if (!options.selectionManager.isSelected(options.key)) {\n      options.selectionManager.select(options.key, {\n        type: \"press\",\n        pointerType: \"mouse\",\n        target: e.currentTarget,\n        shiftKey: e.shiftKey,\n        metaKey: e.metaKey,\n        ctrlKey: e.ctrlKey,\n        altKey: e.altKey,\n      });\n    }\n  };\n  const result = useOriginalSelectableItem(options);\n  return {\n    ...result,\n    itemProps: mergeProps(result.itemProps, { onContextMenu }),\n  };\n};\n","/**\n * Drop shadow of windows and other overlays.\n * The current value is not accurate and needs to be revisited. It should also be os-dependant.\n * FIXME: On windows, there is only a border-like shadow. No drop shadow\n * FIXME: On Mac, there is a border-like shadow and a drop shadow. the border-like shadow is missing in the current value\n */\nexport const WINDOW_SHADOW = \"box-shadow: 0 5px 15px rgb(0 0 0 / 30%)\";\n","import * as styledComponents from \"styled-components\";\nimport { ThemedStyledComponentsModule } from \"styled-components\";\nimport { Theme } from \"./Theme\";\nimport { KnownThemePropertyPath } from \"./Theme/types\";\n\ntype JuiStyledComponentsModule = ThemedStyledComponentsModule<\n  Theme<KnownThemePropertyPath>\n>;\n\nexport const styled =\n  styledComponents.default as JuiStyledComponentsModule[\"default\"];\nexport const useTheme =\n  styledComponents.useTheme as JuiStyledComponentsModule[\"useTheme\"];\nexport const css = styledComponents.css as JuiStyledComponentsModule[\"css\"];\nexport const ThemeConsumer =\n  styledComponents.ThemeConsumer as JuiStyledComponentsModule[\"ThemeConsumer\"];\n","import {\n  FocusManager,\n  focusSafely,\n  FocusScope as WrappedFocusScope,\n  FocusScopeProps,\n  useFocusManager,\n} from \"@react-aria/focus\";\nimport React, {\n  ForwardedRef,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n} from \"react\";\n\ntype BetterFocusScopeProps = FocusScopeProps & {\n  /**\n   *\n   */\n  forceRestoreFocus?: boolean;\n};\nexport type FocusScopeRef = { focus: (forceFocusFirst?: boolean) => void };\n/**\n * A version of FocusScope which also allows for imperatively moving focus to the scope.\n * and has tiny patches/improvements\n * It's useful for\n */\nexport const FocusScope = React.forwardRef(function BetterFocusScope(\n  { children, forceRestoreFocus, ...otherProps }: BetterFocusScopeProps,\n  ref: ForwardedRef<FocusScopeRef>\n) {\n  const directChildRef = useRef<HTMLSpanElement>(null);\n  const focusManagerRef = useRef<FocusManager>(null);\n  useForceRestoreFocus(forceRestoreFocus);\n  useImperativeHandle(\n    ref,\n    () => ({\n      focus: (forceFocusFirst?: boolean) => {\n        const focusManager = focusManagerRef.current;\n        const containerElement = directChildRef.current?.parentElement;\n        if (!focusManager) {\n          throw new Error(\"focus manager not found!\");\n        }\n        if (!containerElement) {\n          throw new Error(\"container element not found\");\n        }\n        if (forceFocusFirst) {\n          return focusManager.focusFirst();\n        }\n        const alreadyHasFocused =\n          document.activeElement &&\n          document.activeElement !== containerElement &&\n          containerElement.contains(document.activeElement);\n        if (!alreadyHasFocused) {\n          focusManager.focusNext({ tabbable: true });\n        }\n      },\n    }),\n    []\n  );\n\n  return (\n    <WrappedFocusScope {...otherProps}>\n      <GetFocusManager ref={focusManagerRef} />\n      <span data-focus-root-direct-child=\"\" hidden ref={directChildRef} />\n      {children}\n    </WrappedFocusScope>\n  );\n});\nconst GetFocusManager = React.forwardRef(function FocusScopeHandle(\n  props: {},\n  ref: ForwardedRef<FocusManager>\n) {\n  const focusManager = useFocusManager();\n  useImperativeHandle(ref, () => focusManager, [focusManager]);\n  return null;\n});\n\n/**\n * Kind of a patchy solution for focus restoration when currently focused element is in a different focus scope, but\n * we still want focus restoration to work. So far the only use case is in nested menu, which is rendered as a separate\n * overlay with a focus scope. If focus is within that submenu, when the menu is closed, the default `restoreFocus`\n * doesn't work because there is a check in useRestoreFocus, which requires the currently focused element to be in\n * the focus scope, to do the focus restoration:\n * https://github.com/adobe/react-spectrum/blob/e14523fedd93ac1a4ede355aed70988af572ae74/packages/%40react-aria/focus/src/FocusScope.tsx#L460\n */\nfunction useForceRestoreFocus(restoreFocus?: boolean) {\n  useLayoutEffect(() => {\n    let nodeToRestore = document.activeElement as HTMLElement;\n\n    return () => {\n      if (restoreFocus && nodeToRestore) {\n        requestAnimationFrame(() => {\n          if (document.body.contains(nodeToRestore)) {\n            focusSafely(nodeToRestore);\n          }\n        });\n      }\n    };\n  }, [restoreFocus]);\n}\n","/**\n * Properly typed filter function for filtering out null/undefined items in array.\n */\nexport const notNull = <T>(\n  item: T | undefined | null\n): item is NonNullable<T> => item != null;\n","import React from \"react\";\nimport { isMac } from \"@react-aria/utils\";\n\n/**\n * TODO: The current name is not accurate, and can be confusing. Rename to something better.\n */\nexport function isCtrlKeyPressed(\n  e: { metaKey: boolean; ctrlKey: boolean } | undefined\n) {\n  if (isMac()) {\n    return e?.metaKey;\n  }\n\n  return e?.ctrlKey;\n}\n\nexport function hasAnyModifier(e: KeyboardEvent | React.KeyboardEvent) {\n  return e.altKey || e.ctrlKey || e.metaKey || e.shiftKey;\n}\n","import React, { useContext } from \"react\";\n\nexport const useContextOrThrow = <ContextType extends unknown>(\n  Context: React.Context<ContextType | null>,\n  nullErrorMessage: string\n) => {\n  const context = useContext<ContextType | null>(Context);\n\n  if (context == null) {\n    throw new Error(nullErrorMessage);\n  }\n\n  return context;\n};\n","import { useCallback, useLayoutEffect, useRef } from \"react\";\n\n/**\n * Interim solution for non-reactive callbacks, until\n * [useEvent](https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md) (or whatever it will end up being\n * called), becomes available.\n */\nexport function useEventCallback<T extends (...args: any[]) => any>(fn: T): T {\n  let ref = useRef<typeof fn>();\n  useLayoutEffect(() => {\n    ref.current = fn;\n  });\n  const callback = ((...args: Parameters<T>) =>\n    ref.current?.apply(null, args)) as T;\n  return useCallback<T>(callback, []);\n}\n","import React, { useRef } from \"react\";\n\n/**\n * For when a component needs to forward ref, but it too needs to use the same ref. Since forwarded ref can be in form\n * of a callback too, this will normalize it as a RefObject.\n * NOTE: Should we keep the ref in state because of edge cases?\n */\nexport default function useForwardedRef<T>(\n  forwardedRef: React.Ref<T>\n): React.RefObject<T> {\n  const innerRef = useRef<T>(null);\n  React.useEffect(() => {\n    if (!forwardedRef) {\n      return;\n    }\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(innerRef.current);\n    } else {\n      (forwardedRef as React.MutableRefObject<T | null>).current =\n        innerRef.current;\n    }\n  });\n\n  return innerRef;\n}\n","import { useLayoutEffect, useRef } from \"react\";\n\nexport function useLatest<T>(value: T) {\n  const ref = useRef(value);\n  useLayoutEffect(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n","import React, { useRef } from \"react\";\nimport { useLayoutEffect } from \"@react-aria/utils\";\nimport {\n  AriaPositionProps,\n  PositionAria,\n  useOverlayPosition,\n} from \"@react-aria/overlays\";\n\n/**\n * `useOverlayPosition` only supports positioning overlay relative to an element, at the moment.\n *  For context menu or tooltip, we may want to position the overlay based on the coordinates of the mouse event which\n *  has triggered the overlay.\n *  This hook wraps `useOverlayPosition`, and is very similar to it, but you don't need to pass `targetRef`. Instead,\n *  you have to call the updatePosition in the event handler that triggers the overlay, passing the `MouseEvent` object.\n *\n * This is hopefully a temporary solution to circumvents the limitation of `useOverlayPosition`, until it supports\n * non-element based positioning as well. It works by appending a dummy 1x1 px element to body and positioning it\n * based on React.MouseEvent objects. Then it uses a ref to that element as the `targetRef`, passed to `useOverlayPosition`\n *\n * @example\n * ```ts\n * const { updatePosition, overlyProps} = useMouseEventOverlayPosition({ overlayRef });\n *\n * const onContextMenu = (event: React.ReactEvent) => {\n *  updatePosition(event);\n *  // ...\n * }\n * ```\n */\nlet globalMoveHandler: null | ((e: MouseEvent) => void) = null;\nlet lastMouseClientPos = { x: 0, y: 0 };\n\nexport function useMouseEventOverlayPosition(\n  options: Omit<AriaPositionProps, \"targetRef\">\n): Omit<PositionAria, \"updatePosition\"> & {\n  updatePosition: (event?: React.MouseEvent) => void;\n} {\n  const targetRef = useRef<HTMLElement>(null);\n\n  useLayoutEffect(() => {\n    if (!globalMoveHandler) {\n      // After the first use of the hook, the listener will be attached forever. Not a big deal but can be improved.\n      globalMoveHandler = (e) => {\n        lastMouseClientPos = { x: e.clientX, y: e.clientY };\n      };\n      document.addEventListener(\"mousemove\", globalMoveHandler);\n    }\n    if (!targetRef.current) {\n      const fakeTarget = document.createElement(\"span\");\n      Object.assign(fakeTarget.style, {\n        width: \"0px\",\n        height: \"0px\",\n        pointerEvents: \"none\",\n        position: \"fixed\",\n        visibility: \"hidden\",\n      });\n      document.body.appendChild(fakeTarget);\n      // @ts-expect-error We intentionally don't pass null to generic argument, to not have it as a mutable nullable\n      // ref, since we are mimicking an element ref.\n      targetRef.current = fakeTarget;\n      return () => {\n        fakeTarget.remove();\n      };\n    }\n  }, []);\n\n  useLayoutEffect(() => {\n    if (options.isOpen && targetRef.current) {\n      targetRef.current.style.left = `${lastMouseClientPos.x}px`;\n      targetRef.current.style.top = `${lastMouseClientPos.y}px`;\n      updatePosition();\n    }\n  }, [options.isOpen, targetRef.current]);\n\n  const { updatePosition, ...result } = useOverlayPosition({\n    ...options,\n    targetRef,\n  });\n\n  return {\n    ...result,\n    /**\n     * Ref to be passed to be passed as targetRef\n     */\n    updatePosition: (e?: React.MouseEvent) => {\n      if (targetRef.current && e) {\n        targetRef.current.style.left = `${e.clientX}px`;\n        targetRef.current.style.top = `${e.clientY}px`;\n      }\n      updatePosition();\n    },\n  };\n}\n","import { useEffect, useRef } from \"react\";\n\nexport function usePrevious<T>(value: T): T {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n","import React, { useEffect, useMemo } from \"react\";\nimport { SSRProvider } from \"@react-aria/ssr\";\nimport darculaTheme from \"../../../jui/themes/darcula.theme.json\";\nimport highContrastTheme from \"../../../jui/themes/HighContrast.theme.json\";\nimport lightTheme from \"../../../jui/themes/intellijlaf.theme.json\";\nimport { Theme, ThemeProvider } from \"../../../jui/src\";\n\nexport type ExampleContextThemeName = \"light\" | \"darcula\" | \"highContrast\";\n\nexport const ExampleContext: React.FC<{\n  themeName?: ExampleContextThemeName;\n}> = ({ children, themeName = \"darcula\" }) => {\n  const themeJson = (\n    {\n      light: lightTheme,\n      highContrast: highContrastTheme,\n      darcula: darculaTheme,\n    } as const\n  )[themeName];\n\n  // IMPORTANT: passing a function that returns Theme is crucial in get it working. Otherwise, ThemeProvider will try\n  // to \"merge\" themes, and the end result is an POJO, with prototype link lost.\n  // @ts-expect-error ThemeJson type is not accurate ATM.\n  const theme = useMemo(() => new Theme(themeJson), [themeJson]);\n\n  useFixDocusaurusStyleBleeds();\n  return (\n    <SSRProvider>\n      <ThemeProvider theme={theme}>{children}</ThemeProvider>\n    </SSRProvider>\n  );\n};\n\n/**\n * TODO: add a surrounding UI for examples, with tools for theme selection for example.\n */\nexport const Example: React.FC = ({ children }) => (\n  <ExampleContext>\n    <div\n      // @ts-expect-error: css prop is not working for some reason\n      css={`\n        background: ${({ theme }) => theme.color(\"*.background\")};\n      `}\n    >\n      {children}\n    </div>\n  </ExampleContext>\n);\n\nexport const withExampleContext = <P extends {}>(\n  Component: React.ComponentType<P>\n) => {\n  function WithExampleContext(props: P) {\n    return (\n      <ExampleContext>\n        <Component {...props} />\n      </ExampleContext>\n    );\n  }\n\n  return WithExampleContext;\n};\n\nconst useFixDocusaurusStyleBleeds = () => {\n  useEffect(() => {\n    const FLAG_CLASSNAME = \"example-context-patch\";\n    if (!document.body.classList.contains(FLAG_CLASSNAME)) {\n      try {\n        undoUseKeyboardNavigation();\n        document.body.classList.add(FLAG_CLASSNAME);\n      } catch (e) {\n        console.error(\"Could not undo useKeyboardNavigation\");\n      }\n    }\n  }, []);\n};\n\n/**\n * Reverts the \"improvement\" [useKeyboardNavigation][1] does :|\n *\n * [1]: https://github.com/facebook/docusaurus/blob/f87a3ead4664b301901c12466cb2c82cd95d141b/packages/docusaurus-theme-common/src/hooks/useKeyboardNavigation.ts#L14\n */\nfunction undoUseKeyboardNavigation() {\n  document\n    .querySelectorAll<HTMLLinkElement>(\"link[rel=stylesheet]\")\n    .forEach((linkEl) => {\n      for (let i = 0; i < linkEl.sheet.cssRules.length; i++) {\n        const rule = linkEl.sheet.cssRules.item(i);\n        if (rule.cssText?.startsWith(\"body:not(.navigation-with-keyboard)\")) {\n          linkEl.sheet.deleteRule(i); // We can change the rule to only disable it within the boundary of example\n        }\n      }\n    });\n}\n","import { DividerItem } from \"./src/Collections/Divider\";\n\nexport type Legend = { name: string };\nexport const legends: Array<\n  Legend | DividerItem | { items: Legend[]; title: string }\n> = [\n  { name: \"Paco de Lucia\" },\n  { name: \"Vicente Amigo\" },\n  new DividerItem(),\n  { name: \"Gerardo Nunez\" },\n  { name: \"Paco Serrano\" },\n  new DividerItem(),\n  { name: \"Sabicas\" },\n  {\n    title: \"Super legends\",\n    items: [{ name: \"Sabicas2\" }],\n  },\n  { name: \"Pepe Habichuela\" },\n  { name: \"El Amir\" },\n  { name: \"Paco Peña\" },\n];\n","import React from \"react\";\nimport { CollectionElement } from \"@react-types/shared\";\nimport { Item } from \"@react-stately/collections\";\n\nimport { HighlightedTextValue } from \"../CollectionSpeedSearch\";\n\ntype TreeItem = {\n  name: string;\n  children?: TreeItem[];\n};\nexport const treeItems: TreeItem[] = [\n  { name: \"index.ts\" },\n  {\n    name: \"List\",\n    children: [\n      {\n        name: \"BasicList\",\n        children: [\n          { name: \"BasicList.stories.tsx\" },\n          { name: \"BasicList.tsx\" },\n          { name: \"BasicListItem.tsx\" },\n          { name: \"useBasicList.ts\" },\n        ],\n      },\n      {\n        name: \"SpeedSearchList\",\n        children: [\n          { name: \"SpeedSearchList.stories.tsx\" },\n          { name: \"SpeedSearchList.tsx\" },\n          { name: \"SpeedSearchListItem.tsx\" },\n          { name: \"useSpeedSearchList.ts\" },\n        ],\n      },\n      { name: \"ListDivider.tsx\" },\n    ],\n  },\n  { name: \"Theme\", children: [{ name: \"createTheme.ts\" }] },\n];\n\nexport const staticTreeItems: Array<CollectionElement<any>> = (\n  <>\n    <Item key=\"index.ts\" textValue=\"index.ts\">\n      index.ts\n    </Item>\n    <Item textValue=\"List\" title=\"List\" key=\"List\">\n      <Item textValue=\"BasicList\" title=\"BasicList\" key=\"BasicList\">\n        <Item textValue=\"BasicList.stories.tsx\">BasicList.stories.tsx</Item>\n        <Item textValue=\"BasicList.tsx\">BasicList.tsx</Item>\n        <Item textValue=\"BasicListItem.tsx\">BasicListItem.tsx</Item>\n        <Item textValue=\"useBasicList.ts\">useBasicList.ts</Item>\n      </Item>\n\n      <Item\n        textValue=\"SpeedSearchList\"\n        title=\"SpeedSearchList\"\n        key=\"SpeedSearchList\"\n      >\n        <Item textValue=\"SpeedSearchList.stories.tsx\">\n          SpeedSearchList.stories.tsx\n        </Item>\n        <Item textValue=\"SpeedSearchList.tsx\">SpeedSearchList.tsx</Item>\n        <Item textValue=\"SpeedSearchListItem.tsx\">SpeedSearchListItem.tsx</Item>\n        <Item textValue=\"useSpeedSearchList.ts\">useSpeedSearchList.ts</Item>\n      </Item>\n\n      <Item textValue=\"ListDivider.tsx\">ListDivider.tsx</Item>\n    </Item>\n    <Item textValue=\"Theme\" title=\"Theme\" key=\"Theme\">\n      <Item textValue=\"createTheme.ts\">createTheme.ts</Item>\n    </Item>\n  </>\n).props.children;\nexport const staticSpeedSearchTreeItems: Array<CollectionElement<any>> = (\n  <>\n    <Item key=\"index.ts\" textValue=\"index.ts\">\n      {<HighlightedTextValue />}\n    </Item>\n    <Item textValue=\"List\" title={<HighlightedTextValue />} key=\"List\">\n      <Item\n        textValue=\"BasicList\"\n        title={<HighlightedTextValue />}\n        key=\"BasicList\"\n      >\n        <Item textValue=\"BasicList.stories.tsx\">\n          {<HighlightedTextValue />}\n        </Item>\n        <Item textValue=\"BasicList.tsx\">{<HighlightedTextValue />}</Item>\n        <Item textValue=\"BasicListItem.tsx\">{<HighlightedTextValue />}</Item>\n        <Item textValue=\"useBasicList.ts\">{<HighlightedTextValue />}</Item>\n      </Item>\n\n      <Item\n        textValue=\"SpeedSearchList\"\n        title={<HighlightedTextValue />}\n        key=\"SpeedSearchList\"\n      >\n        <Item textValue=\"SpeedSearchList.stories.tsx\">\n          {<HighlightedTextValue />}\n        </Item>\n        <Item textValue=\"SpeedSearchList.tsx\">{<HighlightedTextValue />}</Item>\n        <Item textValue=\"SpeedSearchListItem.tsx\">\n          {<HighlightedTextValue />}\n        </Item>\n        <Item textValue=\"useSpeedSearchList.ts\">\n          {<HighlightedTextValue />}\n        </Item>\n      </Item>\n\n      <Item textValue=\"ListDivider.tsx\">{<HighlightedTextValue />}</Item>\n    </Item>\n    <Item textValue=\"Theme\" title={<HighlightedTextValue />} key=\"Theme\">\n      <Item textValue=\"createTheme.ts\">{<HighlightedTextValue />}</Item>\n    </Item>\n  </>\n).props.children;\n","import { Selection } from \"@react-types/shared\";\nimport React, { HTMLProps, Key } from \"react\";\nimport { styled } from \"./styled\";\nimport { SpeedSearchTree, TreeRefValue } from \"@intellij-platform/core/Tree\";\nimport { staticSpeedSearchTreeItems } from \"@intellij-platform/core/Tree/story-helpers\";\n\nexport const Container = styled.div`\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n`;\nexport const Pane: React.FC<Omit<HTMLProps<HTMLDivElement>, \"style\">> = (\n  props\n) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"column\",\n      width: 400,\n      marginTop: 25,\n      height: \"calc(100vh - 70px)\",\n    }}\n    {...props}\n  />\n);\n\nexport function SelectionLog({ selection }: { selection: Selection }) {\n  return (\n    <pre>\n      {selection instanceof Set && (\n        <div>{JSON.stringify([...selection], null, 2)}</div>\n      )}\n      {JSON.stringify(selection, null, 2)}\n    </pre>\n  );\n}\n\ntype SelectedKeysType = \"all\" | Iterable<Key>;\nexport const SpeedSearchTreeSample = ({\n  selectedKeys,\n  defaultSelectedKeys = [\"BasicList\"],\n  onSelectedKeysChange,\n  treeRef,\n}: {\n  selectedKeys?: SelectedKeysType;\n  defaultSelectedKeys?: SelectedKeysType;\n  onSelectedKeysChange?: (selectedKeys: Selection) => void;\n  treeRef?: React.RefObject<TreeRefValue>;\n}): React.ReactElement => {\n  return (\n    <SpeedSearchTree\n      treeRef={treeRef}\n      autoFocus\n      fillAvailableSpace\n      selectionMode=\"multiple\"\n      defaultExpandedKeys={[\"List\", \"Theme\", \"BasicList\", \"Foo\"]}\n      selectedKeys={selectedKeys}\n      defaultSelectedKeys={new Set(defaultSelectedKeys)}\n      onSelectionChange={onSelectedKeysChange}\n    >\n      {staticSpeedSearchTreeItems}\n    </SpeedSearchTree>\n  );\n};\n","import { Legend, legends } from \"../../test-data\";\nimport React, { ReactNode } from \"react\";\nimport { Story } from \"@storybook/react\";\nimport { SelectionManager } from \"@react-stately/selection\";\nimport {\n  Divider,\n  DividerItem,\n  HighlightedTextValue,\n  Item,\n  List,\n  ListProps,\n  Section,\n  useCollectionSearchInput,\n} from \"@intellij-platform/core\";\n\nimport { Pane } from \"../story-components\";\n\nexport const renderItemCustomUI = (item: Legend, content?: ReactNode) => (\n  <Item key={item.name} textValue={item.name}>\n    <div style={{ height: 40, display: \"flex\", alignItems: \"center\" }}>\n      🎸 &nbsp;\n      <b>{content || item.name}</b>\n    </div>\n  </Item>\n);\nexport const itemRenderer =\n  (\n    renderItem: (item: Legend, content?: ReactNode) => JSX.Element,\n    content?: ReactNode\n  ) =>\n  (item: typeof legends[number]) => {\n    if (item instanceof DividerItem) {\n      return <Divider key={item.key} />;\n    }\n    if (\"items\" in item) {\n      return (\n        <Section items={item.items} key={item.title} title={item.title}>\n          {(item) => renderItem(item, content)}\n        </Section>\n      );\n    }\n    return renderItem(item as Legend, content);\n  };\nexport const renderItemText = (item: Legend) => (\n  <Item key={item.name} textValue={item.name}>\n    {item.name}\n  </Item>\n);\nexport const renderItemTextWithHighlights = (item: Legend) => (\n  <Item key={item.name} textValue={item.name}>\n    <HighlightedTextValue />\n  </Item>\n);\n\nexport const commonListStories = {\n  withConnectedInput: (ListCmp: typeof List) => {\n    const WithConnectedInput: Story<ListProps<any>> = (props) => {\n      const [isFocused, setIsFocused] = React.useState(false);\n      const listRef = React.useRef<HTMLUListElement>(null);\n      const selectionManagerRef = React.useRef<SelectionManager>(null);\n      const { collectionSearchInputProps } = useCollectionSearchInput({\n        collectionRef: listRef,\n        selectionManager: selectionManagerRef.current,\n      });\n      return (\n        <Pane>\n          <input\n            {...collectionSearchInputProps}\n            onFocus={() => setIsFocused(true)}\n            onBlur={() => setIsFocused(false)}\n          />\n          <ListCmp\n            selectionManagerRef={selectionManagerRef}\n            ref={listRef}\n            selectionMode=\"single\"\n            items={legends}\n            showAsFocused={isFocused}\n            fillAvailableSpace\n            {...props}\n          >\n            {itemRenderer(renderItemText)}\n          </ListCmp>\n        </Pane>\n      );\n    };\n    return WithConnectedInput;\n  },\n};\n","import React, { Key, useState } from \"react\";\nimport { Meta, StoryFn, StoryObj } from \"@storybook/react\";\nimport { List, ListProps } from \"./List\";\nimport { legends } from \"../../test-data\";\nimport { Divider } from \"../Collections/Divider\";\nimport { Pane } from \"../story-components\";\nimport {\n  commonListStories,\n  itemRenderer,\n  renderItemCustomUI,\n  renderItemText,\n} from \"./story-helpers\";\nimport {\n  ContextMenuContainer,\n  Item,\n  Menu,\n  MenuItemLayout,\n  PlatformIcon,\n  Section,\n  styled,\n} from \"@intellij-platform/core\";\n\nexport default {\n  title: \"Components/List (Basic)\",\n  component: List,\n} as Meta;\n\nexport const Default: StoryObj<ListProps<typeof legends[number]>> = {\n  render: (props) => (\n    <Pane>\n      <List\n        selectionMode=\"single\"\n        items={legends}\n        fillAvailableSpace\n        {...props}\n      >\n        {itemRenderer(renderItemText)}\n      </List>\n    </Pane>\n  ),\n  args: {},\n};\n\nexport const WithConnectedInput = commonListStories.withConnectedInput(List);\n\nconst StyledLabel = styled.label`\n  color: ${({ theme }) => theme.commonColors.label()};\n  display: inline-flex;\n  align-items: center;\n  gap: 0.25rem;\n`;\nexport const shownAsFocused: StoryFn = () => {\n  const [shownAsFocused, setShowAsFocused] = useState(false);\n  return (\n    <Pane>\n      <StyledLabel>\n        <input\n          type=\"checkbox\"\n          checked={shownAsFocused}\n          onChange={(e) => setShowAsFocused(e.target.checked)}\n        />\n        Show as focused\n      </StyledLabel>\n      <br />\n      <List\n        selectionMode=\"single\"\n        items={legends}\n        fillAvailableSpace\n        showAsFocused={shownAsFocused}\n      >\n        {itemRenderer(renderItemCustomUI)}\n      </List>\n    </Pane>\n  );\n};\n\nexport const WithStaticData: StoryFn = () => {\n  return (\n    <Pane>\n      <List selectionMode=\"multiple\" fillAvailableSpace>\n        <Item>Paco de lucia</Item>\n        <Divider />\n        <Item>Vicente Amigo</Item>\n        <Section title=\"Other\">\n          <Item>Gerardo Nunez</Item>\n          <Item>El Amir</Item>\n        </Section>\n      </List>\n    </Pane>\n  );\n};\n\nexport const MultiSelect: StoryObj<ListProps<object>> = {\n  render: ({ fillAvailableSpace, shouldFocusWrap, showAsFocused }: any) => {\n    return (\n      <Pane>\n        <List\n          selectionMode=\"multiple\"\n          items={legends}\n          fillAvailableSpace={fillAvailableSpace}\n          shouldFocusWrap={shouldFocusWrap}\n          showAsFocused={showAsFocused}\n        >\n          {itemRenderer(renderItemText)}\n        </List>\n      </Pane>\n    );\n  },\n};\n\nexport const WithContextMenu: StoryFn = () => {\n  const [selectedKeys, setSelectedKeys] = useState<\"all\" | Set<Key>>(\n    new Set([])\n  );\n  return (\n    <Pane>\n      <ContextMenuContainer\n        renderMenu={() => {\n          const renderActions = () => {\n            if (typeof selectedKeys !== \"string\" && selectedKeys.size === 0) {\n              return <Item>Nothing here</Item>;\n            } else {\n              return [\n                <Item textValue={`Cut`} key=\"Cut\">\n                  <MenuItemLayout\n                    icon={<PlatformIcon icon={\"actions/menu-cut\"} />}\n                    content={`Cut`}\n                    shortcut={\"⌘X\"}\n                  />\n                </Item>,\n                <Item textValue={`Copy`} key=\"Copy\">\n                  <MenuItemLayout\n                    icon={<PlatformIcon icon={\"actions/copy\"} />}\n                    content={`Copy`}\n                    shortcut={\"⌘C\"}\n                  />\n                </Item>,\n                <Item textValue={`Delete`} key=\"Paste\">\n                  <MenuItemLayout content={`Delete`} shortcut=\"⌫\" />\n                </Item>,\n              ];\n            }\n          };\n          return <Menu aria-label=\"Tree Context Menu\">{renderActions()}</Menu>;\n        }}\n      >\n        <List\n          selectionMode=\"single\"\n          selectedKeys={selectedKeys}\n          onSelectionChange={setSelectedKeys}\n          items={legends}\n          fillAvailableSpace\n        >\n          {itemRenderer(renderItemText)}\n        </List>\n      </ContextMenuContainer>\n    </Pane>\n  );\n};\n","\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\n/* @jsxFrag React.Fragment */\n\nimport React from 'react';\nimport { mdx } from '@mdx-js/react';\n\n\nexport const frontMatter = {};\nexport const contentTitle = 'List';\nexport const metadata = {\n  \"unversionedId\": \"components/List\",\n  \"id\": \"components/List\",\n  \"title\": \"List\",\n  \"description\": \"Used for showing a flat list of items with different selection modes. It's usually used in master-detail views, or for\",\n  \"source\": \"@site/docs/components/List.mdx\",\n  \"sourceDirName\": \"components\",\n  \"slug\": \"/components/List\",\n  \"permalink\": \"/jui/docs/components/List\",\n  \"draft\": false,\n  \"editUrl\": \"https://github.com/alirezamirian/jui/edit/master/packages/website/docs/components/List.mdx\",\n  \"tags\": [],\n  \"version\": \"current\",\n  \"frontMatter\": {},\n  \"sidebar\": \"tutorialSidebar\",\n  \"previous\": {\n    \"title\": \"Link\",\n    \"permalink\": \"/jui/docs/components/Link\"\n  },\n  \"next\": {\n    \"title\": \"Menu\",\n    \"permalink\": \"/jui/docs/components/Menu\"\n  }\n};\nexport const assets = {\n\n};\n\nimport { Default } from \"@intellij-platform/core/List/List.stories\";\nimport { ExampleContext } from \"@site/src/components/ExampleContext\";\nexport const toc = [{\n  value: 'Remaining',\n  id: 'remaining',\n  level: 4\n}, {\n  value: 'ItemLayout',\n  id: 'itemlayout',\n  level: 2\n}, {\n  value: 'SpeedSearchList',\n  id: 'speedsearchlist',\n  level: 2\n}, {\n  value: 'ContextMenu',\n  id: 'contextmenu',\n  level: 2\n}, {\n  value: 'Advanced use',\n  id: 'advanced-use',\n  level: 2\n}, {\n  value: 'Custom list component with useList and useSpeedSearchList',\n  id: 'custom-list-component-with-uselist-and-usespeedsearchlist',\n  level: 3\n}];\n\nconst layoutProps = {\n  toc\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"list\"\n    }}>{`List`}</h1>\n    <p>{`Used for showing a flat list of items with different selection modes. It's usually used in master-detail views, or for\na list of items with a single attribute. Here is some examples from JetBrains IDEs:`}</p>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Settings -> Tools -> SSH Configurations`}</strong>{` (master-detail)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Settings -> Appearance & Behavior -> Scopes`}</strong>{` (master-detail)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Settings -> Editor -> General -> Console -> Exceptions`}</strong>{` (single attribute list of items)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Settings -> Editor -> File and Code Templates`}</strong>{` (master-detail)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Settings -> Editor -> Natural Languages`}</strong>{` (single attribute list of items)`}</li>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Show Local History`}</strong>{` window (advanced layout)`}</li>\n    </ul>\n    <h4 {...{\n      \"id\": \"remaining\"\n    }}>{`Remaining`}</h4>\n    <ul {...{\n      \"className\": \"contains-task-list\"\n    }}>\n      <li parentName=\"ul\" {...{\n        \"className\": \"task-list-item\"\n      }}><input parentName=\"li\" {...{\n          \"type\": \"checkbox\",\n          \"checked\": false,\n          \"disabled\": true\n        }}></input>{` `}{`Virtualized scrolling support for performance with long lists`}</li>\n    </ul>\n    <ExampleContext mdxType=\"ExampleContext\">\n  <Default.render />\n    </ExampleContext>\n    <h2 {...{\n      \"id\": \"itemlayout\"\n    }}>{`ItemLayout`}</h2>\n    <p>{`While you can render any custom content in `}<inlineCode parentName=\"p\">{`Item`}</inlineCode>{`s of a list, `}<inlineCode parentName=\"p\">{`ItemLayout`}</inlineCode>{` is a useful helper component implementing\nthe most common cases. Render different parts of an item, such as icon, text, etc. inside a `}<inlineCode parentName=\"p\">{`ItemLayout`}</inlineCode>{` and it handles\nthe layout, and the spacing between them. Some common parts that require a special style are implemented as components\naccessible on `}<inlineCode parentName=\"p\">{`ItemLayout`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\",\n        \"metastring\": \"live themed\",\n        \"live\": true,\n        \"themed\": true\n      }}>{`<SpeedSearchList selectionMode=\"multiple\">\n  <Item textValue=\"jui\">\n    <ItemLayout>\n      <PlatformIcon icon=\"nodes/folder\" />\n      <HighlightedTextValue />\n      <ItemLayout.Hint>~/workspace/jui</ItemLayout.Hint>\n    </ItemLayout>\n  </Item>\n</SpeedSearchList>\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"speedsearchlist\"\n    }}>{`SpeedSearchList`}</h2>\n    <h2 {...{\n      \"id\": \"contextmenu\"\n    }}>{`ContextMenu`}</h2>\n    <p>{`In order to have context menu for list items, just wrap the list in a `}<inlineCode parentName=\"p\">{`ContextMenuContainer`}</inlineCode>{`. When the context menu\nis triggered on an item, the selection is also updated right before the context menu opens, so you can render the\ncontext menu based on the selected item(s).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\",\n        \"metastring\": \"live themed noPadding\",\n        \"live\": true,\n        \"themed\": true,\n        \"noPadding\": true\n      }}>{`function ListContextMenuExample() {\n  const [selectedKeys, setSelectedKeys] = useState(new Set());\n\n  return (\n    <ContextMenuContainer\n      renderMenu={() => {\n        const selectedKey = Array.from(selectedKeys)[0];\n        if (!selectedKey) {\n          return (\n            <Menu>\n              <Item>Nothing here</Item>\n            </Menu>\n          );\n        }\n        return (\n          <Menu>\n            <Item textValue={\\`Run '\\${selectedKey}'\\`}>\n              <MenuItemLayout\n                icon={<PlatformIcon icon=\"debugger/threadRunning.svg\" />}\n                content={\\`Run '\\${selectedKey}'\\`}\n                shortcut=\"⇧⏎\"\n              />\n            </Item>\n            <Item textValue={\\`Debug '\\${selectedKey}'\\`}>\n              <MenuItemLayout\n                icon={<PlatformIcon icon=\"actions/startDebugger.svg\" />}\n                content={\\`Debug '\\${selectedKey}'\\`}\n                shortcut=\"⌃⇧D\"\n              />\n            </Item>\n            <Item textValue={\\`Edit '\\${selectedKey}' Settings...\\`}>\n              <MenuItemLayout\n                icon={<PlatformIcon icon=\"actions/editSource.svg\" />}\n                content={\\`Edit '\\${selectedKey}' Settings...\\`}\n              />\n            </Item>\n            <Divider />\n            <Item textValue=\"Jump to source\">\n              <MenuItemLayout\n                icon={<PlatformIcon icon=\"actions/editSource.svg\" />}\n                content=\"Jump to source\"\n                shortcut=\"⌘↓\"\n              />\n            </Item>\n          </Menu>\n        );\n      }}\n    >\n      <List\n        selectionMode=\"single\"\n        selectedKeys={selectedKeys}\n        onSelectionChange={setSelectedKeys}\n      >\n        <Item key=\"start\">start</Item>\n        <Item key=\"build\">build</Item>\n        <Item key=\"test\">test</Item>\n        <Item key=\"deploy\">deploy</Item>\n      </List>\n    </ContextMenuContainer>\n  );\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"advanced-use\"\n    }}>{`Advanced use`}</h2>\n    <h3 {...{\n      \"id\": \"custom-list-component-with-uselist-and-usespeedsearchlist\"\n    }}>{`Custom list component with useList and useSpeedSearchList`}</h3>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n"],"names":["CollectionSpeedSearchContext","React","CollectionSpeedSearchItemContext","SpeedSearchItemHighlightsProvider","children","itemKey","context","useContext","Error","item","collection","getItem","text","textValue","undefined","props","console","warn","Provider","value","highlightedRanges","matches","get","HighlightedTextValue","Component","speedSearchContext","highlights","useCollectionSpeedSearchResult","selectionManager","inputSelectionManager","speedSearch","focusBestMatch","searchTerm","active","useMemo","Map","getKeys","map","key","filter","type","forEach","matchedRanges","minusculeMatch","set","wrappedSelectionManager","Object","create","selectAll","state","setSelectedKeys","Set","keys","disabledKeys","has","createSpeedSearchSelectionManager","latestValues","useLatest","useEffect","current","matchedKeys","noneOfTheMatchesAreSelected","some","matchedKey","isSelected","keyToFocus","entries","firstRange","from","sort","rangeA","rangeB","to","getLongestCommonPrefixMatch","length","passedFirstSelection","firstSelectedKey","includes","getMatchToSelect","setFocusedKey","replaceSelection","useCollectionSpeedSearch","stickySearch","keyboardDelegate","ref","speedSearchStateProps","useSpeedSearchState","speedSearchSelectionManager","containerProps","useSpeedSearch","speedSearchKeyboardDelegate","wrappedKeyboardDelegate","findFirstMatch","fromKey","direction","currentKey","getKeyAbove","getKeyBelow","getFirstKey","global","firstKey","values","next","getLastKey","lastKey","pop","createSpeedSearchKeyboardDelegate","speedSearchContextValue","searchPopupProps","match","size","DividerItem","seq","id","this","Divider","_Divider","getCollectionNode","element","rendered","hasChildNodes","Item","_Item","result","StatelyItem","originalShouldInvalidate","shouldInvalidate","invalidated","ItemStateContext","useCollectionAutoScroll","isVirtualized","focusedKey","querySelector","scrollIntoView","useCollectionRef","selectionManagerRef","useImperativeHandle","useCollectionSearchInput","collectionRef","relayEventsToCollection","useEventCallback","event","dispatchEvent","KeyboardEvent","nativeEvent","preventDefault","stopPropagation","collectionSearchInputProps","onKeyDown","onKeyUp","onKeyPress","LafIcon","forwardedRef","themePath","icon","resolvedIconPath","iconDescriptor","theme","useTheme","resolvedValue","modifiers","name","isUnderDarcula","modifier","Disabled","reduce","soFar","findIconPath","useIconPath","useForwardedRef","useSvgIcon","path","amendName","iconNameOrPath","amendment","ext","split","getPlatformIconPath","relativePath","startsWith","slice","PlatformIcon","darkIcon","iconName","dark","darkPath","getDarkPath","fallbackPath","DEFAULT_ICON_SIZE","StyledIconWrapper","styled","role","itemState","selected","isContainerFocused","unmounted","async","error","dataset","loadingIcon","svg","getSvgIcon","catch","e","remove","svgElement","document","createElement","appendChild","outerHTML","randomPostfix","Math","random","toFixed","matchAll","modifiedSvg","_","newId","replaceAll","makeIdsUnique","fetchIcon","theOld","theNew","str","replaced","replace","replacedAgain","List","allowEmptySelection","showAsFocused","fillAvailableSpace","onAction","inputProps","disallowEmptySelection","useObjectRef","useListState","listProps","focused","useList","listItemRenderer","listFocused","ListDivider","as","useSeparator","elementType","orientation","separatorProps","ListItem","isDisabled","itemProps","useSelectableItem","pressProps","usePress","preventFocusOnPress","containerFocused","disabled","node","StyledList","shouldForwardProp","prop","color","css","StyledListItem","backgroundColor","commonColors","labelForeground","asCurrentForeground","labelSelectedForeground","position","display","whiteSpace","paddingLeft","paddingRight","lineHeight","outline","cursor","minWidth","StyledListSectionHeader","fontWeight","renderItem","sectionHeader","renderSectionHeader","render","isSectionNode","childNodes","isDividerNode","onMouseDown","autoFocus","shouldFocusWrap","selectOnFocus","disallowTypeAhead","shouldUseVirtualFocus","allowsTabNavigation","collator","useCollator","usage","sensitivity","delegate","ListKeyboardDelegate","collectionProps","useSelectableCollection","useSelectableList","setFocused","useState","focusWithinProps","useFocusWithin","onFocusWithinChange","isEmpty","select","mergeProps","originalUseListState","selectionBehavior","ContextMenuContainer","renderMenu","useMenuTriggerState","overlayProps","overlayRef","useRef","positionProps","updatePosition","useMouseEventOverlayPosition","placement","shouldFlip","offset","isOpen","useOverlay","onClose","close","shouldCloseOnBlur","isKeyboardDismissDisabled","isDismissable","shouldCloseOnInteractOutside","areInNestedOverlays","onContextMenu","open","useContextMenu","allProps","MenuOverlay","restoreFocus","patchCollectionItem","nodes","partialNode","result2","partialChildNode","partialChildNodeWithoutType","PatchedItem","PatchedSection","Section","convertChildren","Array","isArray","Item2","MenuOverlayContext","MenuContext","useMenu","onActionProp","submenuBehavior","menuContextValue","menuProps","useMenuAria","useMenuState","patchCollectionProps","useTreeState","childExpansionBehaviour","expandedKeys","expandedKey","onExpandedChange","onExpandedKeyChange","defaultExpandedKeys","defaultExpandedKey","Menu","StyledMenu","style","renderMenuNodes","StyledMenuItemText","StyledMenuItemPlatformIcon","StyledMenuItemLafIcon","MenuItemContext","descriptionProps","labelProps","keyboardShortcutProps","useMenuItemLayout","MenuItem","nestedMenuRef","isExpanded","selectedKeys","isFocused","renderSubmenu","itemWrapper","i","menuItemProps","hasSubmenu","ariaMenuItemProps","useMenuItemAria","onMouseEnter","onPointerEnter","onPointerDown","hoverProps","useHover","onHoverStart","isAnySubmenuOpen","parentKey","toggleKey","isFocusVisible","keyboardProps","togglePressProps","onPressUp","useMenuItem","useOverlayPosition","targetRef","crossOffset","MENU_VERTICAL_PADDING","MENU_BORDER_WIDTH","arrowProps","onPointerUp","isActive","Selected","OverlayComponent","SimpleOverlay","parentState","rootKey","portalContainer","body","ReactDOM","StyledMenuItemLayout","Content","Shortcut","currentForegroundAware","MenuItemLayout","content","shortcut","useContextOrThrow","allowedIcon","forceRestoreFocus","WINDOW_SHADOW","StyledVerticalSeparator","StyledMenuItem","StyledMenuItemIcon","StyledNestedArrow","highlightedStyle","defaultStyle","disabledStyle","useSubmenu","rootItem","MenuKeyboardDelegate","submenuProps","useSubmenuAria","submenuBehaviorProps","setTimeout","focus","Submenu","useSubmenuState","constructor","super","flatMap","keyBelow","keyAbove","useKeyboard","contains","target","continuePropagation","root","isFocusedRef","focusedKeyRef","defineProperties","SelectionManager","StyledMenuHeading","StyledMenuSectionItemsContainer","MenuSection","headingProps","groupProps","useMenuSection","heading","hasDivider","ParentOverlayContext","Overlay","AriaOverlay","containerRef","element1","element2","overlayRoot1","closest","overlayRoot2","Boolean","StyledSearchIcon","SpeedSearchPopup","StyledSpeedSearchPopup","noMatch","red","tooltipForeground","useGhostInput","onChange","valueRef","ctrlKey","altKey","metaKey","HTMLElement","elem","isContentEditable","HTMLInputElement","HTMLTextAreaElement","sliceEnd","setActive","useControlledState","onActiveChange","setSearchTerm","defaultSearchTerm","onSearchTermChange","clear","ghostInputKeydown","trimmedValue","trimStart","onFocus","onBlur","DarculaSeparatorUI","defaultSize","StyledSeparator","backgroundClip","boxSizing","margin","border","flexShrink","StyledHorizontalSeparator","getAllRanges","ranges","push","index","gapRange","range","createRangesFromIndices","indices","lastRange","HighlightedMatch","TextWithHighlights","parts","highlighted","SpeedSearchTreeNode","TreeNode","SpeedSearchTree","treeRef","treeProps","treeContext","useSpeedSearchTree","virtualizerProps","useTreeVirtualizer","TreeContext","StyledTree","Virtualizer","collectionSpeedSearch","TreeKeyboardDelegate","speedSearchKeyboardProps","hasAnyModifier","selectableTree","useSelectableTree","getKeyLeftOf","getKeyRightOf","StyledTreeNodeIcon","TreeNodeIcon","expanded","iconPath","getIcon","useTreeNodeToggleButton","treeNodeToggleButtonProps","onPress","selectedDescendantKeys","toggleSelection","StyledTreeNode","attrs","level","onActionRef","treeNodeProps","onDoubleClick","useTreeNode","domProps","filterDOMProps","selectionKeyDown","isExpandable","onNodeKeyDown","shouldToggle","shiftKey","Symbol","iterator","TreeCollection","keyMap","iterable","last","visit","child","nextKey","prevKey","getKeyBefore","getKeyAfter","at","idx","getSingleChildrenKeys","getSingleChildrenKeysRecursive","previousKeys","childNodesIterator","firstChild","done","noMoreChildren","concat","isEmptyIterable","TreeSelectionManager","options","expandSelection","expandKeys","getExpandAndShrinkKeys","shrinkSelection","shrinkKeys","recursivelyGetExpandAndShrinkKeys","previousChild","parent","newKeys","parentDescendants","getAllDescendants","getAllRoots","every","descendants","stopKeys","flat","_TreeCollection","rootKeys","getAllExpandableKeys","rootNodes","notNull","recursivelyAddExpandableKeys","add","setExpandedKeys","selectionState","useMultipleSelectionState","cacheInvalidation","invalidators","lastInvalidators","usePrevious","anInvalidator","useCollectionCacheInvalidation","tree","useCollection","latestState","expandAll","collapseAll","useTreeRef","newExpandedKeys","toggleTreeNode","expandedSiblings","getRootItemKeys","getChildItems","siblings","getSiblings","aKey","childItems","sectionItems","res","delete","VariableWidthListLayout","ListLayout","keyToWidth","visibleContentWidth","buildItem","x","y","layoutNode","layoutInfo","rect","width","buildCollection","getVisibleContentWidth","invalidateEverything","contentSize","layoutNodes","newRect","oldRect","validate","invalidationContext","lastWidth","updateItemSize","changed","layoutInfos","max","virtualizer","visibleRect","visibleViews","view","itemContentWidth","intersects","getVisibleRect","FlattenedTreeLayout","buildChild","getVisibleLayoutInfos","layout","estimatedRowHeight","sizeToFit","scrollToItem","shouldScrollX","duration","scrollDirection","isWordSeparator","c","isWhitespace","char","test","isUpperCase","toUpperCase","toLowerCase","isMeaningfulChar","ch","input","rawPattern","isStarts","isStart","pattern","join","continuous","inputIndex","patternIndex","lastMatch","chars","previousChar","manager","disallowSelectAll","useLocale","focusSafely","tabIndex","handlers","navigateToKey","childFocus","selectionMode","extendSelection","isCtrlKeyPressed","getKeyPageBelow","getKeyPageAbove","clearSelection","walker","getFocusableTreeWalker","tabbable","lastChild","activeElement","currentTarget","relatedTarget","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","typeSelectProps","useTypeSelect","onTypeSelect","useOriginalSelectableItem","pointerType","styledComponents","ThemeConsumer","FocusScope","otherProps","directChildRef","focusManagerRef","useLayoutEffect","nodeToRestore","requestAnimationFrame","forceFocusFirst","focusManager","containerElement","parentElement","focusFirst","focusNext","GetFocusManager","hidden","useFocusManager","isMac","Context","nullErrorMessage","fn","useCallback","args","apply","innerRef","globalMoveHandler","lastMouseClientPos","clientX","clientY","addEventListener","fakeTarget","assign","height","pointerEvents","visibility","left","top","ExampleContext","themeName","themeJson","light","lightTheme","highContrast","highContrastTheme","darcula","darculaTheme","Theme","useFixDocusaurusStyleBleeds","Example","FLAG_CLASSNAME","classList","querySelectorAll","linkEl","sheet","cssRules","cssText","deleteRule","legends","title","items","Pane","flexDirection","marginTop","renderItemCustomUI","alignItems","itemRenderer","renderItemText","commonListStories","ListCmp","setIsFocused","listRef","Default","label","frontMatter","contentTitle","metadata","assets","toc","layoutProps","MDXContent","components","mdxType","parentName","isMDXComponent"],"sourceRoot":""}