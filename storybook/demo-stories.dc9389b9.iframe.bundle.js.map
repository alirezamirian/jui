{"version":3,"file":"demo-stories.dc9389b9.iframe.bundle.js","mappings":";;;;;;;;;;;AA0BA;;;;;;ACmNA;AASA;;;;;;;;;;;;;;;;;;;AClOA;;AAKA;;;;;;;AChBA;AAcA;;ACDA;;;;AAQA;;;;AAIA;;;;;AASA;;;;AAKA;;;;;;AAMA;AAMA;;;;ACtCA;;AAGA;;;;AAIA;;AAIA;;;;ACLA;;;;AAMA;;;;;AASA;;;;;ACpCA;;AAGA;;AAGA;AACA;;;;;;;;;;;;;;;;ACoCA;;;;ACDA;;;;;AAOA;;;;;AAOA;;;AAKA;;;AAKA;;;AC/CA;;;;;AAOA;;AAGA;AACA;AAGA;;;;;AAMA;;AAIA;;;;;;AAQA;;;AAwEA;;;;AC1EA;;;;;;;ACvCA;AACA;;;;;;;AAOA;;;AAGA;;AAKA;;;AAKA;AACA;;;;AAMA;;;AAGA;;;AAIA;;ACzCA;;;;;;;;AC6BA;;;AAKA;AACA;;AAAA;;;;;;;;;;AAeA;AAGA;;;;AAMA;;;;;AAMA;;;;AC/CA;;;;AAIA;;;;;AAOA;;;;;ACUA;;;;AAMA;;;;ACzBA;;;;;AAMA;;;;;;AAQA;;ACQA;;;;;;AAQA;;;;;;;;;AAoCA;AACA;;AAEA;;;AAGA;;AAOA;AACA;AAEA;;;;AAMA;;ACnGA;;AAIA;;;;;;ACqBA;;;;;;AAQA;;;;;;ACDA;AACA;;;AAKA;;;AAKA;;;;;ACvDA;;;;AAKA;AACA;;;ACSA;;;ACkBA;;AAGA;AAEA;;AAEA;AAEA;AAEA;AAEA;;;;;AAMA;;;AAIA;;;;;;;;;;;;;;AAcA;AACA;;;AAIA;;;;AAKA;;;;;AAKA;AAEA;AACA;;AAKA;AACA;;;AAQA;AACA;;;;;AAQA;;;;;;;;;;;ACxCA;AACA;AAGA;;;;;;ACxDA;;;;AAMA;;;;;ACWA;AC8BA;;;;AAMA;;;;;;;AASA;;;;;AAOA;;AAIA;;;;;;AAQA;;;;AAMA;;;;AAMA;;AAIA;;AAYA;;;;ACzGA;;;AAGA;AACA;;AAEA;;AASA;;;;;AAUA;;;;;;;;AC5BA;;;;;;;AClBA;AAGA;;;AASA;;ACbA;;;AAQA;;;;;;;;;;AC8EA","sources":["webpack://@intellij-platform/core/../example-app/src/Editor/Editor.tsx","webpack://@intellij-platform/core/../example-app/src/Editor/FileEditor.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/StyledRepoColorSquare.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/StyledCurrentBranchTag.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/ChangesView/CommitView.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/ChangesView/CommitActionsRow.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/ChangesView/ChangesViewSplitter.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/styled-components.ts","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/CommitChanges/CommitsChangedFiles.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/RefLabel.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/DetailsView/CommitDetails.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/DetailsView/VcsLogDetailsView.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/CommitsView/VcsLogDropdown.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Branches/BranchFavoriteButton.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/CommitsView/CommitsTableRow.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/CommitsView/CommitsTable.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/CommitsView/VcsLogCommitsView.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/BranchesView/BranchesTree.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/VersionControlToolWindow/VersionControlToolWindow.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Branches/RenameBranchWindow.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Branches/BranchesPopup.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Changes/Rollback/RollbackWindow.tsx","webpack://@intellij-platform/core/../example-app/src/SearchEverywhere/contributors/ItemHelpers.tsx","webpack://@intellij-platform/core/../example-app/src/SearchEverywhere/contributors/action/ActionItem.tsx","webpack://@intellij-platform/core/../example-app/src/SearchEverywhere/SearchEverywherePopup.tsx","webpack://@intellij-platform/core/../example-app/src/Project/actions/createFileAction.tsx","webpack://@intellij-platform/core/../example-app/src/VersionControl/Branches/CreateNewBranchWindow.tsx","webpack://@intellij-platform/core/../example-app/src/Project/Project.tsx","webpack://@intellij-platform/core/./src/AlertDialog/AlertDialog.tsx","webpack://@intellij-platform/core/./src/ModalWindow/ModalWindow.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowHeader.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowFooter.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowLayout.tsx","webpack://@intellij-platform/core/./src/SearchInput/SearchInput.tsx"],"sourcesContent":["import MonacoEditor, { EditorProps } from \"@monaco-editor/react\";\nimport { styled } from \"@intellij-platform/core\";\nimport React from \"react\";\nimport { useEditorTheme } from \"./useEditorTheme\";\n\nexport const StyledEditor = styled(MonacoEditor)`\n  .monaco-editor {\n    .margin-view-overlays .line-numbers {\n      text-align: left;\n      padding-left: 7px;\n    }\n\n    .scrollbar .slider {\n      border-radius: 0.25rem;\n    }\n  }\n`;\n/**\n * Monaco Editor styled to look like Intellij Platform's editor.\n * TODO:\n *  - folding controls appearance is different and should be changed\n *  - highlighting pairs of parens, brackets, etc. is different.\n *  - context menu look different.\n *  - selection look different.\n *  - BUG: height is more than necessary. Needs investigation first.\n */\nexport const Editor = (props: Omit<EditorProps, \"theme\">) => {\n  const editorTheme = useEditorTheme();\n  const fontSize = 13;\n  return (\n    <StyledEditor\n      {...props}\n      options={{\n        minimap: { enabled: false },\n        lineHeight: 22,\n        showFoldingControls: \"always\",\n        renderIndentGuides: true,\n        overviewRulerBorder: false,\n        fontFamily: \"JetBrains Mono\",\n        fontSize,\n        scrollbar: {\n          verticalScrollbarSize: 14,\n          horizontalScrollbarSize: 8,\n          verticalSliderSize: 8,\n          horizontalSliderSize: 8,\n          horizontal: \"auto\",\n          vertical: \"visible\",\n          alwaysConsumeMouseWheel: false, // to let example-app be rendered as a part of a page.\n        },\n        ...props.options,\n      }}\n      theme={editorTheme as any} // FIXME\n    />\n  );\n};\n","import { Monaco } from \"@monaco-editor/react\";\nimport {\n  ActionTooltip,\n  ContextMenuContainer,\n  EditorTabContent,\n  EditorTabs,\n  HIDE_ALL_WINDOWS_ACTION_ID,\n  Item,\n  Menu,\n  MenuItemLayout,\n  PlatformIcon,\n  styled,\n  TabCloseButton,\n  TabItem,\n  TooltipTrigger,\n  useAction,\n  useLatest,\n} from \"@intellij-platform/core\";\nimport { editor, languages } from \"monaco-editor\";\nimport React, { useRef, useState } from \"react\";\nimport { selector, useSetRecoilState } from \"recoil\";\nimport { getIconForFile } from \"../file-utils\";\nimport { LoadingGif } from \"../LoadingGif\";\nimport { Editor } from \"./Editor\";\nimport {\n  activeEditorTabState,\n  editorCursorPositionState,\n  editorRefState,\n  useEditorState,\n} from \"./editor.state\";\nimport { fileContentState } from \"../fs/fs.state\";\nimport { useRefreshFileStatus } from \"../VersionControl/file-status.state\";\nimport * as path from \"path\";\nimport { FileStatusColor } from \"../VersionControl/FileStatusColor\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { useActivePathsProvider } from \"../Project/project.state\";\nimport { notImplemented } from \"../Project/notImplemented\";\nimport { useExistingLatestRecoilValue } from \"../recoil-utils\";\n\nconst editorFullState = selector({\n  key: \"editorState\",\n  get: ({ get }) => {\n    const activeEditorTab = get(activeEditorTabState);\n    return {\n      ...activeEditorTab,\n      content: get(fileContentState(activeEditorTab?.filePath)),\n    };\n  },\n});\n/**\n * Used as main content in the main ToolWindows. Shows currently opened files tabs and the editor.\n *\n * TODO: preserve editor state when switching between tabs\n * TODO: support multiple editors in split view.\n */\nexport const FileEditor = () => {\n  const [editorTabs, editorStateManager] = useEditorState();\n  const editorRef = useRef<editor.ICodeEditor>();\n  const [active, setActive] = useState(false);\n  const hideAllAction = useAction(HIDE_ALL_WINDOWS_ACTION_ID);\n  const setCursorPositionState = useSetRecoilState(editorCursorPositionState);\n\n  const [{ content, editorState, filePath }, loadingState] =\n    useExistingLatestRecoilValue(editorFullState);\n\n  // For functions that are needed in tab action callbacks. Because items are cached and referencing anything\n  // other than the collection item (tab) itself has a risk of working with stale data because of the caching\n  // More info: https://react-spectrum.adobe.com/react-stately/collections.html#why-not-array-map\n  // We can alternatively switch to mapping over tabs array, instead of using the Collection's dynamic api (items)\n  // which is subject to this caching.\n  const tabActionsRef = useLatest({\n    closePath: editorStateManager.closePath,\n    closeOthersTabs: editorStateManager.closeOtherTabs,\n  });\n\n  const setEditorRef = useSetRecoilState(editorRefState);\n\n  const setContent = useSetRecoilState(fileContentState(filePath));\n  const updateFileStatus = useRefreshFileStatus();\n\n  const updateContent = (newContent: string = \"\") => {\n    setActive(false);\n    setContent(newContent);\n    if (filePath) {\n      updateFileStatus(filePath).catch((e) => {\n        console.error(\"Could not update file status\", e);\n      });\n    }\n  };\n\n  // For now, when the first tab content is changed, we focus the editor.\n  // FIXME when action system is implemented and there is an action like \"open project file\".\n  // Note that it's event currently buggy\n\n  const activePathsProviderProps = useActivePathsProvider(\n    filePath ? [filePath] : []\n  );\n\n  return (\n    <StyledFileEditorContainer\n      {...mergeProps(activePathsProviderProps, {\n        onFocus: () => {\n          setActive(true);\n          setEditorRef({\n            focus: () => editorRef.current?.focus(),\n          });\n        },\n      })}\n    >\n      {editorTabs.length > 0 && (\n        <ContextMenuContainer\n          renderMenu={() => (\n            <Menu\n              // TODO: detect which tab was triggering context menu and handle the action accordingly\n              //  One idea is to use use the data-key attribute, from the closes parent that has one. Maybe a\n              //  CollectionContextMenuContainer component which implements that, while ContextMenuContainer is\n              //  modified to pass the MouseEvent object, in renderMenu.\n              onAction={notImplemented}\n            >\n              <Item key=\"close\">Close</Item>\n              <Item key=\"closeOthers\">Close Other tabs</Item>\n              <Item key=\"closeAll\">Close all tabs</Item>\n              <Item key=\"closeLeft\">Close tabs to the left</Item>\n              <Item key=\"closeRight\">Close tabs to the right</Item>\n            </Menu>\n          )}\n        >\n          <EditorTabs\n            items={editorTabs}\n            active={active}\n            selectedKey={filePath}\n            onSelectionChange={(key) => {\n              editorStateManager.select(\n                editorTabs.findIndex((tab) => tab.filePath === key)\n              );\n            }}\n            noBorders\n          >\n            {(tab) => {\n              const filename = path.basename(tab.filePath);\n              const icon = <PlatformIcon icon={getIconForFile(tab.filePath)} />;\n              return (\n                <TabItem\n                  key={tab.filePath}\n                  textValue={filename}\n                  inOverflowMenu={\n                    <MenuItemLayout content={filename} icon={icon} />\n                  }\n                >\n                  <TooltipTrigger\n                    tooltip={<ActionTooltip actionName={tab.filePath} />}\n                  >\n                    <EditorTabContent\n                      icon={icon}\n                      title={\n                        <FileStatusColor filepath={tab.filePath}>\n                          {filename}\n                        </FileStatusColor>\n                      }\n                      closeButton={\n                        <TooltipTrigger\n                          tooltip={\n                            <ActionTooltip actionName=\"Close. Alt-Click to Close Others\" />\n                          }\n                        >\n                          <TabCloseButton\n                            onPress={(e) => {\n                              if (e.altKey) {\n                                tabActionsRef.current.closeOthersTabs(\n                                  editorTabs.indexOf(tab)\n                                );\n                              } else {\n                                tabActionsRef.current.closePath(tab.filePath);\n                              }\n                            }}\n                          />\n                        </TooltipTrigger>\n                      }\n                      containerProps={{\n                        onDoubleClick: () => {\n                          hideAllAction?.perform();\n                        },\n                      }}\n                    />\n                  </TooltipTrigger>\n                </TabItem>\n              );\n            }}\n          </EditorTabs>\n        </ContextMenuContainer>\n      )}\n      {typeof content === \"string\" ? (\n        /**\n         * ## Note\n         * TLDR: Keeping the editor mounted when filePath changes is intentional and does matter.\n         *\n         * Whether the editor component is kept mounted as tabs change or not has nuances that can lead to minor\n         * focus issues. For example calling editorStateManager.focus() may do nothing if the editor is unmounted due\n         * to filePath being changed. focusing editor in createFile action is an example of such case. It also affects\n         * certain focus management code within the FileEditor. For example, focusing the editor on tab changes will\n         * be necessary if the editor remounts with each file change. Or autofocus behavior of the editor can be\n         * done on the onMount callback of the Editor component, if it's only mounted once. But the same code leads\n         * to focus issues if the editor is mounted on active tab changes, when they are not done via the tab UI,\n         * but as a side effect of another action like opening a file via Project tool window.\n         *\n         */\n        <Editor\n          height=\"100%\"\n          path={filePath}\n          onMount={(monacoEditor, monaco) => {\n            monacoEditor.focus();\n            enableJsx(monaco);\n            editorRef.current = monacoEditor;\n            monacoEditor.onDidChangeCursorPosition((e) => {\n              setCursorPositionState(e.position);\n            });\n            monacoEditor.onDidChangeModel(() => {\n              // TODO: set the editor tab state, and add an atom effect to persist whole editor state across loads\n            });\n          }}\n          onChange={updateContent}\n          value={content ?? \"\"}\n        />\n      ) : (\n        content && \"UNSUPPORTED CONTENT\"\n      )}\n      {loadingState === \"loading\" && <FileEditorLoading />}\n    </StyledFileEditorContainer>\n  );\n};\n\nconst StyledFileEditorContainer = styled.div`\n  position: relative;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  background: ${({ theme }) =>\n    theme.color(\n      \"Editor.background\",\n      theme.isUnderDarcula()\n        ? \"rgb(40,40,40)\"\n        : theme.commonColors.panelBackground // FIXME: ColorUtil.darker(theme.commonColors.panelBackground, 3)\n    )};\n`;\n\nconst FileEditorLoading = styled(LoadingGif)`\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n`;\n\nfunction enableJsx(monaco: Monaco) {\n  monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n    jsx: languages.typescript.JsxEmit.React,\n  });\n\n  monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n    noSemanticValidation: false,\n    noSyntaxValidation: false,\n  });\n}\n","import { styled, Theme } from \"@intellij-platform/core\";\nimport React, { ForwardedRef, HTMLAttributes } from \"react\";\nimport { useRecoilValue } from \"recoil\";\nimport { vcsRootsState } from \"../file-status.state\";\nimport { useTheme } from \"styled-components\";\n\nconst StyledRepoColorSquare = styled.span`\n  width: 14px;\n  height: 14px;\n  align-self: center;\n  margin-right: 0.2rem;\n  position: relative;\n\n  //  after pseudo element is used to create the color mixing implemented here:\n  //  https://github.com/JetBrains/intellij-community/blob/82f201386c3f7a339ff25fc8f3389024c8078a87/platform/vcs-log/impl/src/com/intellij/vcs/log/ui/VcsLogColorManagerImpl.java#L60\n  &&:after {\n    content: \"\";\n    position: absolute;\n    inset: 0;\n    opacity: 0.75;\n    background: ${({ theme }) =>\n      theme.color(\"Table.background\") || (theme.dark ? \"#3C3F41\" : \"#fff\")};\n  }\n`;\n\nconst useRepoRootColor = (rootPath: string) => {\n  const index = useRecoilValue(vcsRootsState).findIndex(\n    (root) => root.dir === rootPath\n  );\n  const theme = useTheme() as Theme;\n  const colors = [theme.commonColors.red, theme.commonColors.blue];\n  return colors[index % colors.length] ?? colors[0];\n};\n\nexport const RepoColorIcon = React.forwardRef(\n  (\n    {\n      rootPath,\n      ...props\n    }: {\n      rootPath: string;\n    } & HTMLAttributes<HTMLSpanElement>,\n    ref: ForwardedRef<HTMLElement>\n  ) => (\n    <StyledRepoColorSquare\n      ref={ref}\n      {...props}\n      style={{ ...props.style, backgroundColor: useRepoRootColor(rootPath) }}\n    />\n  )\n);\n","import { styled } from \"@intellij-platform/core\";\n\nexport const StyledCurrentBranchTag = styled.span`\n  display: inline-flex;\n  align-self: center;\n  height: 1.1rem;\n  line-height: 1.1rem;\n  padding: 0 0.25rem;\n\n  background: ${({ theme }) =>\n    theme.currentBackgroundAware(\n      // FIXME: color-mix algorithm used here seems to be different from how colors are mixed in the reference impl.\n      `color-mix(in srgb, ${theme.color(\n        \"VersionControl.Log.Commit.currentBranchBackground\",\n        theme.dark ? \"rgb(63, 71, 73)\" : \"rgb(228, 250, 255)\"\n      )}, ${theme.color(\n        \"VersionControl.RefLabel.backgroundBase\",\n        theme.dark ? \"#fff\" : \"#000\"\n      )} ${\n        (theme.value<number>(\"VersionControl.RefLabel.backgroundBrightness\") ??\n          0.08) * 100\n      }%)`\n    )};\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(\n      theme.color(\n        \"VersionControl.RefLabel.foreground\",\n        theme.dark ? \"#909090\" : \"#7a7a7a\"\n      )\n    )};\n`;\n","import { IntlMessageFormat } from \"intl-messageformat\";\nimport React, { useEffect, useImperativeHandle, useRef } from \"react\";\nimport { useRecoilCallback, useRecoilState, useRecoilValue } from \"recoil\";\nimport {\n  Button,\n  PlatformIcon,\n  styled,\n  useBalloonManager,\n  useDefaultToolWindowContext,\n} from \"@intellij-platform/core\";\n\nimport { notImplemented } from \"../../../Project/notImplemented\";\nimport {\n  amendCommitState,\n  commitErrorMessageState,\n  commitMessageState,\n  commitTaskIdState,\n  includedChangesState,\n} from \"./ChangesView.state\";\nimport { useCommitChanges } from \"./useCommitChanges\";\n\nconst StyledCommitMessageContainer = styled.div`\n  background: ${({ theme }) =>\n    theme.dark\n      ? \"#2b2b2b\" /*FIXME: should come from color scheme. attributes.TEXT.BACKGROUND*/\n      : \"#fff\"};\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n`;\nconst StyledCommitMessageTextArea = styled.textarea`\n  flex: 1;\n  background: none;\n  padding: 0.25rem 0.375rem;\n  color: ${({ theme }) =>\n    theme.dark\n      ? \"#a9b7c6\" /*FIXME: should come from color scheme. attributes.TEXT.BACKGROUND*/\n      : \"#000\"};\n  font-family: inherit;\n  border: none;\n  resize: none;\n  outline: none;\n`;\nconst StyledCommitActionsRow = styled.div`\n  display: flex;\n  gap: 0.3rem;\n  padding: 0.4rem;\n`;\nconst StyledErrorMessage = styled.div`\n  display: flex;\n  align-items: center;\n  padding: 0.125rem 0.5rem;\n  gap: 0.25rem;\n  position: sticky; // prevents commit message scroll jump when message is toggled on and off\n  color: ${({ theme }) => theme.commonColors.red};\n`;\n\n/**\n * Commit message and commit buttons shown in the bottom/right split view of the commit toolwindow\n */\nexport function CommitView({\n  editorRef,\n}: {\n  editorRef: React.RefObject<{ focus: () => void }>;\n}) {\n  const commitMessageTextAreaRef = useRef<HTMLTextAreaElement>(null);\n  const [commitMessage, setCommitMessage] = useRecoilState(commitMessageState);\n  const commit = useCommitChanges();\n  const balloonManager = useBalloonManager();\n  const [errorMessage, setErrorMessage] = useRecoilState(\n    commitErrorMessageState\n  );\n  const commitTaskId = useRecoilValue(commitTaskIdState);\n\n  useEffect(() => {\n    if (commitMessage) {\n      setErrorMessage(\"\");\n    }\n  }, [commitMessage]);\n\n  const commitSelectedChanges = useRecoilCallback(({ snapshot }) => {\n    const includedChanges = snapshot\n      .getLoadable(includedChangesState)\n      .getValue();\n    const commitMessage = snapshot.getLoadable(commitMessageState).getValue();\n    return () => {\n      if (includedChanges.length === 0) {\n        setErrorMessage(\"Select files to commit\");\n        return;\n      }\n      if (!commitMessage) {\n        setErrorMessage(\"Specify commit message\");\n        return;\n      }\n      if (snapshot.getLoadable(amendCommitState).getValue()) {\n        balloonManager.show({\n          icon: \"Error\",\n          title: \"Unsupported action\",\n          body: \"Amending commits is not yet supported.\",\n        });\n        return;\n      }\n      commit(includedChanges, commitMessage);\n      // TODO: clear message and add an entry in commit message history\n    };\n  }, []);\n\n  const { hasFocus } = useDefaultToolWindowContext();\n\n  useImperativeHandle(\n    editorRef,\n    () => ({\n      focus: () => {\n        commitMessageTextAreaRef.current?.focus();\n      },\n    }),\n    []\n  );\n\n  return (\n    <StyledCommitMessageContainer>\n      <StyledCommitMessageTextArea\n        ref={commitMessageTextAreaRef}\n        value={commitMessage}\n        onChange={(event) => {\n          setCommitMessage(event.target.value);\n        }}\n        placeholder=\"Commit Message\"\n        data-gramm=\"false\"\n      />\n      {errorMessage && (\n        <StyledErrorMessage>\n          <PlatformIcon icon=\"general/error.svg\" /> {errorMessage}\n        </StyledErrorMessage>\n      )}\n      <StyledCommitActionsRow>\n        <Button\n          preventFocusOnPress\n          variant={hasFocus ? \"default\" : undefined}\n          onPress={commitSelectedChanges}\n          isDisabled={commitTaskId != null}\n        >\n          Commit\n        </Button>\n        <Button preventFocusOnPress onPress={notImplemented}>\n          Commit and Push...\n        </Button>\n      </StyledCommitActionsRow>\n    </StyledCommitMessageContainer>\n  );\n}\n","import React from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport {\n  IconButton,\n  ActionHelpTooltip,\n  ActionTooltip,\n  Checkbox,\n  PlatformIcon,\n  styled,\n  TooltipTrigger,\n  UnknownThemeProp,\n} from \"@intellij-platform/core\";\n\nimport { ChangesSummary } from \"../ChangesSummary\";\nimport { notImplemented } from \"../../../Project/notImplemented\";\nimport { amendCommitState, includedChangesState } from \"./ChangesView.state\";\n\nconst StyledActionsRow = styled.div`\n  display: flex;\n  padding: 0.125rem;\n  position: relative;\n`;\nconst StyledAmendCheckbox = styled(Checkbox)`\n  padding-right: 0.625rem;\n`;\nconst StyledChangesSummaryContainer = styled.span`\n  position: absolute;\n  right: 0.5rem;\n  top: 0.25rem;\n  background: ${({ theme }) =>\n    theme.color(\"Panel.background\" as UnknownThemeProp<\"Panel.background\">)};\n  z-index: 1;\n`;\nconst ChangesViewChangesSummary = () => {\n  const changes = useRecoilValue(includedChangesState);\n  return <ChangesSummary changes={changes} />;\n};\n\n/**\n * Amend checkbox, commit message history button, and summary of included changes, shown as a row\n * bellow changes tree, in commit tool window.\n */\nexport function CommitActionsRow() {\n  const [amend, setAmend] = useRecoilState(amendCommitState);\n\n  return (\n    <StyledActionsRow>\n      <TooltipTrigger\n        tooltip={\n          <ActionHelpTooltip\n            actionName=\"Amend Commit\"\n            helpText=\"Modify the latest commit of the current branch\"\n          />\n        }\n      >\n        {(props) => (\n          <span {...props}>\n            <StyledAmendCheckbox\n              isSelected={amend}\n              onChange={setAmend}\n              preventFocus\n            >\n              Amend\n            </StyledAmendCheckbox>\n          </span>\n        )}\n      </TooltipTrigger>\n      <TooltipTrigger\n        tooltip={<ActionTooltip actionName=\"Show Commit Options\" />}\n      >\n        <IconButton onPress={notImplemented}>\n          <PlatformIcon icon=\"general/gear.svg\" />\n        </IconButton>\n      </TooltipTrigger>\n      <TooltipTrigger\n        tooltip={<ActionTooltip actionName=\"Commit Message History\" />}\n      >\n        <IconButton isDisabled onPress={notImplemented}>\n          <PlatformIcon icon=\"vcs/historyInline.svg\" />\n        </IconButton>\n      </TooltipTrigger>\n      <StyledChangesSummaryContainer>\n        <ChangesViewChangesSummary />\n      </StyledChangesSummaryContainer>\n    </StyledActionsRow>\n  );\n}\n","import React, { useRef } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport {\n  ActionsProvider,\n  getAnchorOrientation,\n  styled,\n  ThreeViewSplitter,\n  TreeRefValue,\n  useToolWindowState,\n  useTreeActions,\n} from \"@intellij-platform/core\";\n\nimport { repoStatusUpdatingState } from \"../../file-status.state\";\nimport { LoadingGif } from \"../../../LoadingGif\";\nimport { Delayed } from \"../../../Delayed\";\nimport { commitMessageSizeState } from \"./ChangesView.state\";\nimport { ChangeViewTree } from \"./ChangeViewTree\";\nimport { ChangesViewToolbar } from \"./ChangesViewToolbar\";\nimport { CommitView } from \"./CommitView\";\nimport { CommitActionsRow } from \"./CommitActionsRow\";\nimport { useChangesViewActions } from \"./useChangesViewActions\";\n\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n`;\n\nconst StyledTreeViewWrapper = styled.div`\n  flex: 1;\n  overflow: auto;\n  position: relative;\n`;\n\nconst StyledLoadingWrapper = styled.div`\n  position: absolute;\n  right: 0.125rem;\n  top: 0.125rem;\n  z-index: 1;\n`;\n\n// Not so ideal solution for allowing imperatively focusing commit message. Should be ok, since there will\n// be at most only one instance of change view rendered.\nlet editor: { focus: () => void } | null = null;\n\nexport let focusCommitMessage = () => {\n  setTimeout(() => {\n    editor?.focus();\n  });\n};\n\nexport const ChangesViewSplitter = () => {\n  const {\n    state: { anchor },\n  } = useToolWindowState();\n  const treeRef = useRef<TreeRefValue>(null);\n  const editorRef = useRef<{ focus: () => void }>(null);\n  const orientation = getAnchorOrientation(anchor);\n  const updating = useRecoilValue(repoStatusUpdatingState);\n  const [commitMessageSize, setCommitMessageSize] = useRecoilState(\n    commitMessageSizeState(orientation)\n  );\n  const changesViewActions = useChangesViewActions();\n  const treeActions = useTreeActions({ treeRef });\n  // TODO(lib-candidate): ToolWindowAwareSplitter. A wrapper around ThreeViewSplitter which sets orientation based\n  //  on anchor orientation from useToolWindowState.\n  editor = editorRef.current;\n\n  return (\n    <ThreeViewSplitter\n      orientation={orientation}\n      innerView={\n        <ActionsProvider actions={[...treeActions, ...changesViewActions]}>\n          {({ shortcutHandlerProps }) => (\n            <StyledContainer {...shortcutHandlerProps}>\n              <ChangesViewToolbar />\n              <StyledTreeViewWrapper>\n                {updating && (\n                  <Delayed>\n                    <StyledLoadingWrapper>\n                      <LoadingGif />\n                    </StyledLoadingWrapper>\n                  </Delayed>\n                )}\n                <ChangeViewTree treeRef={treeRef} />\n              </StyledTreeViewWrapper>\n              <CommitActionsRow />\n            </StyledContainer>\n          )}\n        </ActionsProvider>\n      }\n      innerViewMinSize={50}\n      lastView={<CommitView editorRef={editorRef} />}\n      lastSize={commitMessageSize}\n      onLastResize={setCommitMessageSize}\n    />\n  );\n};\n","import { styled } from \"@intellij-platform/core\";\n\nexport const StyledHeader = styled.div`\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  height: 2.0625rem;\n  border-bottom: 1px solid ${({ theme }) => theme.commonColors.borderColor};\n  flex-shrink: 0;\n`;\nexport const StyledSpacer = styled.div`\n  flex-grow: 1;\n`;\nexport const StyledPlaceholderContainer = styled.div`\n  color: ${({ theme }) => theme.commonColors.inactiveTextColor};\n  display: flex;\n  flex-direction: column;\n  justify-content: end;\n  align-items: center;\n  gap: 0.25rem;\n  min-height: 37%;\n  overflow: hidden;\n`;\n","import React, { HTMLAttributes, useEffect } from \"react\";\nimport {\n  RecoilValue,\n  useRecoilState,\n  useRecoilValue,\n  useRecoilValueLoadable,\n} from \"recoil\";\n\nimport {\n  HelpTooltip,\n  PlatformIcon,\n  PositionedTooltipTrigger,\n  SpeedSearchTree,\n  styled,\n} from \"@intellij-platform/core\";\n\nimport { useLatestRecoilValue } from \"../../../recoil-utils\";\nimport { LoadingGif } from \"../../../LoadingGif\";\nimport { Delayed } from \"../../../Delayed\";\nimport { StyledPlaceholderContainer } from \"../styled-components\";\nimport { selectedCommitsState } from \"../CommitsView/CommitsTable.state\";\nimport {\n  changedFilesState,\n  changedFilesWithoutRenamesState,\n  commitChangesTreeRefState,\n  expandedKeysState,\n  selectionState,\n} from \"./CommitsChangedFiles.state\";\nimport { commitChangesTreeNodeRenderer } from \"./commitChangesTreeNodeRenderer\";\n\nconst StyledLoadingWrapper = styled.div`\n  position: absolute;\n  inset: 0;\n  gap: 0.5rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n`;\n\nfunction useFastestValueLoadable<T>(states: RecoilValue<T>[]) {\n  const loadables = states.map((state) => useRecoilValueLoadable(state));\n  return (\n    loadables.find(({ state }) => state === \"hasValue\") ||\n    loadables.slice(-1)[0]\n  );\n}\n/**\n * TODO: handle multiple selected commits (check Changes.ShowChangesFromParents https://github.com/JetBrains/intellij-community/blob/ac57611a0612bd65ba2a19c841a4f95b40591134/platform/vcs-log/impl/src/com/intellij/vcs/log/ui/frame/VcsLogChangesBrowser.java#L255-L254)\n */\nexport function CommitChangedFiles({\n  treeShortcutHandlerProps,\n}: {\n  treeShortcutHandlerProps: HTMLAttributes<HTMLElement>;\n}) {\n  const [selectedCommits] = useLatestRecoilValue(selectedCommitsState);\n  const treeRef = useRecoilValue(commitChangesTreeRefState);\n  const nothingSelected = !selectedCommits?.length;\n\n  const stateLoadable = useFastestValueLoadable([\n    changedFilesState,\n    changedFilesWithoutRenamesState,\n  ]);\n  const state = stateLoadable.valueMaybe();\n  const [expandedKeys, setExpandedKeys] = useRecoilState(expandedKeysState);\n  const [selection, setSelection] = useRecoilState(selectionState);\n\n  useEffect(() => {\n    // TODO: expanded keys are supposed to be set based on selected keys\n    setExpandedKeys(state?.expandAllKeys ?? new Set());\n    setSelection(new Set());\n    // FIXME: with this being in an effect here, closing and reopening the toolwindow will\n    //  reset the selection, making selection state be effectively like a local state.\n  }, [stateLoadable.state]);\n\n  if (nothingSelected) {\n    return (\n      <StyledPlaceholderContainer>\n        Select commits to to view changes\n      </StyledPlaceholderContainer>\n    );\n  }\n  return (\n    <div\n      {...treeShortcutHandlerProps}\n      style={{\n        height: \"-webkit-fill-available\",\n        position: \"relative\",\n      }}\n    >\n      {stateLoadable.state === \"loading\" && (\n        <Delayed>\n          <StyledLoadingWrapper>\n            <LoadingGif style={{ width: \"1.5rem\" }} />\n            Loading...\n          </StyledLoadingWrapper>\n        </Delayed>\n      )}\n      {state && (\n        <SpeedSearchTree\n          treeRef={treeRef}\n          items={state.rootNodes}\n          selectionMode=\"multiple\"\n          expandedKeys={expandedKeys}\n          onExpandedChange={setExpandedKeys}\n          selectedKeys={selection}\n          onSelectionChange={setSelection}\n          style={{ paddingBottom: \"1rem\" }}\n          fillAvailableSpace\n        >\n          {commitChangesTreeNodeRenderer.itemRenderer({\n            fileCountsMap: state.fileCountsMap,\n          })}\n        </SpeedSearchTree>\n      )}\n      {selectedCommits.length > 1 && (\n        <PositionedTooltipTrigger\n          placement=\"top\"\n          tooltip={\n            <HelpTooltip\n              helpText={\n                <>\n                  Showing diff for more than one commit is not currently\n                  supported. Only the first selected commit is taken into\n                  account.\n                </>\n              }\n            ></HelpTooltip>\n          }\n        >\n          {(props) => (\n            <span\n              {...props}\n              style={{\n                position: \"absolute\",\n                right: \"0.5rem\",\n                bottom: \"0.5rem\",\n              }}\n            >\n              <PlatformIcon icon=\"general/warning\" />\n            </span>\n          )}\n        </PositionedTooltipTrigger>\n      )}\n    </div>\n  );\n}\n","import { styled, Theme } from \"@intellij-platform/core\";\nimport React from \"react\";\n\nimport { StyledCurrentBranchTag } from \"../Changes/StyledCurrentBranchTag\";\nimport { GitRef } from \"./GitRef\";\n\nconst labelIcon = (\n  <path\n    fill=\"currentColor\"\n    d=\"M4.2 4.8 C4.8627 4.8 5.4 5.3373 5.4 6 C5.4 6.6627 4.8627 7.2 4.2 7.2 C3.5373 7.2 3 6.6627 3 6 C3 5.3373 3.5373 4.8 4.2 4.8 ZM0.6 2.4 L0.6 7.2 L7.8 14.4 L12.6 9.6 L5.4 2.4 Z\"\n  />\n);\nconst vcsLogStandardColors = {\n  TIP: { light: \"#ffd100\", dark: \"#e1c731\" },\n  LEAF: { light: \"#8a2d6b\", dark: \"#c31e8c\" },\n  BRANCH: { light: \"#3cb45c\", dark: \"#3cb45c\" },\n  BRANCH_REF: { light: \"#9f79b5\", dark: \"#9f79b5\" },\n  TAG: { light: \"#7a7a7a\", dark: \"#999999\" },\n};\nconst gitLogColors: Record<GitRef[\"type\"], (args: { theme: Theme }) => string> =\n  {\n    head: ({ theme }: { theme: Theme }) =>\n      theme.color(\n        \"VersionControl.GitLog.headIconColor\",\n        vcsLogStandardColors.TIP\n      ),\n    localBranch: ({ theme }: { theme: Theme }) =>\n      theme.color(\n        \"VersionControl.GitLog.localBranchIconColor\",\n        vcsLogStandardColors.BRANCH\n      ),\n    remoteBranch: ({ theme }: { theme: Theme }) =>\n      theme.color(\n        \"VersionControl.GitLog.remoteBranchIconColor\",\n        vcsLogStandardColors.BRANCH_REF\n      ),\n    tag: ({ theme }: { theme: Theme }) =>\n      theme.color(\n        \"VersionControl.GitLog.tagIconColor\",\n        vcsLogStandardColors.TAG\n      ),\n  };\n\nconst StyledRef = styled(StyledCurrentBranchTag)`\n  border-radius: 3px;\n  align-items: stretch;\n  font-size: 0.75rem;\n`;\n\nconst StyledLabelSvg = styled.svg.attrs({ viewBox: \"0 0 14.5 14.5\" })<{\n  type: GitRef[\"type\"];\n}>`\n  width: 1rem;\n  height: 1rem;\n  stroke: rgba(0, 0, 0, 0.25);\n  stroke-width: 0.5px;\n  color: ${({ type, theme }) => gitLogColors[type]({ theme })};\n  z-index: 1; // for the right vertical order of grouped labels\n  &:not(:first-child) {\n    margin-right: -11px;\n  }\n`;\n\nconst StyledRefIconGroup = styled.span`\n  display: inline-flex;\n  flex-direction: row-reverse;\n`;\n\nconst StyledLabelText = styled.span`\n  text-overflow: ellipsis;\n  overflow: hidden;\n`;\n\nexport function RefIcon({ type }: { type: GitRef[\"type\"] }) {\n  return <StyledLabelSvg type={type}>{labelIcon}</StyledLabelSvg>;\n}\n\nexport function RefIconGroup({ types }: { types: Array<GitRef[\"type\"]> }) {\n  return (\n    <StyledRefIconGroup>\n      {types.map((type, index) => (\n        <StyledLabelSvg key={index} type={type}>\n          {labelIcon}\n        </StyledLabelSvg>\n      ))}\n    </StyledRefIconGroup>\n  );\n}\nexport function RefLabel({\n  types,\n  children,\n}: {\n  types: Array<GitRef[\"type\"]>;\n  children: React.ReactNode;\n}) {\n  return (\n    <StyledRef>\n      <RefIconGroup types={types} />\n      <StyledLabelText>{children}</StyledLabelText>\n    </StyledRef>\n  );\n}\n","import { groupBy } from \"ramda\";\nimport { useRecoilValue } from \"recoil\";\nimport React, { ReactNode } from \"react\";\n\nimport { Link, styled, Tooltip, TooltipTrigger } from \"@intellij-platform/core\";\nimport { StyledPlaceholderContainer } from \"../styled-components\";\nimport { RepoColorIcon } from \"../../Changes/StyledRepoColorSquare\";\nimport { vcsRootsState } from \"../../file-status.state\";\nimport { useLatestRecoilValue } from \"../../../recoil-utils\";\nimport {\n  formatCommitDate,\n  formatCommitTime,\n  parseCommitMessage,\n  shortenOid,\n} from \"../commit-utils\";\nimport {\n  allResolvedRefsState,\n  selectedCommitState,\n} from \"../CommitsView/CommitsTable.state\";\nimport { RefIconGroup } from \"../RefLabel\";\nimport { GitRef } from \"../GitRef\";\n\nconst StyledContainer = styled.div`\n  padding: 0.875rem;\n  cursor: default;\n`;\nconst StyledCommitMessage = styled.div`\n  font-family: \"JetBrains Mono\", monospace;\n  line-height: 1.125rem;\n  margin-bottom: 1.25rem;\n  margin-right: 1.1875rem;\n`;\n\nconst StyledCommitMessageHeader = styled.div`\n  font-weight: bold;\n`;\nconst StyledCommitterInfo = styled.div`\n  color: ${({ theme }) => theme.commonColors.label({ disabled: true })};\n`;\n\nconst StyledCommitInfoRow = styled.div`\n  line-height: 1.2;\n  display: flex;\n  gap: 0.25rem;\n  margin-bottom: 0.75rem;\n`;\nconst StyledRepoColorIcon = styled(RepoColorIcon)`\n  align-self: start;\n`;\n\nconst StyledRefsContainer = styled.span`\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  gap: 0.25rem;\n  margin-bottom: 0.75rem;\n`;\n\nexport function CommitDetails() {\n  const [firstSelectedCommit] = useLatestRecoilValue(selectedCommitState);\n  const [allResolvedRefs] = useLatestRecoilValue(allResolvedRefsState);\n  const isMultiRepo = useRecoilValue(vcsRootsState).length > 0;\n  if (!firstSelectedCommit) {\n    return (\n      <StyledPlaceholderContainer>\n        No commits selected\n      </StyledPlaceholderContainer>\n    );\n  }\n\n  const {\n    readCommitResult: { commit, oid },\n    containingRefs,\n    repoPath,\n  } = firstSelectedCommit;\n  const { subject, body } = parseCommitMessage(commit.message);\n  const committerInfo: ReactNode[] = [];\n  if (commit.committer.name !== commit.author.name) {\n    committerInfo.push(\n      <React.Fragment key={commit.committer.email}>\n        by {commit.committer.name} <EmailLink email={commit.committer.email} />\n      </React.Fragment>\n    );\n  }\n  if (commit.committer.timestamp !== commit.author.timestamp) {\n    committerInfo.push(formatDateAndTime(commit.committer.timestamp * 1000));\n  }\n  const refs = allResolvedRefs?.[oid] || [];\n  const refsByType = groupBy((ref) => ref.type, refs);\n  return (\n    <StyledContainer>\n      <StyledCommitMessage>\n        <StyledCommitMessageHeader>{subject}</StyledCommitMessageHeader>\n        {body}\n      </StyledCommitMessage>\n      <StyledCommitInfoRow>\n        {isMultiRepo && (\n          <TooltipTrigger tooltip={<Tooltip>{repoPath}</Tooltip>}>\n            {(props) => <StyledRepoColorIcon {...props} rootPath={repoPath} />}\n          </TooltipTrigger>\n        )}\n        <div>\n          {`${shortenOid(oid)} ${commit.author.name} `}\n          <EmailLink email={commit.author.email} />{\" \"}\n          {`${formatDateAndTime(new Date(commit.author.timestamp * 1000))}`}\n          {committerInfo.length > 0 && (\n            <StyledCommitterInfo>committed {committerInfo}</StyledCommitterInfo>\n          )}\n        </div>\n      </StyledCommitInfoRow>\n      {refs.length > 0 && (\n        <StyledRefsContainer>\n          <RefGroup refs={refsByType.head} />\n          <RefGroup refs={refsByType.localBranch} />\n          <RefGroup refs={refsByType.remoteBranch} />\n          <RefGroup refs={refsByType.tag} />\n        </StyledRefsContainer>\n      )}\n      <div>\n        {/*TODO: collapsing and \"Show more\"*/}\n        In {containingRefs.size} branches: {[...containingRefs].join(\", \")}\n      </div>\n    </StyledContainer>\n  );\n}\n\nconst StyledRefWithIcon = styled.span`\n  display: inline-flex;\n  align-items: center;\n`;\nfunction RefGroup({ refs }: { refs: undefined | GitRef[] }) {\n  return refs?.length ? (\n    <>\n      {refs.map((ref, index) => {\n        const name = `${ref.name}${index === refs.length - 1 ? \"\" : \",\"}`;\n        return index === 0 ? (\n          <StyledRefWithIcon>\n            <RefIconGroup types={refs.map(({ type }) => type).slice(0, 2)} />\n            {name}\n          </StyledRefWithIcon>\n        ) : (\n          // span is needed for the right flex-wrap behavior\n          <span>{name}</span>\n        );\n      })}\n    </>\n  ) : null;\n}\n\nfunction EmailLink({ email }: { email: string }) {\n  return (\n    <a href={`mailto:${email}`} style={{ all: \"unset\" }}>\n      <Link>{`<${email}>`}</Link>\n    </a>\n  );\n}\n\nfunction formatDateAndTime(date: Date | number) {\n  return `on ${formatCommitDate(date)} at ${formatCommitTime(date)}`;\n}\n","import React, { HTMLAttributes, useMemo } from \"react\";\nimport {\n  atom,\n  isRecoilValue,\n  RecoilValue,\n  selector,\n  useRecoilCallback,\n  useRecoilState,\n  useRecoilValue,\n} from \"recoil\";\nimport {\n  ActionButton,\n  ActionDefinition,\n  ActionGroupMenu,\n  ActionsProvider,\n  ActionTooltip,\n  CommonActionId,\n  IconButton,\n  IconButtonWithMenu,\n  PlatformIcon,\n  SpeedSearchMenu,\n  styled,\n  ThreeViewSplitter,\n  Toolbar,\n  TooltipTrigger,\n  useActionGroup,\n  useActions,\n  useCreateDefaultActionGroup,\n  useTreeActions,\n} from \"@intellij-platform/core\";\nimport { StyledHeader, StyledSpacer } from \"../styled-components\";\nimport { CommitChangedFiles } from \"../CommitChanges/CommitsChangedFiles\";\nimport { CommitDetails } from \"./CommitDetails\";\nimport { defaultChangeGroupings } from \"../../Changes/ChangesTree/changesGroupings\";\nimport {\n  changesGroupingActiveState,\n  commitChangesTreeRefState,\n} from \"../CommitChanges/CommitsChangedFiles.state\";\nimport {\n  vcsLogTabShowCommitDetailsInCurrentTabState,\n  vcsLogTabShowCommitDetailsState,\n} from \"../vcs-logs.state\";\nimport { VcsActionIds } from \"../../VcsActionIds\";\nimport { notNull } from \"@intellij-platform/core/utils/array-utils\";\n\nconst splitViewSizeState = atom({\n  key: \"vcs/toolwindow/splitViewSize\",\n  default: 0.5,\n});\n\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n`;\n\nconst groupingState = selector({\n  key: \"vcs/log/commits/changes/groupingState\",\n  get: ({ get }) => {\n    const groupings = defaultChangeGroupings.filter((grouping) =>\n      isRecoilValue(grouping.isAvailable)\n        ? get(grouping.isAvailable)\n        : grouping.isAvailable\n    );\n    return groupings.map((grouping) => ({\n      ...grouping,\n      key: `groupBy:${grouping.id}`,\n      isActive: get(changesGroupingActiveState(grouping.id)),\n    }));\n  },\n});\n\nconst GROUP_BY_ACTION_GROUP_ID = \"Vcs.log.detailsView.groupBy\";\nconst LAYOUT_ACTION_GROUP_ID = \"Vcs.log.detailsView.layout\";\nconst VIEW_OPTIONS_ACTION_GROUP_ID = \"Vcs.log.detailsView.viewOptions\";\nconst SHOW_DETAILS_ACTION_ID = `${LAYOUT_ACTION_GROUP_ID}.${VcsActionIds.SHOW_DETAILS}`;\nconst SHOW_DIFF_PREVIEW_ACTION_ID = `${LAYOUT_ACTION_GROUP_ID}.${VcsActionIds.SHOW_DIFF_PREVIEW}`;\n\nconst groupingActionId = (grouping: { id: string }) => {\n  return `Vcs.log.detailsView.groupBy.${grouping.id}`;\n};\n\nexport function VcsLogDetailsView({ tabKey }: { tabKey: string }) {\n  const [splitViewSize, setSplitViewSize] = useRecoilState(splitViewSizeState);\n  const isDetailsVisible = useRecoilValue(\n    vcsLogTabShowCommitDetailsState(tabKey)\n  );\n  const toggleGroupBy = useRecoilCallback(({ set }) => (id: string) => {\n    set(changesGroupingActiveState(id), (currentValue) => !currentValue);\n  });\n  const createActionGroup = useCreateDefaultActionGroup();\n  const availableGroupings = useRecoilValue(groupingState);\n\n  const treeRef = useRecoilValue(commitChangesTreeRefState);\n  const actions = [\n    createActionGroup({\n      id: VIEW_OPTIONS_ACTION_GROUP_ID,\n      title: \"View Options\",\n      icon: <PlatformIcon icon=\"actions/groupBy.svg\" />,\n      children: [\n        createActionGroup({\n          id: GROUP_BY_ACTION_GROUP_ID,\n          title: \"Group By\",\n          presentation: \"titledSection\",\n          icon: <PlatformIcon icon=\"actions/groupBy.svg\" />,\n          children: availableGroupings.map((grouping) => ({\n            id: groupingActionId(grouping),\n            useShortcutsOf: grouping.useShortcutOf,\n            title: grouping.title,\n            actionPerformed: () => {\n              toggleGroupBy(grouping.id);\n            },\n          })),\n        }),\n        createActionGroup({\n          id: LAYOUT_ACTION_GROUP_ID,\n          presentation: \"titledSection\",\n          title: \"Layout\",\n          children: [\n            useRedefineAction(\n              VcsActionIds.SHOW_DETAILS,\n              SHOW_DETAILS_ACTION_ID\n            ),\n            useRedefineAction(\n              VcsActionIds.SHOW_DIFF_PREVIEW,\n              SHOW_DIFF_PREVIEW_ACTION_ID\n            ),\n          ].filter(notNull),\n        }),\n      ],\n    }),\n    ...useTreeActions({ treeRef }),\n  ];\n\n  return (\n    <ActionsProvider actions={actions}>\n      {({ shortcutHandlerProps }) => (\n        <StyledContainer>\n          <StyledHeader>\n            <Toolbar>\n              <TooltipTrigger\n                tooltip={<ActionTooltip actionName=\"Show Diff\" shortcut=\"⌘D\" />}\n              >\n                <IconButton isDisabled>\n                  <PlatformIcon icon={\"actions/diff.svg\"} />\n                </IconButton>\n              </TooltipTrigger>\n              <TooltipTrigger\n                tooltip={<ActionTooltip actionName=\"Revert Selected Changes\" />}\n              >\n                <IconButton isDisabled>\n                  <PlatformIcon icon=\"actions/rollback.svg\" />\n                </IconButton>\n              </TooltipTrigger>\n              <IconButtonWithMenu\n                renderMenu={({ menuProps }) => {\n                  return (\n                    <VcsLogsDetailsViewOptionsMenu menuProps={menuProps} />\n                  );\n                }}\n              >\n                <PlatformIcon icon=\"actions/groupBy.svg\" />\n              </IconButtonWithMenu>\n            </Toolbar>\n            <StyledSpacer />\n            <Toolbar style={{ flexShrink: 0 }}>\n              <ActionButton actionId={CommonActionId.EXPAND_ALL} />\n              <ActionButton actionId={CommonActionId.COLLAPSE_ALL} />\n            </Toolbar>\n          </StyledHeader>\n          <div style={{ flex: 1, minHeight: 0 }}>\n            {isDetailsVisible ? (\n              <ThreeViewSplitter\n                orientation=\"vertical\"\n                firstSize={splitViewSize}\n                onFirstResize={setSplitViewSize}\n                firstViewMinSize={10}\n                firstView={\n                  <CommitChangedFiles\n                    treeShortcutHandlerProps={shortcutHandlerProps}\n                  />\n                }\n                innerView={<CommitDetails />}\n              />\n            ) : (\n              <CommitChangedFiles\n                treeShortcutHandlerProps={shortcutHandlerProps}\n              />\n            )}\n          </div>\n        </StyledContainer>\n      )}\n    </ActionsProvider>\n  );\n}\n\nconst toggleActionsState: { [actionId: string]: RecoilValue<boolean> } = {\n  [SHOW_DETAILS_ACTION_ID]: vcsLogTabShowCommitDetailsInCurrentTabState,\n  ...Object.fromEntries(\n    defaultChangeGroupings.map((grouping) => [\n      groupingActionId(grouping),\n      changesGroupingActiveState(grouping.id),\n    ])\n  ),\n};\nconst selectedKeysState = selector({\n  key: \"vcs/log/commits/detailsView/viewOptionsSelectedKeys\",\n  get: ({ get }) =>\n    Object.entries(toggleActionsState)\n      .filter(([, state]) => get(state))\n      .map(([actionId]) => actionId),\n});\n\nfunction VcsLogsDetailsViewOptionsMenu({\n  menuProps,\n}: {\n  menuProps: HTMLAttributes<HTMLDivElement>;\n}) {\n  const group = useActionGroup(VIEW_OPTIONS_ACTION_GROUP_ID);\n  const selectedKeys = useRecoilValue(selectedKeysState);\n  return (\n    group && (\n      <ActionGroupMenu\n        menuComponent={SpeedSearchMenu}\n        menuProps={menuProps}\n        actionGroup={group}\n        selectedKeys={selectedKeys}\n      />\n    )\n  );\n}\n\n/**\n * Currently, action groups are expected to **define** the child actions, instead of just referencing already defined\n * actions. In such model, where groups are not just a grouping of existing actions, this hook allows for redefining\n * existing actions to be used within a group. Kind of a temporary solution while action system evolves.\n */\nfunction useRedefineAction(\n  actionId: string,\n  newId: string\n): ActionDefinition | null {\n  const actions = useActions();\n\n  const action = useMemo(() => actions.find(({ id }) => id === actionId), []);\n  if (!action) {\n    return null;\n  }\n  const { perform, id, ...commonProperties } = action;\n  return {\n    ...commonProperties,\n    id: newId,\n    useShortcutsOf: id,\n    isSearchable: false,\n    actionPerformed: (context) => {\n      perform(context);\n    },\n  };\n}\n","import React from \"react\";\nimport {\n  AutoHoverPlatformIcon,\n  BareButton,\n  MenuTrigger,\n  MenuTriggerProps,\n  PlatformIcon,\n  styled,\n} from \"@intellij-platform/core\";\n\nconst StyledDropdownButton = styled.button`\n  all: unset;\n  display: inline-flex;\n  align-items: center;\n  gap: 0.25rem;\n  padding-left: 0.25rem;\n  cursor: pointer;\n  background: ${({ theme }) => theme.color(\"ComboBoxButton.background\")};\n  color: ${({ theme }) => theme.commonColors.label({ disabled: true })};\n\n  line-height: 1.5;\n  border-radius: 0.25rem;\n  white-space: nowrap;\n  border: 2px solid transparent;\n  &:hover {\n    color: ${({ theme }) => theme.color(\"*.foreground\")};\n  }\n  &:focus-visible {\n    border-color: ${({ theme }) =>\n      theme.commonColors.focusRing({ focused: true })};\n  }\n`;\n\nconst StyledDropdownIcon = styled.span`\n  margin-left: -1px;\n  line-height: 1.2;\n`;\n\nconst StyledValue = styled.span`\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  max-width: 8.25rem;\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\n\nconst FocusableAutoHoverPlatformIcon = styled(AutoHoverPlatformIcon)`\n  &:focus-visible {\n    outline: 2px solid\n      ${({ theme }) => theme.commonColors.focusRing({ focused: true })};\n    outline-offset: -2px;\n  }\n`;\nexport function VcsFilterDropdown({\n  label,\n  value,\n  onClear,\n  ...menuTriggerProps\n}: Omit<MenuTriggerProps, \"children\"> & {\n  label: React.ReactNode;\n  value?: React.ReactNode;\n  onClear?: () => void;\n}) {\n  return (\n    <MenuTrigger {...menuTriggerProps}>\n      {(props, ref) => (\n        <StyledDropdownButton {...props} ref={ref}>\n          {label}\n          {value ? (\n            <>\n              : <StyledValue>{value}</StyledValue>\n              <BareButton onPress={onClear}>\n                <FocusableAutoHoverPlatformIcon\n                  icon=\"actions/close\"\n                  hoverIcon=\"actions/closeHovered\"\n                />\n              </BareButton>\n            </>\n          ) : (\n            <StyledDropdownIcon>\n              <PlatformIcon icon=\"general/arrowDownSmall.svg\" />\n            </StyledDropdownIcon>\n          )}\n        </StyledDropdownButton>\n      )}\n    </MenuTrigger>\n  );\n}\n","import React from \"react\";\nimport {\n  AutoHoverPlatformIcon,\n  PlatformIcon,\n  styled,\n} from \"@intellij-platform/core\";\n\nconst StyledMenuIconButton = styled.span.attrs({ role: \"button\" })`\n  display: inline-flex;\n`;\n\nexport function BranchFavoriteButton({\n  onClick,\n  isFavorite,\n  isCurrent,\n}: {\n  isCurrent?: boolean;\n  isFavorite: boolean;\n  onClick: () => void;\n}) {\n  const getIcon = () => {\n    if (isCurrent) {\n      return (\n        <AutoHoverPlatformIcon\n          icon={\n            isFavorite\n              ? \"/platform/dvcs-impl/resources/icons/currentBranchFavoriteLabel.svg\"\n              : \"/platform/dvcs-impl/resources/icons/currentBranchLabel.svg\"\n          }\n          hoverIcon={\n            isFavorite ? \"nodes/favorite.svg\" : \"nodes/notFavoriteOnHover.svg\"\n          }\n          hoverContainerSelector=\"[role='menuitem']\"\n        />\n      );\n    }\n    if (isFavorite) {\n      return <PlatformIcon icon=\"nodes/favorite.svg\" />;\n    } else {\n      return (\n        <AutoHoverPlatformIcon\n          icon=\"nodes/emptyNode.svg\"\n          hoverIcon=\"nodes/notFavoriteOnHover.svg\"\n          hoverContainerSelector=\"[role='menuitem']\"\n        />\n      );\n    }\n  };\n  return (\n    <StyledMenuIconButton\n      onPointerUp={(e) => {\n        e.stopPropagation();\n      }}\n      onClick={onClick}\n    >\n      {getIcon()}\n    </StyledMenuIconButton>\n  );\n}\n","import React, { CSSProperties, RefObject, useMemo } from \"react\";\nimport { css, styled, Tooltip, TooltipTrigger } from \"@intellij-platform/core\";\nimport { ReadCommitResult } from \"isomorphic-git\";\n\nimport { GitRef } from \"../GitRef\";\nimport { RefLabel, RefIcon } from \"../RefLabel\";\nimport { useRecoilValue } from \"recoil\";\nimport {\n  authorColumn,\n  dateColumn,\n  hashColumn,\n  vcsTableColumnsVisibilityState,\n  vcsTableHighlightMyCommitsState,\n  vcsTableReferencesOnTheLeftState,\n  vcsTableShowCommitTimestampState,\n} from \"./CommitsTable.state\";\nimport {\n  areSamePerson,\n  gitRepoUserState,\n  GitUser,\n} from \"../../git-users.state\";\nimport {\n  CURRENT_USER_FILTER_VALUE,\n  vcsLogFilterCurrentTab,\n} from \"../vcs-logs.state\";\nimport {\n  formatCommitDateTime,\n  parseCommitMessage,\n  shortenOid,\n} from \"../commit-utils\";\n\nconst StyledCommitRow = styled.div`\n  display: flex;\n  height: 1.5rem;\n  align-items: center;\n  width: 100%;\n  --column-width-1: 130px;\n  --column-width-2: 130px;\n  --column-width-3: 70px;\n`;\nconst StyledCommitCell = styled.div`\n  overflow: hidden;\n  padding-left: 0.25rem;\n`;\n\nconst StyledRefsContainer = styled.div<{ asOverlay?: boolean }>`\n  ${({ asOverlay }) =>\n    !asOverlay\n      ? css`\n          position: absolute;\n          right: 0;\n          top: 1px;\n          max-width: calc(100% - 100px);\n        `\n      : css`\n          flex-shrink: 0;\n        `};\n\n  display: flex;\n  gap: 0.25rem;\n  overflow: hidden;\n  background: ${({ theme }) =>\n    theme.currentBackgroundAware(theme.color(\"List.background\"))};\n`;\nconst StyledMessageContainer = styled.div`\n  position: relative;\n  display: flex;\n  gap: 0.25rem;\n`;\n\nconst StyledRefTooltipRow = styled.div`\n  display: flex;\n  align-items: center;\n  margin: 0 0.25rem;\n  font-size: 0.75rem;\n`;\nconst useCurrentUserHighlightStyle = ({\n  repoRoot,\n  author,\n}: {\n  repoRoot: string;\n  author: GitUser;\n}): CSSProperties => {\n  const currentUser = useRecoilValue(gitRepoUserState(repoRoot));\n  const shouldHighlightCurrentUserCommits = useRecoilValue(\n    vcsTableHighlightMyCommitsState\n  );\n  // for now assuming only a single table can be visible, and that's current tab's.\n  const userFilter = useRecoilValue(vcsLogFilterCurrentTab.user);\n  // single user case is not considered a special case, like it is in the original impl\n  const shouldHighlight =\n    shouldHighlightCurrentUserCommits &&\n    userFilter !== CURRENT_USER_FILTER_VALUE &&\n    areSamePerson(currentUser, author);\n\n  return { fontWeight: shouldHighlight ? \"bold\" : undefined };\n};\n\nexport function CommitsTableRow({\n  refs,\n  readCommitResult: {\n    oid,\n    commit: { author, committer, message },\n  },\n  repoRoot,\n}: {\n  repoRoot: string;\n  readCommitResult: ReadCommitResult;\n  refs: GitRef[] | undefined;\n}) {\n  const showCommitTimestamp = useRecoilValue(vcsTableShowCommitTimestampState);\n  const referencesOnTheLeft = useRecoilValue(vcsTableReferencesOnTheLeftState);\n  const isAuthorVisible = useRecoilValue(\n    vcsTableColumnsVisibilityState(authorColumn.id)\n  );\n  const isDateVisible = useRecoilValue(\n    vcsTableColumnsVisibilityState(dateColumn.id)\n  );\n  const isHashVisible = useRecoilValue(\n    vcsTableColumnsVisibilityState(hashColumn.id)\n  );\n\n  const highlightStyles = useCurrentUserHighlightStyle({ author, repoRoot });\n  return (\n    <StyledCommitRow>\n      <StyledCommitCell style={{ flexBasis: \"0%\", flexGrow: 1, flexShrink: 1 }}>\n        <StyledMessageContainer>\n          {refs && <CommitRefs onLeft={referencesOnTheLeft} refs={refs} />}\n          <span style={highlightStyles}>\n            {parseCommitMessage(message).subject}\n          </span>\n        </StyledMessageContainer>\n      </StyledCommitCell>\n      {isAuthorVisible && (\n        <StyledCommitCell\n          style={{\n            flexBasis: \"auto\",\n            width: \"var(--column-width-1)\",\n            flexShrink: 1,\n            ...highlightStyles,\n          }}\n        >\n          {author.name}\n          {committer.name !== author.name && \"*\"}\n        </StyledCommitCell>\n      )}\n      {isDateVisible && (\n        <StyledCommitCell\n          style={{\n            flexBasis: \"auto\",\n            width: \"var(--column-width-2)\",\n            flexShrink: 1,\n            ...highlightStyles,\n          }}\n        >\n          {formatCommitDateTime(\n            (showCommitTimestamp ? committer : author).timestamp * 1000\n          )}\n        </StyledCommitCell>\n      )}\n      {isHashVisible && (\n        <StyledCommitCell\n          style={{\n            flexBasis: \"auto\",\n            width: \"var(--column-width-3)\",\n            flexShrink: 1,\n            ...highlightStyles,\n          }}\n        >\n          {shortenOid(oid)}\n        </StyledCommitCell>\n      )}\n    </StyledCommitRow>\n  );\n}\n\nfunction refKey(ref: GitRef) {\n  return `${ref.type}${ref.name}`;\n}\n\nfunction CommitRefs({ refs, onLeft }: { refs: GitRef[]; onLeft?: boolean }) {\n  const { filteredRefs } = useMemo(() => {\n    const headIsOnABranch = refs.some(\n      (ref) => ref.type === \"localBranch\" && ref.isCurrent\n    );\n    return {\n      filteredRefs: refs.filter(\n        (ref) =>\n          !(\n            (ref.type === \"head\" && headIsOnABranch) ||\n            (ref.type === \"remoteBranch\" &&\n              refs.find(\n                (aBranch) =>\n                  aBranch.type === \"localBranch\" &&\n                  aBranch.trackingBranch === ref.name\n              ))\n          )\n      ),\n    };\n  }, [refs]);\n\n  return (\n    <TooltipTrigger\n      placement=\"bottom\"\n      delay={800}\n      isDisabled={refs.length < 2}\n      tooltip={\n        <Tooltip withPointer>\n          {refs.map((ref) => (\n            <StyledRefTooltipRow key={refKey(ref)}>\n              <RefIcon type={ref.type} />\n              {ref.name}\n            </StyledRefTooltipRow>\n          ))}\n        </Tooltip>\n      }\n    >\n      {({ ref, ...tooltipTriggerProps }) => (\n        <StyledRefsContainer\n          ref={ref as RefObject<HTMLDivElement>}\n          asOverlay={onLeft}\n          {...tooltipTriggerProps}\n        >\n          {filteredRefs\n            .filter(\n              (ref) =>\n                ref.type !== \"remoteBranch\" ||\n                !refs.find(\n                  (aBranch) =>\n                    aBranch.type === \"localBranch\" &&\n                    aBranch.trackingBranch === ref.name\n                )\n            )\n            .map((ref) => {\n              let name = ref.name;\n              const types: GitRef[\"type\"][] = [ref.type];\n              if (ref.type === \"localBranch\" && ref.trackingBranch) {\n                types.unshift(\"remoteBranch\");\n                name = `${ref.trackingBranch.split(\"/\")[0]} & ${ref.name}`;\n              }\n              if (ref.type === \"localBranch\" && ref.isCurrent) {\n                types.push(\"head\");\n              }\n              return (\n                <RefLabel key={refKey(ref)} types={types}>\n                  {name}\n                </RefLabel>\n              );\n            })}\n        </StyledRefsContainer>\n      )}\n    </TooltipTrigger>\n  );\n}\n","import React from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport { Item, Link, List, ProgressBar, styled } from \"@intellij-platform/core\";\nimport { StyledPlaceholderContainer } from \"../styled-components\";\nimport { useResetFilters, vcsActiveTabKeyState } from \"../vcs-logs.state\";\nimport { useLatestRecoilValue } from \"../../../recoil-utils\";\nimport { CommitsTableRow } from \"./CommitsTableRow\";\nimport { GitRef } from \"../GitRef\";\nimport {\n  allResolvedRefsState,\n  commitsSelectionState,\n  commitsTableRowsState,\n} from \"./CommitsTable.state\";\nimport { StyledListItem } from \"@intellij-platform/core/List/StyledListItem\";\n\n// const StyledList = styled(List)`\n//   display: grid;\n//   grid-template-columns: repeat(3, auto); /* Define 3 columns */\n//\n//   ${StyledListItem} {\n//     display: contents;\n//   }\n// ` as typeof List;\n\nconst StyledProgressBar = styled(ProgressBar)`\n  position: absolute;\n  width: 100%;\n  z-index: 1;\n`;\nconst StyledContainer = styled.div`\n  position: relative;\n  min-height: 0;\n  flex: 1;\n  ${StyledListItem} {\n    // the default \"min-width: min-content\", which is necessary for sizing overlays (e.g. Popup) containing list/tree,\n    // results in horizontally scrollable table. Probably not an issue when a proper Table component is implemented.\n    min-width: unset;\n  }\n`;\n\nconst ResolvedRefsContext = React.createContext<Record<string, GitRef[]>>({});\nexport function CommitsTable() {\n  const currentTabKey = useRecoilValue(vcsActiveTabKeyState);\n  const resetFilters = useResetFilters();\n\n  const [result, commitRowsState] = useLatestRecoilValue(commitsTableRowsState);\n  const rows = result?.rows;\n  const [allResolvedRefs] = useLatestRecoilValue(allResolvedRefsState);\n  const [selectedCommits, setSelectedCommits] = useRecoilState(\n    commitsSelectionState\n  );\n\n  return (\n    <ResolvedRefsContext.Provider value={allResolvedRefs ?? {}}>\n      <StyledContainer>\n        {commitRowsState === \"loading\" && (\n          <StyledProgressBar aria-label=\"Loading commits\" isIndeterminate />\n        )}\n        {rows && rows.length > 0 && (\n          <List\n            items={rows}\n            fillAvailableSpace\n            selectionMode=\"multiple\"\n            selectedKeys={selectedCommits}\n            onSelectionChange={setSelectedCommits}\n            estimatedItemHeight={24}\n          >\n            {({ readCommitResult, repoPath }) => (\n              <Item\n                key={readCommitResult.oid}\n                textValue={readCommitResult.commit.message}\n              >\n                {/* Using context here due to rendering optimizations of collection API */}\n                <ResolvedRefsContext.Consumer>\n                  {(refs) => (\n                    <CommitsTableRow\n                      readCommitResult={readCommitResult}\n                      repoRoot={repoPath}\n                      refs={refs[readCommitResult.oid]}\n                    />\n                  )}\n                </ResolvedRefsContext.Consumer>\n              </Item>\n            )}\n          </List>\n        )}\n        {commitRowsState === \"hasValue\" && rows && rows.length === 0 && (\n          <StyledPlaceholderContainer>\n            No commits matching filters\n            <Link onPress={() => resetFilters(currentTabKey)}>\n              Reset filters\n            </Link>\n          </StyledPlaceholderContainer>\n        )}\n      </StyledContainer>\n    </ResolvedRefsContext.Provider>\n  );\n}\n","import { v4 as uuid } from \"uuid\";\nimport React, { useEffect, useState } from \"react\";\nimport {\n  ActionButton,\n  ActionTooltip,\n  AutoHoverPlatformIcon,\n  IconButton,\n  Item,\n  Menu,\n  PlatformIcon,\n  SearchInput,\n  styled,\n  StyledHoverContainer,\n  Toolbar,\n  ToolbarSeparator,\n  TooltipTrigger,\n  useGetActionShortcut,\n} from \"@intellij-platform/core\";\n\nimport { StyledHeader, StyledSpacer } from \"../styled-components\";\nimport { VcsFilterDropdown } from \"./VcsLogDropdown\";\nimport {\n  atom,\n  RecoilState,\n  useRecoilCallback,\n  useRecoilState,\n  useRecoilValue,\n  useResetRecoilState,\n} from \"recoil\";\nimport { searchInputRefState } from \"../VersionControlToolWindow\";\nimport { VcsActionIds } from \"../../VcsActionIds\";\nimport {\n  CURRENT_USER_FILTER_VALUE,\n  vcsActiveTabKeyState,\n  vcsLogFilter,\n  vcsTabKeysState,\n} from \"../vcs-logs.state\";\nimport { notImplemented } from \"../../../Project/notImplemented\";\nimport { DateRange, dateToString } from \"../DateRange\";\nimport { BranchesFilterDropdown } from \"./BranchesFilterDropdown\";\nimport { CommitsTable } from \"./CommitsTable\";\nimport { CommitsTableViewOptionsMenuIconButton } from \"./CommitsTableViewOptionsMenuIconButton\";\n\nconst StyledSearchInput = styled(SearchInput)`\n  border-radius: 2px;\n  width: 219px;\n  margin-right: 0.0625rem;\n  margin-left: 0.2rem;\n`;\n\nconst StyledContainer = styled.div`\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst searchHistoryState = atom<string[]>({\n  key: \"vcs/toolwindow/searchHistory\",\n  default: [], // TODO: add an effect to persist it under application level other.xml file under\n  // PropertyService component's \"Vcs.Log.Text.Filter.History\" property\n});\n\nexport function VcsLogCommitsView({ tabKey }: { tabKey: string }) {\n  const textFilterRef = useRecoilValue(searchInputRefState);\n  const [searchQuery, setSearchQuery] = useRecoilState(\n    vcsLogFilter.searchQuery(tabKey)\n  );\n  const [user, setUser] = useRecoilState(vcsLogFilter.user(tabKey));\n  const resetUser = useResetRecoilState(vcsLogFilter.user(tabKey));\n  const [dateFilter, setDateFilter] = useRecoilState(vcsLogFilter.date(tabKey));\n  const resetDate = useResetRecoilState(vcsLogFilter.date(tabKey));\n  const [searchHistory, setSearchHistory] = useRecoilState(searchHistoryState);\n  const [searchInputValue, setSearchInputValue] = useState(searchQuery);\n  const getActionShortcut = useGetActionShortcut();\n  const isRegExpOn = useRecoilValue(vcsLogFilter.regExp(tabKey));\n  const isMatchCaseOn = useRecoilValue(vcsLogFilter.matchCase(tabKey));\n  const submitSearchQuery = (value = searchInputValue) => {\n    setSearchQuery(value);\n    if (value && !searchHistory.includes(value)) {\n      setSearchHistory((searchHistory) => [\n        value,\n        ...searchHistory.filter((item) => item !== value),\n      ]);\n    }\n  };\n\n  useEffect(() => {\n    setSearchInputValue(searchQuery);\n  }, [searchQuery]);\n\n  const createNewTab = useRecoilCallback(\n    ({ set, snapshot }) =>\n      () => {\n        const newTabId = uuid();\n        set(vcsTabKeysState, (value) => [...value, newTabId]);\n        Object.values(vcsLogFilter).forEach(\n          (filterState: (tabKey: string) => RecoilState<any>) => {\n            set(\n              filterState(newTabId),\n              snapshot\n                .getLoadable(\n                  filterState(\n                    snapshot.getLoadable(vcsActiveTabKeyState).getValue()\n                  )\n                )\n                .getValue()\n            );\n          }\n        );\n        set(vcsActiveTabKeyState, newTabId);\n      },\n    []\n  );\n  const today = new Date();\n  const sevenDaysAgo = new Date();\n  sevenDaysAgo.setDate(today.getDate() - 7);\n  const yesterday = new Date();\n  yesterday.setDate(today.getDate() - 1);\n  const predefinedDateRanges = [\n    {\n      name: \"Last 24 hours\",\n      value: { from: yesterday },\n    },\n    {\n      name: \"Last 7 days\",\n      value: { from: sevenDaysAgo },\n    },\n  ];\n  return (\n    <StyledContainer>\n      <StyledHeader>\n        <TooltipTrigger\n          tooltip={\n            <ActionTooltip\n              actionName=\"Text or Hash Filter\"\n              shortcut={getActionShortcut(VcsActionIds.FOCUS_TEXT_FILTER)}\n            />\n          }\n        >\n          <StyledSearchInput\n            inputRef={textFilterRef}\n            value={searchInputValue}\n            onChange={setSearchInputValue}\n            onSubmit={submitSearchQuery}\n            onBlur={() => submitSearchQuery()}\n            onClear={() => submitSearchQuery(\"\")}\n            searchHistory={searchHistory}\n            addonAfter={\n              <>\n                <StyledHoverContainer\n                  as={ActionButton}\n                  excludeFromTabOrder={false}\n                  actionId={VcsActionIds.REG_EXP}\n                >\n                  <AutoHoverPlatformIcon\n                    icon={\n                      isRegExpOn ? \"actions/regexSelected\" : \"actions/regex\"\n                    }\n                    hoverIcon={\n                      isRegExpOn\n                        ? \"actions/regexSelected\"\n                        : \"actions/regexHovered\"\n                    }\n                  />\n                </StyledHoverContainer>\n                <StyledHoverContainer\n                  as={ActionButton}\n                  excludeFromTabOrder={false}\n                  actionId={VcsActionIds.MATCH_CASE}\n                >\n                  {isMatchCaseOn ? (\n                    <PlatformIcon icon=\"actions/matchCaseSelected\" />\n                  ) : (\n                    <AutoHoverPlatformIcon\n                      icon=\"actions/matchCase\"\n                      hoverIcon=\"actions/matchCaseHovered\"\n                    />\n                  )}\n                </StyledHoverContainer>\n              </>\n            }\n          />\n        </TooltipTrigger>\n        <Toolbar>\n          <BranchesFilterDropdown tabKey={tabKey} />\n          <VcsFilterDropdown\n            value={user === CURRENT_USER_FILTER_VALUE ? \"me\" : user}\n            onClear={resetUser}\n            renderMenu={({ menuProps }) => (\n              <Menu\n                {...menuProps}\n                onAction={(key) => {\n                  if (key === \"select\") {\n                    return notImplemented();\n                  }\n                  setUser(`${key}`);\n                }}\n              >\n                <Item key=\"select\">Select...</Item>\n                <Item key={CURRENT_USER_FILTER_VALUE}>me</Item>\n              </Menu>\n            )}\n            label=\"User\"\n          />\n          <VcsFilterDropdown\n            value={dateFilter && dateRangeToString(dateFilter)}\n            onClear={resetDate}\n            renderMenu={({ menuProps }) => (\n              <Menu\n                {...menuProps}\n                onAction={(key) => {\n                  const predefinedDateRange = predefinedDateRanges.find(\n                    ({ name }) => name === key\n                  );\n                  if (predefinedDateRange) {\n                    setDateFilter(predefinedDateRange.value);\n                  } else {\n                    notImplemented();\n                  }\n                }}\n              >\n                {[\n                  <Item key=\"select\">Select...</Item>,\n                  ...predefinedDateRanges.map(({ name }) => (\n                    <Item key={name}>{name}</Item>\n                  )),\n                ]}\n              </Menu>\n            )}\n            label=\"Date\"\n          />\n          <VcsFilterDropdown\n            renderMenu={({ menuProps }) => (\n              <Menu {...menuProps} onAction={notImplemented}>\n                <Item>Select in...</Item>\n                <Item>Select in Tree...</Item>\n              </Menu>\n            )}\n            label=\"Paths\"\n          />\n          <ToolbarSeparator />\n          <TooltipTrigger\n            tooltip={<ActionTooltip actionName=\"Open New Git Log Tab\" />}\n          >\n            <IconButton aria-label=\"Checkout\" onPress={createNewTab}>\n              <PlatformIcon icon=\"actions/openNewTab.svg\" />\n            </IconButton>\n          </TooltipTrigger>\n        </Toolbar>\n        <StyledSpacer />\n        <Toolbar style={{ flexShrink: 0 }}>\n          <ActionButton actionId={VcsActionIds.LOG_REFRESH} />\n          <TooltipTrigger tooltip={<ActionTooltip actionName=\"Cherry-Pick\" />}>\n            <IconButton isDisabled>\n              <PlatformIcon icon=\"/platform/dvcs-impl/resources/icons/cherryPick.svg\" />\n            </IconButton>\n          </TooltipTrigger>\n          <CommitsTableViewOptionsMenuIconButton />\n          <TooltipTrigger\n            tooltip={\n              <ActionTooltip actionName=\"Go To Hash/Branch/Tag\" shortcut=\"⌘F\" />\n            }\n          >\n            <IconButton>\n              <PlatformIcon icon=\"actions/find\" />\n            </IconButton>\n          </TooltipTrigger>\n        </Toolbar>\n      </StyledHeader>\n      <CommitsTable />\n    </StyledContainer>\n  );\n}\n\nfunction dateRangeToString(dateRange: DateRange): string {\n  if (dateRange.from && dateRange.to) {\n    return `Between ${dateToString(dateRange.from)} and ${dateToString(\n      dateRange.to\n    )}`;\n  }\n  if (dateRange.from) {\n    return `since ${dateToString(dateRange.from)}`;\n  }\n  if (dateRange.to) {\n    return `until ${dateToString(dateRange.to)}`;\n  }\n  return \"\";\n}\n","import React, { useRef, useState } from \"react\";\nimport { useRecoilState, useRecoilValue, useSetRecoilState } from \"recoil\";\nimport {\n  PlatformIcon,\n  SpeedSearchTree,\n  styled,\n  useCollectionSearchInput,\n} from \"@intellij-platform/core\";\n\nimport {\n  branchTreeNodeRenderers,\n  keyToBranch,\n} from \"./branchTreeNodeRenderers\";\nimport {\n  branchesTreeNodeState,\n  branchesTreeRefState,\n  expandedKeysState,\n  searchInputState,\n  selectedKeysState,\n} from \"./BranchesTree.state\";\nimport { StyledHeader } from \"../styled-components\";\nimport { vcsLogFilterCurrentTab } from \"../vcs-logs.state\";\nimport { TreeSelectionManager } from \"@intellij-platform/core/Tree/TreeSelectionManager\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { useLatestRecoilValue } from \"../../../recoil-utils\";\n\nconst StyledSearchInput = styled.input`\n  all: unset;\n  flex: 1;\n  align-self: stretch;\n`;\nconst StyledContainer = styled.div`\n  min-width: 0; // don't outgrow the container\n  flex-grow: 1; // fill the available space\n  display: flex;\n  flex-direction: column;\n`;\nconst StyledSearchIconContainer = styled.span`\n  display: inline-flex;\n  margin-top: -0.0625rem;\n  margin-left: 0.7rem;\n  margin-right: 0.25rem;\n  cursor: text;\n`;\n\nexport function BranchesTree({ tabKey }: { tabKey: string }) {\n  const [branchesTreeNodes] = useLatestRecoilValue(branchesTreeNodeState);\n  const [selectedKeys, setSelectedKeys] = useRecoilState(\n    selectedKeysState(tabKey)\n  );\n  const [expandedKeys, setExpandedKeys] = useRecoilState(\n    expandedKeysState(tabKey)\n  );\n  const [searchTerm, setSearchTerm] = useRecoilState(searchInputState(tabKey));\n  const treeRef = useRecoilValue(branchesTreeRefState(tabKey));\n  const ref = useRef<HTMLDivElement>(null);\n  const searchInputRef = useRef<HTMLInputElement>(null);\n  const selectionManagerRef = useRef<TreeSelectionManager>(null);\n  const [isInputFocused, setInputFocused] = useState(false);\n  const setBranchFilter = useSetRecoilState(vcsLogFilterCurrentTab.branch);\n  const { collectionSearchInputProps } = useCollectionSearchInput({\n    collectionRef: ref,\n    selectionManager: selectionManagerRef.current,\n  });\n  /**\n   * TODO: remaining from search:\n   * - Make the search input red when there is no match\n   * - filter non-matching tree nodes out\n   * - search in the whole tree, not just nodes that are currently visible based on expandedKeys\n   *   - update expanded keys to show matches, as a side effect, every time matches are updated.\n   * The above items are postponed to think more about flexibility of SpeedSearchTree API.\n   * Some rough thoughts about different approaches:\n   * - Provide generic tree utilities to search in the whole tree. In SpeedSearchTree allow for full control over\n   * `matches`. It will be in usage side that matches are calculated based on search input value, and passed to\n   * SpeedSearchTree as an input.\n   * - In SpeedSearchTree, allow for passing a custom search function, which would accept the tree collection object,\n   *   the search query, and the default match function (minusculeMatch).\n   * - Make Tree more flexible or introduce a more flexible base component, so that speed search for tree can be\n   *   implementated in a more composable way. Tree (or TreeBase) would accept props for intercepting `state` creation,\n   *   and it would also allow passing additional props to the tree container. Then a more generic CollectionSpeedSearch\n   *   component would offer options on how to control and customize speed search, and would return props to be passed\n   *   to collection components.\n   */\n\n  return (\n    <StyledContainer>\n      <StyledHeader>\n        <StyledSearchIconContainer>\n          <PlatformIcon icon=\"actions/search\" />\n        </StyledSearchIconContainer>\n        {/* FIXME: tabIndex -1 is a workaround to not get the input focused when the toolwindow opens. Not ideal.*/}\n        <StyledSearchInput\n          ref={searchInputRef}\n          tabIndex={-1}\n          value={searchTerm}\n          onChange={(e) => setSearchTerm(e.target.value)}\n          {...mergeProps(collectionSearchInputProps, {\n            onFocus: () => {\n              setInputFocused(true);\n            },\n            onBlur: () => {\n              setInputFocused(false);\n            },\n          })}\n        />\n      </StyledHeader>\n      <SpeedSearchTree\n        ref={ref}\n        treeRef={treeRef}\n        selectionManagerRef={selectionManagerRef}\n        items={branchesTreeNodes ?? []}\n        selectionMode=\"multiple\"\n        selectedKeys={selectedKeys}\n        onSelectionChange={setSelectedKeys}\n        expandedKeys={expandedKeys}\n        onExpandedChange={setExpandedKeys}\n        onAction={(key) => {\n          const branch = keyToBranch(`${key}`);\n          if (branch) {\n            setBranchFilter([branch]);\n          }\n        }}\n        fillAvailableSpace\n        // speed search related props\n        showAsFocused={isInputFocused}\n        searchTerm={searchTerm}\n        onSearchTermChange={setSearchTerm}\n        keepSearchActiveOnBlur\n        hideSpeedSearchPopup\n        isSearchActive\n      >\n        {(node) => {\n          // @ts-expect-error we need to somehow infer the type of `node.type`\n          return branchTreeNodeRenderers[node.type](node);\n        }}\n      </SpeedSearchTree>\n    </StyledContainer>\n  );\n}\n","import React, { RefObject } from \"react\";\nimport {\n  atom,\n  RecoilState,\n  useRecoilCallback,\n  useRecoilState,\n  useRecoilValue,\n} from \"recoil\";\nimport {\n  ActionDefinition,\n  ActionsProvider,\n  ActionTooltip,\n  MultiViewToolWindow,\n  PlatformIcon,\n  styled,\n  TabCloseButton,\n  ThreeViewSplitter,\n  ThreeViewSplitterProps,\n  TooltipTrigger,\n  ToolWindowTabContent,\n} from \"@intellij-platform/core\";\n\nimport { VcsLogDetailsView } from \"./DetailsView/VcsLogDetailsView\";\nimport { VcsLogCommitsView } from \"./CommitsView/VcsLogCommitsView\";\nimport { VcsBranchesView } from \"./BranchesView/VcsBranchesView\";\nimport { VcsActionIds } from \"../VcsActionIds\";\nimport {\n  useCloseVcsTab,\n  vcsActiveTabKeyState,\n  vcsLogFilter,\n  vcsLogTabShowBranchesState,\n  vcsLogTabShowCommitDetailsState,\n  vcsTabKeysState,\n  vcsTabTitleState,\n} from \"./vcs-logs.state\";\nimport { useCommitsTableActions } from \"./CommitsView/useCommitsTableActions\";\nimport { notImplemented } from \"../../Project/notImplemented\";\n\nexport const VERSION_CONTROL_TOOLWINDOW_ID = \"Version Control\";\n\nconst firstViewSizeState = atom({\n  key: \"vcs/toolwindow/firstViewSize\",\n  default: 0.25,\n});\nconst lastViewSizeState = atom({\n  key: \"vcs/toolwindow/lastViewSize\",\n  default: 0.35,\n});\n\nconst StyledToolWindowHeader = styled.span`\n  margin: 0 0.5rem 0 0.125rem;\n`;\n\nconst StyledContainer = styled.div`\n  height: 100%;\n  display: flex;\n  :focus-visible {\n    outline: none;\n  }\n`;\n\nexport const searchInputRefState = atom<RefObject<HTMLInputElement>>({\n  key: \"vcs/toolWindow/searchInputRef\",\n  default: React.createRef(),\n  dangerouslyAllowMutability: true,\n});\n\nexport const VersionControlToolWindow = () => {\n  const tabKeys = useRecoilValue(vcsTabKeysState);\n  const [activeTabKey, setActiveTabKey] = useRecoilState(vcsActiveTabKeyState);\n  return (\n    <MultiViewToolWindow\n      headerContent={<StyledToolWindowHeader>Git:</StyledToolWindowHeader>}\n      activeKey={activeTabKey}\n      onActiveKeyChange={(key) => setActiveTabKey(`${key}`)}\n    >\n      {tabKeys.map((key) => (\n        <MultiViewToolWindow.View\n          tabContent={<VcsToolWindowTabTitle tabKey={key} />}\n          key={key}\n        >\n          <VcsTab tabKey={key} />\n        </MultiViewToolWindow.View>\n      ))}\n    </MultiViewToolWindow>\n  );\n};\n\nconst StyledExpandStripeButton = styled.button.attrs({ tabIndex: -1 })`\n  box-sizing: border-box;\n  all: unset;\n  width: 1.71875rem;\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n  padding: 0.5rem 0;\n  gap: 0.625rem;\n  background: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  :disabled {\n    color: ${({ theme }) => theme.color(\"Button.disabledText\")};\n  }\n  &:hover {\n    background: ${({ theme }) =>\n      theme.color(\n        \"ToolWindow.Button.hoverBackground\",\n        theme.dark ? \"#0f0f0f28\" : \"#55555528\"\n      )};\n  }\n`;\nconst StyledShowBranchesButton = styled(StyledExpandStripeButton)`\n  border-right: 1px solid ${({ theme }) => theme.commonColors.borderColor};\n`;\nconst StyledShowBranchesButtonText = styled.span`\n  writing-mode: vertical-lr;\n  transform: rotateZ(180deg);\n  font-size: 0.6875rem;\n`;\n\nfunction ShowBranchesButton({ onPress }: { onPress: () => void }) {\n  return (\n    <StyledShowBranchesButton onClick={onPress}>\n      <PlatformIcon icon=\"actions/arrowExpand\" />\n      <StyledShowBranchesButtonText>Branches</StyledShowBranchesButtonText>\n    </StyledShowBranchesButton>\n  );\n}\n\nfunction VcsTab({ tabKey }: { tabKey: string }) {\n  const [firstViewSize, setFirstViewSize] = useRecoilState(firstViewSizeState);\n  const [lastViewSize, setLastViewSize] = useRecoilState(lastViewSizeState);\n\n  const actions = useVcsLogsToolWindowActions();\n  const [showBranches, setShowBranches] = useRecoilState(\n    vcsLogTabShowBranchesState(tabKey)\n  );\n\n  const firstViewProps: Partial<ThreeViewSplitterProps> = showBranches\n    ? {\n        firstView: <VcsBranchesView tabKey={tabKey} />,\n        firstSize: firstViewSize,\n        onFirstResize: setFirstViewSize,\n        firstViewMinSize: 85,\n      }\n    : {};\n  return (\n    <ActionsProvider actions={actions}>\n      {({ shortcutHandlerProps }) => (\n        // tabIndex is added to make the whole container focusable, which means the focus can go away from the currently\n        // focused element, when background is clicked. This is to follow the original implementation.\n        <StyledContainer\n          {...shortcutHandlerProps}\n          tabIndex={showBranches ? -1 : 0}\n        >\n          {!showBranches && (\n            <ShowBranchesButton onPress={() => setShowBranches(true)} />\n          )}\n          <ThreeViewSplitter\n            {...firstViewProps}\n            innerView={<VcsLogCommitsView tabKey={tabKey} />}\n            innerViewMinSize={200}\n            lastView={<VcsLogDetailsView tabKey={tabKey} />}\n            lastSize={lastViewSize}\n            onLastResize={setLastViewSize}\n            lastViewMinSize={40}\n          />\n        </StyledContainer>\n      )}\n    </ActionsProvider>\n  );\n}\n\nfunction useToggleCurrentTabSettings(\n  toggleState: (activeTab: string) => RecoilState<boolean>\n) {\n  return useRecoilCallback(\n    ({ set, snapshot }) =>\n      () => {\n        set(\n          toggleState(snapshot.getLoadable(vcsActiveTabKeyState).getValue()),\n          (value) => !value\n        );\n      },\n    []\n  );\n}\n\nfunction useVcsLogsToolWindowActions() {\n  const textFilterRef = useRecoilValue(searchInputRefState);\n  const hideBranches = useRecoilCallback(\n    ({ set, snapshot }) =>\n      () => {\n        set(\n          vcsLogTabShowBranchesState(\n            snapshot.getLoadable(vcsActiveTabKeyState).getValue()\n          ),\n          // Would be nicer to have the action toggle, but prioritized matching the reference impl here.\n          false\n        );\n      },\n    []\n  );\n\n  const toggleMatchCase = useToggleCurrentTabSettings(vcsLogFilter.matchCase);\n  const toggleRegExp = useToggleCurrentTabSettings(vcsLogFilter.regExp);\n  const toggleDetails = useToggleCurrentTabSettings(\n    vcsLogTabShowCommitDetailsState\n  );\n\n  const actions: ActionDefinition[] = [\n    ...useCommitsTableActions(),\n    {\n      id: VcsActionIds.FOCUS_TEXT_FILTER,\n      title: \"Focus Text Filter\",\n      actionPerformed: () => {\n        textFilterRef.current?.focus();\n      },\n    },\n    {\n      id: VcsActionIds.GIT_LOG_HIDE_BRANCHES,\n      title: \"Hide Git Branches\",\n      icon: <PlatformIcon icon=\"actions/arrowCollapse\" />,\n      actionPerformed: hideBranches,\n    },\n    {\n      id: VcsActionIds.MATCH_CASE,\n      title: \"Match Case\",\n      icon: <PlatformIcon icon=\"actions/matchCase.svg\" />,\n      actionPerformed: toggleMatchCase,\n    },\n    {\n      id: VcsActionIds.REG_EXP,\n      title: \"Regex\",\n      icon: <PlatformIcon icon=\"actions/regex\" />,\n      actionPerformed: toggleRegExp,\n    },\n    {\n      id: VcsActionIds.SHOW_DETAILS,\n      title: \"Show Details\",\n      description: \"Display details panel\",\n      actionPerformed: toggleDetails,\n    },\n    {\n      id: VcsActionIds.SHOW_DIFF_PREVIEW,\n      title: \"Show Diff Preview\",\n      description: \"Show Diff Preview Panel\",\n      actionPerformed: () => notImplemented(),\n    },\n  ];\n  return actions;\n}\n\nfunction VcsToolWindowTabTitle({ tabKey }: { tabKey: string }) {\n  const closeTab = useCloseVcsTab();\n  return (\n    <ToolWindowTabContent\n      title={useRecoilValue(vcsTabTitleState(tabKey))}\n      closeButton={\n        tabKey !== \"MAIN\" && (\n          <TooltipTrigger tooltip={<ActionTooltip actionName=\"Close Tab\" />}>\n            <TabCloseButton onPress={() => closeTab(tabKey)} />\n          </TooltipTrigger>\n        )\n      }\n    />\n  );\n}\n","import {\n  Button,\n  InputField,\n  ModalWindow,\n  styled,\n  useBalloonManager,\n  WindowLayout,\n} from \"@intellij-platform/core\";\nimport React, { FormEvent, ReactNode, useState } from \"react\";\nimport {\n  BranchNameError,\n  cleanUpBranchName,\n  validateBranchName,\n} from \"./branch-name-utils\";\nimport { useRecoilValue } from \"recoil\";\nimport { repoBranchesState, useRenameBranch } from \"./branches.state\";\n\nconst StyledContainer = styled.div`\n  padding: 0.5rem 1rem;\n`;\nconst StyledInputField = styled(InputField)`\n  width: 100%;\n`;\n\nexport const ErrorMessages: Record<\n  BranchNameError,\n  (branchName: string) => ReactNode\n> = {\n  EXISTING: (branchName: string) => (\n    <>\n      Branch name {branchName} already exists <br />\n    </>\n  ),\n  CLASHING_WITH_REMOTE: (branchName: string) => (\n    <>\n      Branch name {branchName} clashes with remote branch <br />\n      with the same name\n    </>\n  ),\n};\n\nexport function RenameBranchWindow({\n  branchName,\n  repoRoot,\n  close,\n}: {\n  branchName: string;\n  repoRoot: string;\n  close: () => void;\n}) {\n  const [newBranchName, setNewBranchName] = useState(branchName);\n  const [touched, setTouched] = useState(false);\n  const balloonManager = useBalloonManager();\n  const branches = useRecoilValue(repoBranchesState(repoRoot));\n  const renameBranch = useRenameBranch();\n\n  const error = validateBranchName(branches, newBranchName);\n  const validationState = error && touched ? \"invalid\" : \"valid\";\n\n  const onSubmit = (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (!error) {\n      renameBranch(branches.repoRoot, branchName, newBranchName)\n        .catch((e) => {\n          balloonManager.show({\n            icon: \"Error\",\n            title: \"Unexpected error\",\n            body: `Could not rename branch ${branchName} to ${newBranchName}.`,\n          });\n          console.error(\"Branch rename error: \", e);\n        })\n        .then(() => {\n          close();\n          // TODO: show toolwindow balloon, when/if git toolwindow is added\n        });\n    } else {\n      setTouched(true);\n    }\n  };\n  return (\n    <ModalWindow minWidth=\"content\" minHeight=\"content\">\n      <WindowLayout\n        header={`Rename branch ${branchName}`}\n        content={\n          <StyledContainer>\n            <form id=\"branch_rename_form\" onSubmit={onSubmit}>\n              <StyledInputField\n                labelPlacement=\"above\"\n                label=\"New branch name:\"\n                value={newBranchName}\n                onChange={(newValue) => {\n                  setNewBranchName(cleanUpBranchName(newValue));\n                  setTouched(true);\n                }}\n                validationState={validationState}\n                errorMessage={\n                  error && validationState === \"invalid\"\n                    ? ErrorMessages[error]?.(branchName)\n                    : undefined\n                }\n              />\n            </form>\n          </StyledContainer>\n        }\n        footer={\n          <WindowLayout.Footer\n            right={\n              <>\n                <Button onPress={close}>Cancel</Button>\n                <Button\n                  variant=\"default\"\n                  type=\"submit\"\n                  form=\"branch_rename_form\"\n                  isDisabled={Boolean(error) && touched}\n                >\n                  Rename\n                </Button>\n              </>\n            }\n          />\n        }\n      />\n    </ModalWindow>\n  );\n}\n","import path from \"path\";\nimport React, { useState } from \"react\";\nimport {\n  IconButton,\n  Toolbar,\n  ActionTooltip,\n  BalloonActionLink,\n  Bounds,\n  Divider,\n  Item,\n  ItemLayout,\n  MenuItemLayout,\n  PlatformIcon,\n  Popup,\n  PopupLayout,\n  Section,\n  SpeedSearchMenu,\n  styled,\n  TooltipTrigger,\n  useAction,\n  useBalloonManager,\n  useWindowManager,\n} from \"@intellij-platform/core\";\n\nimport { useLatestRecoilValue } from \"../../recoil-utils\";\nimport {\n  allBranchesState,\n  useCheckoutBranch,\n  useDeleteBranch,\n  useFavoriteBranches,\n} from \"./branches.state\";\nimport { notImplemented } from \"../../Project/notImplemented\";\nimport { VcsActionIds } from \"../VcsActionIds\";\nimport { atom, useRecoilState } from \"recoil\";\nimport { RenameBranchWindow } from \"./RenameBranchWindow\";\nimport { Errors } from \"isomorphic-git\";\nimport { BranchFavoriteButton } from \"./BranchFavoriteButton\";\n\nconst StyledHeader = styled.div`\n  box-sizing: border-box;\n  padding: 0 0.375rem;\n  display: flex;\n  align-items: center;\n  width: 100%;\n`;\nconst StyledTitle = styled.div`\n  flex: 1;\n  text-align: center;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  margin: 0 0.625rem;\n`;\n\nexport const branchesPopupSizeState = atom<\n  | {\n      width: number;\n      height: number;\n    }\n  | undefined\n>({\n  key: \"branchesPopup.bounds\",\n  default: undefined,\n});\n\nexport function BranchesPopup({ close }: { close: () => void }) {\n  const [repoBranches] = useLatestRecoilValue(allBranchesState);\n  const [branchesPopupPersistedSize, setBranchesPopupPersistedSize] =\n    useRecoilState(branchesPopupSizeState);\n  const [branchesPopupBounds, setBranchesPopupBounds] = useState<\n    Partial<Bounds>\n  >(branchesPopupPersistedSize ?? {});\n\n  const newBranchAction = useAction(VcsActionIds.GIT_CREATE_NEW_BRANCH);\n  const deleteBranch = useDeleteBranch();\n  const balloonManager = useBalloonManager();\n  const windowManager = useWindowManager();\n  const checkoutBranch = useCheckoutBranch();\n\n  // useRefreshRecoilValueOnMount(allBranchesState);\n\n  const { isFavorite, toggleFavorite } = useFavoriteBranches();\n\n  if (!repoBranches) {\n    return null;\n  }\n  const title =\n    repoBranches.length === 1\n      ? `Git Branches in ${path.basename(repoBranches[0].repoRoot)}`\n      : \"Git Branches\";\n  return (\n    <Popup\n      interactions=\"all\"\n      minHeight={55}\n      minWidth={300}\n      bounds={branchesPopupBounds}\n      onBoundsChange={(bounds, interactionType) => {\n        if (interactionType === \"resize\") {\n          setBranchesPopupPersistedSize({\n            width: bounds.width,\n            height: bounds.height,\n          });\n        }\n        setBranchesPopupBounds(bounds);\n      }}\n    >\n      <PopupLayout\n        header={\n          <Popup.Header hasControls>\n            <StyledHeader>\n              <StyledTitle>{title}</StyledTitle>\n              <Toolbar>\n                <TooltipTrigger tooltip={<ActionTooltip actionName=\"Fetch\" />}>\n                  <IconButton\n                    onPress={() => {\n                      notImplemented();\n                      close();\n                    }}\n                  >\n                    <PlatformIcon icon=\"vcs/fetch.svg\" />\n                  </IconButton>\n                </TooltipTrigger>\n                <TooltipTrigger\n                  tooltip={<ActionTooltip actionName=\"Restore Popup Size\" />}\n                >\n                  <IconButton\n                    isDisabled={branchesPopupPersistedSize === undefined}\n                    onPress={() => {\n                      setBranchesPopupPersistedSize(undefined);\n                      setBranchesPopupBounds(\n                        ({ width, height, ...currentBounds }) => ({\n                          ...currentBounds,\n                        })\n                      );\n                    }}\n                  >\n                    <PlatformIcon icon=\"general/fitContent.svg\" />\n                  </IconButton>\n                </TooltipTrigger>\n              </Toolbar>\n            </StyledHeader>\n          </Popup.Header>\n        }\n        content={\n          <SpeedSearchMenu\n            aria-label={title}\n            submenuBehavior=\"toggleOnPress\"\n            fillAvailableSpace\n            autoFocus=\"first\"\n            disabledKeys={repoBranches.flatMap(({ localBranches, repoRoot }) =>\n              localBranches\n                .filter(({ trackingBranch }) => !trackingBranch)\n                .map(({ name }) => `${repoRoot}/pull-${name}`)\n            )}\n            onAction={(key) => {\n              const [repoRoot, branch, operation] = `${key}`.split(\"//\");\n\n              async function tryCheckout(checkout: () => Promise<unknown>) {\n                try {\n                  await checkout();\n                  // TODO: show toolwindow balloon, when/if git toolwindow is added\n                } catch (e) {\n                  if (e instanceof Errors.CheckoutConflictError) {\n                    // TODO: open Git Checkout Problem window.\n                    balloonManager.show({\n                      icon: \"Error\",\n                      title: \"Git Checkout Problem\",\n                      body: e.message,\n                    });\n                  } else {\n                    balloonManager.show({\n                      icon: \"Error\",\n                      title: \"Checkout failed\",\n                      body: `Could not checkout branch ${branch}`,\n                    });\n                  }\n                }\n              }\n\n              function checkoutLocalBranch() {\n                return tryCheckout(() => checkoutBranch(repoRoot, branch));\n              }\n\n              function checkoutRemoteBranch() {\n                const remoteBranch = repoBranches\n                  ?.find(({ repoRoot: aRepoRoot }) => aRepoRoot === repoRoot)\n                  ?.remoteBranches.find(\n                    ({ name, remote }) => `${remote}/${name}` === branch\n                  );\n                if (remoteBranch) {\n                  return tryCheckout(() =>\n                    checkoutBranch(\n                      repoRoot,\n                      remoteBranch.name,\n                      remoteBranch.remote\n                    )\n                  );\n                }\n              }\n\n              switch (key) {\n                case newBranchAction?.id:\n                  return newBranchAction?.perform();\n                default:\n                  switch (operation) {\n                    case \"delete\":\n                      return deleteBranch(repoRoot, branch).then(\n                        () => {\n                          balloonManager.show({\n                            title: `Deleted branch: ${branch}`,\n                            icon: \"Info\",\n                            actions: (\n                              <BalloonActionLink onPress={notImplemented}>\n                                Restore\n                              </BalloonActionLink>\n                            ),\n                          });\n                        },\n                        () => {\n                          balloonManager.show({\n                            title: `Could not deleted branch: ${branch}`,\n                            icon: \"Error\",\n                          });\n                        }\n                      );\n                    case \"rename\":\n                      return windowManager.open(({ close }) => (\n                        <RenameBranchWindow\n                          repoRoot={repoRoot}\n                          branchName={branch}\n                          close={close}\n                        />\n                      ));\n                    case \"checkout\":\n                      return checkoutLocalBranch();\n                    case \"remote-checkout\":\n                      return checkoutRemoteBranch();\n                    default:\n                      return notImplemented();\n                  }\n              }\n            }}\n            onClose={close}\n          >\n            {newBranchAction && (\n              <Item key={newBranchAction.id} textValue={newBranchAction.title}>\n                <MenuItemLayout\n                  icon={newBranchAction.icon}\n                  content={newBranchAction.title}\n                />\n              </Item>\n            )}\n            <Item key=\"checkout_revision\">Checkout Tag or Revision...</Item>\n            {\n              repoBranches.flatMap(\n                ({\n                  remoteBranches,\n                  localBranches,\n                  repoRoot,\n                  currentBranch,\n                }) => {\n                  const getSectionLabel = (label: string, repoRoot: string) =>\n                    repoBranches.length > 1\n                      ? `${label} in ${path.basename(repoRoot)}`\n                      : label;\n                  const compareActions = (\n                    branchName: string,\n                    isCurrent: boolean\n                  ) => [\n                    !isCurrent && (\n                      <Item\n                        key={`${repoRoot}//${branchName}//compare-with-branch`}\n                      >{`Compare with '${branchName}'`}</Item>\n                    ),\n                    <Item\n                      key={`${repoRoot}//${branchName}//show-diff-with-working-tree`}\n                    >\n                      Show Diff with Working Tree\n                    </Item>,\n                    <Divider key=\"compare-actions-divider\" />,\n                  ];\n                  const mergeActions = (\n                    branchName: string,\n                    currentBranch: string | undefined\n                  ) =>\n                    currentBranch &&\n                    branchName !== currentBranch && [\n                      <Item\n                        key={`${repoRoot}//${branchName}//rebase-current-onto`}\n                      >{`Rebase '${currentBranch}' onto '${branchName}'`}</Item>,\n                      <Item\n                        key={`${repoRoot}//${branchName}//merge-into-current`}\n                      >{`Merge '${branchName}' onto '${currentBranch}'`}</Item>,\n                      <Divider key=\"merge-actions-divider\" />,\n                    ];\n\n                  return [\n                    <Section\n                      key={`${repoRoot}//local_branches`}\n                      title={getSectionLabel(\"Local Branches\", repoRoot)}\n                    >\n                      {localBranches.map(({ name, trackingBranch }) => {\n                        const isCurrent = name === currentBranch?.name;\n                        const favoriteBranchArgs = {\n                          branchName: name,\n                          branchType: \"LOCAL\",\n                          repoRoot,\n                        } as const;\n                        return (\n                          <Item\n                            key={`${repoRoot}//${name}`}\n                            textValue={name}\n                            title={\n                              <MenuItemLayout\n                                content={name}\n                                icon={\n                                  <BranchFavoriteButton\n                                    isFavorite={isFavorite(favoriteBranchArgs)}\n                                    isCurrent={isCurrent}\n                                    onClick={() => {\n                                      toggleFavorite(favoriteBranchArgs);\n                                    }}\n                                  />\n                                }\n                                shortcut={\n                                  trackingBranch && (\n                                    <ItemLayout.Hint small>\n                                      {trackingBranch}\n                                    </ItemLayout.Hint>\n                                  )\n                                }\n                              />\n                            }\n                          >\n                            {!isCurrent && (\n                              <Item key={`${repoRoot}//${name}//checkout`}>\n                                Checkout\n                              </Item>\n                            )}\n                            <Item\n                              key={`${repoRoot}//${name}//new-branch-from`}\n                            >{`New Branch from '${name}'...`}</Item>\n                            {!isCurrent && (\n                              <Item\n                                key={`${repoRoot}//${name}//checkout-and-rebase-onto`}\n                              >{`Checkout and rebase onto '${name}'`}</Item>\n                            )}\n                            <Divider key=\"new-branch-actions-divider\" />\n                            {compareActions(name, isCurrent)}\n                            {mergeActions(name, currentBranch?.name)}\n                            <Item key={`${repoRoot}//${name}//pull`}>\n                              Update\n                            </Item>\n                            <Item key={`${repoRoot}//${name}//push`}>\n                              Push...\n                            </Item>\n                            <Divider key=\"push-divider\" />\n                            <Item key={`${repoRoot}//${name}//rename`}>\n                              Rename...\n                            </Item>\n                            {!isCurrent && (\n                              <Item key={`${repoRoot}//${name}//delete`}>\n                                Delete\n                              </Item>\n                            )}\n                          </Item>\n                        );\n                      })}\n                    </Section>,\n                    <Section\n                      key={`${repoRoot}//remote_branches`}\n                      title={getSectionLabel(\"Remote Branches\", repoRoot)}\n                    >\n                      {remoteBranches.map((branch) => {\n                        const branchName = `${branch.remote}/${branch.name}`;\n                        const favoriteBranchArgs = {\n                          branchName,\n                          branchType: \"REMOTE\",\n                          repoRoot,\n                        } as const;\n                        return (\n                          <Item\n                            key={`${repoRoot}//${branchName}`}\n                            textValue={branchName}\n                            title={\n                              <MenuItemLayout\n                                content={branchName}\n                                icon={\n                                  <BranchFavoriteButton\n                                    isFavorite={isFavorite(favoriteBranchArgs)}\n                                    onClick={() => {\n                                      toggleFavorite(favoriteBranchArgs);\n                                    }}\n                                  />\n                                }\n                              />\n                            }\n                          >\n                            <Item\n                              key={`${repoRoot}//${branchName}//remote-checkout`}\n                            >\n                              Checkout\n                            </Item>\n                            <Item\n                              key={`${repoRoot}//${branchName}//new-branch-from`}\n                            >{`New Branch from '${branchName}'...`}</Item>\n                            <Item\n                              key={`${repoRoot}//${branchName}//checkout-and-rebase-onto`}\n                            >{`Checkout and rebase onto '${branchName}'`}</Item>\n                            <Divider key=\"new-branch-actions-divider\" />\n                            {compareActions(branchName, false)}\n                            {mergeActions(branchName, currentBranch?.name)}\n                            <Item\n                              key={`${repoRoot}//${branchName}//pull-into-using-merge`}\n                            >{`Pull into '${branchName}' Using Merge`}</Item>\n                            <Item\n                              key={`${repoRoot}//${branchName}//pull-into-using-rebase`}\n                            >{`Pull into '${branchName}' Using Rebase`}</Item>\n                            <Divider />\n                            <Item key={`${repoRoot}//${branchName}//delete`}>\n                              Delete\n                            </Item>\n                          </Item>\n                        );\n                      })}\n                    </Section>,\n                  ];\n                }\n              ) as any\n            }\n          </SpeedSearchMenu>\n        }\n      />\n    </Popup>\n  );\n}\n","import React, { Key, useRef, useState } from \"react\";\nimport { useRecoilState, useRecoilValue, useSetRecoilState } from \"recoil\";\nimport { Selection } from \"@react-types/shared\";\nimport {\n  IconButton,\n  IconButtonWithMenu,\n  ActionsProvider,\n  Toolbar,\n  Button,\n  Checkbox,\n  CommonActionId,\n  ContextMenuContainer,\n  Item,\n  Menu,\n  ModalWindow,\n  PlatformIcon,\n  Section,\n  SpeedSearchTreeWithCheckboxes,\n  styled,\n  TreeNodeCheckbox,\n  TreeRefValue,\n  useBalloonManager,\n  useNestedSelectionState,\n  useTreeActions,\n  WindowLayout,\n  ActionButton,\n} from \"@intellij-platform/core\";\n\nimport {\n  changesTreeNodesState,\n  ChangesViewTreeNode,\n} from \"../ChangesView/ChangesView.state\";\nimport { rollbackViewState } from \"./rollbackView.state\";\nimport { ChangesSummary } from \"../ChangesSummary\";\nimport { defaultChangeGroupings } from \"../ChangesTree/changesGroupings\";\nimport { RollbackTreeContextMenu } from \"./RollbackTreeContextMenu\";\nimport { notImplemented } from \"../../../Project/notImplemented\";\nimport {\n  getNodeKeyForChange,\n  isGroupNode,\n} from \"../ChangesTree/ChangeTreeNode\";\nimport { changesViewTreeNodeRenderer } from \"../ChangesView/changesViewTreeNodeRenderer\";\nimport { Change } from \"../Change\";\nimport { allChangesState, useRollbackChanges } from \"../changes.state\";\n\nconst StyledContainer = styled.div`\n  box-sizing: border-box;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  padding: 1rem 0.75rem 0;\n`;\nconst StyledFrame = styled.div`\n  border: 1px solid ${({ theme }) => theme.commonColors.contrastBorder};\n  flex: 1;\n  overflow: auto;\n`;\n\nconst StyledLine = styled.div`\n  line-height: 2;\n  padding-left: 0.5rem;\n`;\n\nexport function RollbackWindow() {\n  const defaultExpandedKeys = useRecoilValue(\n    rollbackViewState.initiallyExpandedKeys\n  );\n  const initiallyIncludedChangeKeys = useRecoilValue(\n    rollbackViewState.initiallyIncludedChanges\n  ).map(getNodeKeyForChange);\n  const { fileCountsMap } = useRecoilValue(changesTreeNodesState);\n  const [windowBounds, setWindowBounds] = useRecoilState(\n    rollbackViewState.windowBounds\n  );\n  const rootNodes = useRecoilValue(rollbackViewState.rootNodes);\n  const [selectedKeys, setSelectedKeys] = useState<Selection>(\n    new Set<Key>(initiallyIncludedChangeKeys.slice(0, 1))\n  );\n  const [expandedKeys, setExpandedKeys] =\n    useState<Set<Key>>(defaultExpandedKeys);\n  const [includedChangeKeys, setIncludedChangeKeys] = useState(\n    new Set<Key>(initiallyIncludedChangeKeys)\n  );\n  const nestedSelection = useNestedSelectionState<ChangesViewTreeNode>(\n    {\n      rootNodes,\n      getKey: (node) => node.key,\n      getChildren: (node) => (isGroupNode(node) ? node.children : null),\n    },\n    {\n      selectedKeys: includedChangeKeys,\n      onSelectedKeysChange: setIncludedChangeKeys,\n    }\n  );\n  const allChanges = useRecoilValue(allChangesState);\n  const includedChanges = allChanges.filter((change) =>\n    includedChangeKeys.has(getNodeKeyForChange(change))\n  );\n  const rollbackChanges = useRollbackChanges();\n  const balloons = useBalloonManager();\n  const setOpen = useSetRecoilState(rollbackViewState.isOpen);\n  const close = () => setOpen(false);\n\n  const treeRef = useRef<TreeRefValue>(null);\n  const treeActions = useTreeActions({ treeRef });\n  const [deleteAddedFiles, setDeleteAddedFiles] = useState(false);\n\n  const atLeastOneNewFileSelected = includedChanges.some(\n    (change) => change.type === \"ADDED\"\n  );\n\n  return (\n    <ModalWindow\n      onClose={close}\n      bounds={windowBounds}\n      onBoundsChange={setWindowBounds}\n      minHeight={200}\n      minWidth={275}\n    >\n      <WindowLayout\n        header=\"Rollback changes\"\n        content={\n          <ActionsProvider actions={treeActions}>\n            {({ shortcutHandlerProps }) => (\n              <StyledContainer {...shortcutHandlerProps}>\n                <div style={{ display: \"flex\" }}>\n                  <Toolbar>\n                    <IconButton isDisabled>\n                      <PlatformIcon icon=\"actions/diff\" />\n                    </IconButton>\n                    <IconButtonWithMenu\n                      renderMenu={({ menuProps }) => (\n                        <Menu\n                          {...menuProps}\n                          selectedKeys={[] /* FIXME */}\n                          // FIXME\n                          onAction={notImplemented}\n                        >\n                          <Section title=\"Group By\">\n                            {\n                              // FIXME\n                              defaultChangeGroupings.map((grouping) => (\n                                <Item key={grouping.id}>{grouping.title}</Item>\n                              ))\n                            }\n                          </Section>\n                        </Menu>\n                      )}\n                    >\n                      <PlatformIcon icon=\"actions/groupBy.svg\" />\n                    </IconButtonWithMenu>\n                  </Toolbar>\n                  <span style={{ flex: 1 }} />\n                  <Toolbar>\n                    <ActionButton actionId={CommonActionId.EXPAND_ALL} />\n                    <ActionButton actionId={CommonActionId.COLLAPSE_ALL} />\n                  </Toolbar>\n                </div>\n\n                <StyledFrame>\n                  <ContextMenuContainer\n                    renderMenu={() => <RollbackTreeContextMenu />}\n                    style={{ height: \"100%\" }}\n                  >\n                    <SpeedSearchTreeWithCheckboxes\n                      treeRef={treeRef}\n                      items={rootNodes}\n                      selectionMode=\"multiple\"\n                      selectedKeys={selectedKeys}\n                      onSelectionChange={setSelectedKeys}\n                      expandedKeys={expandedKeys}\n                      onExpandedChange={setExpandedKeys}\n                      nestedSelection={nestedSelection}\n                      fillAvailableSpace\n                    >\n                      {(node) => {\n                        const props = changesViewTreeNodeRenderer.getItemProps({\n                          node,\n                          fileCountsMap,\n                        });\n                        return (\n                          <Item {...props}>\n                            {node.children?.length !== 0 && (\n                              <TreeNodeCheckbox\n                                selectionState={nestedSelection.getSelectionState(\n                                  node\n                                )}\n                                onToggle={() => nestedSelection.toggle(node)}\n                              />\n                            )}\n                            {props.children}\n                          </Item>\n                        );\n                      }}\n                    </SpeedSearchTreeWithCheckboxes>\n                  </ContextMenuContainer>\n                </StyledFrame>\n              </StyledContainer>\n            )}\n          </ActionsProvider>\n        }\n        footer={\n          <>\n            <div\n              style={{\n                padding: \"0 .75rem\",\n                display: \"flex\",\n                flexDirection: \"column\",\n              }}\n            >\n              <StyledLine>\n                <ChangesSummary changes={includedChanges} />\n              </StyledLine>\n              <Checkbox\n                isDisabled={!atLeastOneNewFileSelected}\n                isSelected={deleteAddedFiles}\n                onChange={setDeleteAddedFiles}\n              >\n                Delete local copies of the added files\n              </Checkbox>\n            </div>\n            <WindowLayout.Footer\n              right={\n                <>\n                  <Button onPress={close}>Cancel</Button>\n                  <Button\n                    variant=\"default\"\n                    onPress={() => {\n                      rollbackChanges(includedChanges, deleteAddedFiles)\n                        .catch((e) => {\n                          balloons.show({\n                            title: \"Reverting changes failed\",\n                            icon: \"Error\",\n                            body: \"Could not revert selected changes. See console for more info\",\n                          });\n                          console.error(\"Git revert error:\", e);\n                        })\n                        .finally(close);\n                    }}\n                  >\n                    Rollback\n                  </Button>\n                </>\n              }\n            />\n          </>\n        }\n      />\n    </ModalWindow>\n  );\n}\n","import { ItemLayout, styled } from \"@intellij-platform/core\";\n\nexport const StyledIconWrapper = styled.span`\n  width: 0.9375rem;\n  margin-right: 0.25rem;\n  display: inline-flex;\n  justify-content: center;\n`;\nexport const StyledItemLayout = styled(ItemLayout)`\n  min-height: 1.375rem;\n  width: 100%;\n  padding: 0;\n`;\nexport const StyledTitleWrapper = styled.span<{ isDisabled?: boolean }>`\n  color: ${({ theme, isDisabled }) =>\n    isDisabled &&\n    theme.currentForegroundAware(theme.commonColors.inactiveTextColor)};\n`;\n","import React, { useContext } from \"react\";\nimport {\n  Action,\n  ActionGroup,\n  ItemLayout,\n  ItemStateContext,\n  TextRange,\n  TextWithHighlights,\n  isInResolvedActionGroup,\n  styled,\n} from \"@intellij-platform/core\";\nimport {\n  StyledIconWrapper,\n  StyledItemLayout,\n  StyledTitleWrapper,\n} from \"../ItemHelpers\";\n\nconst StyledSpacer = styled.div`\n  flex: 1;\n`;\n/**\n * UI of actions in SearchEverywhere list\n */\nexport function ActionItem({\n  action,\n  highlights,\n}: {\n  action: Action;\n  highlights: null | TextRange[];\n}) {\n  const { isSelected } = useContext(ItemStateContext) || {};\n  return (\n    <StyledItemLayout>\n      <StyledIconWrapper>{action.icon}</StyledIconWrapper>\n      <StyledTitleWrapper isDisabled={action.isDisabled}>\n        {isSelected ? (\n          <TextWithHighlights highlights={highlights}>\n            {action.title}\n          </TextWithHighlights>\n        ) : (\n          action.title\n        )}\n      </StyledTitleWrapper>\n      <ItemLayout.Hint style={{ fontSize: \".85em\", fontWeight: \"bold\" }}>\n        {action.shortcut}\n      </ItemLayout.Hint>\n      <StyledSpacer />\n      <ItemLayout.Hint\n        style={{\n          marginRight:\n            \"-0.375rem\" /* to kill the default list padding on right. */,\n        }}\n      >\n        {getActionBreadcrumb(action, \"title\").join(\" | \")}\n      </ItemLayout.Hint>\n    </StyledItemLayout>\n  );\n}\n\nfunction getActionBreadcrumb<T extends keyof ActionGroup>(\n  action: Action,\n  field: T\n): Array<ActionGroup[T]>;\nfunction getActionBreadcrumb(action: Action): Array<ActionGroup>;\nfunction getActionBreadcrumb(action: Action, field?: keyof ActionGroup) {\n  let parent = isInResolvedActionGroup(action) ? action.parent : null;\n  const breadcrumb: Array<ActionGroup | ActionGroup[keyof ActionGroup]> = [];\n  while (parent) {\n    breadcrumb.unshift(field ? parent[field] : parent);\n    parent = parent.parent;\n  }\n  return breadcrumb;\n}\n","import React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport { useRecoilState, useSetRecoilState } from \"recoil\";\nimport {\n  IconButton,\n  ActionDefinition,\n  ActionsProvider,\n  FocusScope,\n  Item,\n  Link,\n  List,\n  PlatformIcon,\n  Popup,\n  Selection,\n  SelectionManager,\n  styled,\n  StyledTabProps,\n  Tabs,\n  Tooltip,\n  TooltipTrigger,\n  useCollectionSearchInput,\n  useGetActionShortcut,\n} from \"@intellij-platform/core\";\nimport { useTips } from \"./useTips\";\nimport { Input } from \"./Input\";\nimport {\n  searchEverywhereState,\n  SearchEveryWhereTab,\n} from \"./searchEverywhere.state\";\nimport { ContentAwarePopup } from \"./ContentAwarePopup\";\nimport {\n  SearchEverywhereContributor,\n  SearchEverywhereContributorResult,\n} from \"./SearchEverywhereContributor\";\nimport { actionsSearchContributor } from \"./contributors/action/actionsSearchContributor\";\nimport { filesSearchContributor } from \"./contributors/file/filesSearchContributor\";\nimport { SearchEverywhereActionIds } from \"./SearchEverywhereActionIds\";\nimport { useRecoilInitialValue } from \"../recoil-utils\";\n\nconst StyledHeader = styled.div`\n  display: flex;\n  width: 100%;\n  background: ${({ theme }) =>\n    theme.color(\"SearchEverywhere.Header.background\")};\n  border-bottom: 1px solid\n    ${({ theme }) => theme.color(\"SearchEverywhere.SearchField.borderColor\")};\n`;\nconst StyledTab = styled.button<StyledTabProps>`\n  all: unset;\n  background: ${({ theme, selected }) =>\n    selected && theme.color(\"SearchEverywhere.Tab.selectedBackground\")};\n  color: ${({ theme }) =>\n    theme.color(\"SearchEverywhere.Tab.selectedForeground\")};\n  opacity: ${({ disabled }) => disabled && \".5\"};\n`;\nconst StyledTabContent = styled.span`\n  display: flex;\n  padding: 0 0.75rem;\n  height: 1.8rem;\n  align-items: center;\n`;\nconst StyledTabs = styled.div`\n  line-height: normal;\n  border-bottom: none;\n`;\nconst StyledSearchFieldContainer = styled.div`\n  display: flex;\n  flex-shrink: 0;\n  height: 1.85rem;\n  align-items: center;\n  padding: 0 0.75rem 0;\n  gap: 0.75rem;\n\n  input {\n    all: unset;\n    flex: 1;\n    line-height: 1.25;\n\n    &::selection {\n      color: ${({ theme }) => theme.color(\"*.selectionForeground\")};\n      background: ${({ theme }) => theme.color(\"*.selectionBackground\")};\n    }\n  }\n`;\nconst StyledSearchResultsContainer = styled.div`\n  height: 24rem;\n  flex: 1;\n  min-height: 0; // for it to properly fill the remaining height and not to exceed that\n`;\nconst StyledDivider = styled.hr`\n  all: unset;\n  height: 1px;\n  width: 100%;\n  border-bottom: 1px solid\n    ${({ theme }) => theme.color(\"SearchEverywhere.SearchField.borderColor\")};\n`;\nconst StyledSearchFieldHint = styled.div`\n  color: ${({ theme }) =>\n    theme.color(\"SearchEverywhere.SearchField.infoForeground\")};\n  white-space: nowrap;\n`;\n\nconst StyledLoadMore = styled.div`\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(\n      theme.color(\"SearchEverywhere.SearchField.infoForeground\")\n    )};\n  font-size: 0.7rem;\n  min-height: 1.375rem;\n`;\n\nconst StyledPlaceholder = styled.div`\n  color: ${({ theme }) => theme.commonColors.inactiveTextColor};\n  position: absolute;\n  text-align: center;\n  width: 100%;\n  top: 50%;\n`;\nconst SEARCH_RESULT_LIMIT = 30;\n\nconst contributors = [actionsSearchContributor, filesSearchContributor];\n\nconst LOAD_MORE_ITEM = {};\nconst LOAD_MORE_ITEM_KEY = \"LOAD_MORE_ITEM_KEY\";\n\n/**\n * TODO: implement history navigation\n */\nexport function SearchEverywherePopup() {\n  const setOpen = useSetRecoilState(searchEverywhereState.isOpen);\n  const [tab, setTab] = useRecoilState(searchEverywhereState.tab);\n  const [everyWhereAutoSet, setEveryWhereAutoSet] = useState(false);\n  const [pattern, setPattern] = useState(\n    useRecoilInitialValue(searchEverywhereState.initialSearchQuery(tab))\n  );\n  const persistInitialSearchQuery = useSetRecoilState(\n    searchEverywhereState.initialSearchQuery(tab)\n  );\n\n  const getShortcut = useGetActionShortcut();\n  const [selectedKeys, setSelectedKeys] = useState<Selection>(new Set());\n  const idToContributor: Record<\n    string,\n    SearchEverywhereContributorResult<{}> &\n      Omit<SearchEverywhereContributor<{}>, \"use\">\n  > = {};\n  contributors.forEach((contributor) => {\n    idToContributor[contributor.id] = {\n      ...contributor,\n      ...contributor.use({ everyWhereAutoSet }),\n    };\n  });\n\n  const activeContributors = contributors\n    .filter((contributor) => tab === \"\" || contributor.id === tab)\n    .map(({ id }) => idToContributor[id]);\n\n  const [searchResultLimit, setSearchResultLimit] =\n    useState(SEARCH_RESULT_LIMIT);\n  const { searchResult } = useMemo(() => {\n    // TODO: sort results\n    const searchResult = activeContributors.flatMap((contributor) =>\n      contributor.search(pattern).map((item) => ({\n        key: `${contributor.id}_${contributor.getKey(item)}`,\n        contributor,\n        item,\n      }))\n    );\n    return {\n      searchResult,\n    };\n  }, [\n    pattern,\n    tab,\n    ...activeContributors.flatMap(({ searchDeps }) => searchDeps),\n  ]);\n  const currentTabContributor = idToContributor[tab];\n\n  const visibleSearchResult = useMemo(() => {\n    const visibleSearchResult = searchResult.slice(0, searchResultLimit);\n    const hasMore = searchResult.length > visibleSearchResult.length;\n    if (hasMore) {\n      visibleSearchResult.push({\n        key: LOAD_MORE_ITEM_KEY,\n        item: LOAD_MORE_ITEM,\n        contributor: null!,\n      });\n    }\n    return visibleSearchResult;\n  }, [searchResultLimit, searchResult]);\n\n  const notFoundPatternRef = useRef<string | null>(null);\n\n  const onPatternChanged = (newPattern: string) => {\n    const newPatternContainsPrevious =\n      notFoundPatternRef.current &&\n      newPattern.includes(notFoundPatternRef.current);\n    // TODO: improve isEverywhere support. It should be supported it in \"All\" tabs too.\n    if (currentTabContributor?.isEverywhere && !newPatternContainsPrevious) {\n      setEveryWhereAutoSet(false);\n    }\n    setPattern(newPattern);\n  };\n\n  useEffect(() => {\n    if (pattern) {\n      persistInitialSearchQuery(pattern);\n    }\n  }, [pattern, tab]);\n\n  useEffect(() => {\n    if (searchResult[0]) {\n      // Currently, list auto selects the first item, only in first render. But not when the collection is changed.\n      // So we make sure the first item is selected, after each search. Perhaps, List should be changed instead to\n      // react to collection changes.\n      const { key } = searchResult[0];\n      setSelectedKeys(new Set([key]));\n      selectionManagerRef.current?.setFocusedKey(key);\n\n      // A workaround for a mysterious issue that happens only in docusaurus build.\n      // The ref value is not up-to-date, when the effect runs.\n      // FIXME: Find the explanation for why it happens, and fix it properly, if it's a legit issue.\n      requestAnimationFrame(() => {\n        selectionManagerRef.current?.setFocusedKey(key);\n      });\n    }\n    setSearchResultLimit(SEARCH_RESULT_LIMIT);\n  }, [searchResult]);\n\n  const localActions: ActionDefinition[] = [\n    {\n      id: SearchEverywhereActionIds.PREVIOUS_TAB,\n      title: \"Prev tab\",\n      description: \"Switch to previous tab in Search Everywhere dialog\",\n      actionPerformed: () => {\n        const currentContributorIndex = contributors.findIndex(\n          ({ id }) => tab === id\n        );\n\n        setTab(\n          tab === \"\"\n            ? contributors.slice(-1)[0].id\n            : contributors[currentContributorIndex - 1]?.id || \"\"\n        );\n      },\n    },\n    {\n      id: SearchEverywhereActionIds.NEXT_TAB,\n      title: \"Next tab\",\n      description: \"Switch to next tab in Search Everywhere dialog\",\n      actionPerformed: () => {\n        const currentContributorIndex = contributors.findIndex(\n          ({ id }) => tab === id\n        );\n        setTab(contributors[currentContributorIndex + 1]?.id || \"\");\n      },\n    },\n  ];\n  const contributorActions = contributors.flatMap(({ id, actionId, title }) => {\n    return actionId\n      ? [\n          {\n            id: actionId,\n            title: `Find ${title}`,\n            description: `Quickly go to ${title} by name`,\n            actionPerformed: () => {\n              if (tab !== id) {\n                setTab(id);\n              } else {\n                currentTabContributor?.toggleEverywhere?.();\n              }\n            },\n          },\n        ]\n      : [];\n  });\n\n  const close = () => setOpen(false);\n\n  const collectionRef = useRef<HTMLDivElement>(null);\n  const selectionManagerRef = useRef<SelectionManager>(null);\n  const { collectionSearchInputProps } = useCollectionSearchInput({\n    collectionRef,\n    selectionManager: selectionManagerRef.current,\n  });\n\n  const tips = useTips();\n\n  return (\n    <ContentAwarePopup\n      persistedBoundsState={searchEverywhereState.bounds}\n      hasContent={Boolean(pattern)}\n      noContentHeight={59}\n      minWidth={670}\n      minHeight={160}\n      interactions=\"all\"\n      onClose={close}\n    >\n      <ActionsProvider\n        actions={[\n          ...(currentTabContributor?.actions || []),\n          ...contributorActions,\n          ...localActions,\n        ]}\n      >\n        {({ shortcutHandlerProps }) => (\n          <div {...shortcutHandlerProps} style={{ height: \"inherit\" }}>\n            <Popup.Layout\n              header={\n                <>\n                  <Popup.Header hasControls>\n                    <StyledHeader>\n                      <div style={{ flex: 1 }}>\n                        <Tabs\n                          TabComponent={StyledTab}\n                          TabsComponent={StyledTabs}\n                          selectedKey={tab}\n                          onSelectionChange={(key) =>\n                            setTab(key as SearchEveryWhereTab)\n                          }\n                        >\n                          <Item key=\"\">\n                            <StyledTabContent>All</StyledTabContent>\n                          </Item>\n                          {\n                            contributors.map((contributor) => {\n                              const shortcut = getShortcut(\n                                contributor.actionId\n                              );\n                              const title = (\n                                <StyledTabContent>\n                                  {contributor.title}\n                                </StyledTabContent>\n                              );\n                              return (\n                                <Item key={contributor.id}>\n                                  {shortcut ? (\n                                    <TooltipTrigger\n                                      tooltip={<Tooltip>{shortcut}</Tooltip>}\n                                    >\n                                      {/* Span needed for tooltip to work, in the current implementation of tooltip */}\n                                      <span>{title}</span>\n                                    </TooltipTrigger>\n                                  ) : (\n                                    title\n                                  )}\n                                </Item>\n                              );\n                            }) as any /*when a static Item is rendered before this array, it wrongly complains about the type*/\n                          }\n                        </Tabs>\n                      </div>\n                      {currentTabContributor?.headerFilters}\n                      <IconButton style={{ margin: \"0 0.5rem\" }} isDisabled>\n                        <PlatformIcon icon=\"actions/moveToLeftBottom\" />\n                      </IconButton>\n                    </StyledHeader>\n                  </Popup.Header>\n                  <StyledSearchFieldContainer>\n                    <PlatformIcon icon=\"actions/search\" />\n                    <FocusScope contain>\n                      <Input\n                        {...collectionSearchInputProps}\n                        autoFocus\n                        onFocus={(event) => {\n                          event.target.select();\n                        }}\n                        value={pattern}\n                        onChange={(e) =>\n                          onPatternChanged(e.currentTarget.value)\n                        }\n                      />\n                    </FocusScope>\n                    <StyledSearchFieldHint>\n                      {currentTabContributor?.searchAdvertiser}\n                    </StyledSearchFieldHint>\n                  </StyledSearchFieldContainer>\n                </>\n              }\n              content={\n                <>\n                  <StyledDivider />\n                  {pattern && (\n                    <StyledSearchResultsContainer>\n                      <List\n                        ref={collectionRef}\n                        selectionManagerRef={selectionManagerRef}\n                        items={visibleSearchResult}\n                        selectionMode=\"single\"\n                        showAsFocused\n                        shouldFocusWrap\n                        fillAvailableSpace\n                        selectedKeys={selectedKeys}\n                        onSelectionChange={setSelectedKeys}\n                        onAction={(key) => {\n                          if (key === LOAD_MORE_ITEM_KEY) {\n                            setSearchResultLimit(\n                              (limit) => limit + SEARCH_RESULT_LIMIT\n                            );\n                            const nextItem =\n                              searchResult[visibleSearchResult.length + 1];\n                            if (nextItem) {\n                              // nextItem is expected to always have value\n\n                              // Timeout needed to let the item get rendered first. Could be done in an effect instead,\n                              // if we want to avoid setTimeout\n                              setTimeout(() => {\n                                setSelectedKeys(new Set([nextItem.key]));\n                                selectionManagerRef.current?.setFocusedKey(\n                                  nextItem.key\n                                );\n                              });\n                            }\n                          } else {\n                            close();\n                            // Making sure the popup is fully closed before the new action is performed. One edge case that can\n                            // make a difference is actions like FindAction that open the same popup. By performing an action\n                            // async, we make sure the popup is closed and reopened, which is good, because otherwise, the user\n                            // won't get any feedback when choosing such actions.\n                            setTimeout(() => {\n                              const itemWrapper = searchResult.find(\n                                (item) => item.key === key\n                              );\n                              itemWrapper?.contributor.processSelectedItem(\n                                itemWrapper.item\n                              );\n                              /**\n                               * The 50ms timeout is a workaround for an issue in FocusScope:\n                               * restoreFocus only works if the previously focused element is in the dom, when the focus\n                               * scope is unmounted. In case of SearchEveryWhere, actions like \"Rollback\" open a modal\n                               * window, which has a focus scope, when the window is opened, the currently focused\n                               * element (which will be the one to restore focus to), is search everywhere dialog, which\n                               * is immediately closed. So when the modal window is closed, it tries to move focus back\n                               * to search everywhere dialog, which is long gone! It would be nice if FocusScope could\n                               * track a chain of nodes to restore focus to.\n                               * With this 50ms timeout, focus is first restored to where it was, after SearchEveryWhere\n                               * is closed, and then the actions is performed, for focus restoration to work.\n                               */\n                            }, 50);\n                          }\n                        }}\n                      >\n                        {({ key, item, contributor }) => {\n                          if (key === LOAD_MORE_ITEM_KEY) {\n                            return (\n                              <Item key={LOAD_MORE_ITEM_KEY}>\n                                <StyledLoadMore>...more</StyledLoadMore>\n                              </Item>\n                            );\n                          }\n                          return (\n                            <Item\n                              key={key}\n                              textValue={contributor.getItemText(item)}\n                            >\n                              {contributor.renderItem(item)}\n                            </Item>\n                          );\n                        }}\n                      </List>\n                      {searchResult.length === 0 && (\n                        <StyledPlaceholder>\n                          No actions with such name found\n                        </StyledPlaceholder>\n                      )}\n                    </StyledSearchResultsContainer>\n                  )}\n                </>\n              }\n              footer={\n                <Popup.Hint>\n                  {tips.current} <Link onPress={tips.next}>Next Tip</Link>\n                </Popup.Hint>\n              }\n            />\n          </div>\n        )}\n      </ActionsProvider>\n    </ContentAwarePopup>\n  );\n}\n","import path from \"path\";\nimport { selector, useRecoilCallback } from \"recoil\";\nimport React, { ChangeEvent, useState } from \"react\";\nimport {\n  ActionDefinition,\n  Button,\n  Checkbox,\n  Input,\n  ModalWindow,\n  PlatformIcon,\n  Popup,\n  PopupLayout,\n  PositionedTooltipTrigger,\n  styled,\n  ValidationTooltip,\n  WindowLayout,\n} from \"@intellij-platform/core\";\n\nimport { fs } from \"../../fs/fs\";\nimport { editorManagerState } from \"../../Editor/editor.state\";\nimport {\n  activePathExistsState,\n  activePathsState,\n  projectPopupManagerRefState,\n  windowManagerRefState,\n} from \"../project.state\";\nimport { vcsRootForFile } from \"../../VersionControl/file-status.state\";\nimport { createFileCallback } from \"../fs-operations\";\nimport { gitAddCallback } from \"../../VersionControl/gitAddCallback\";\n\n// TODO: expand to and select the new file in the project tree, if the action is initiated from projects view.\nexport const createFileActionState = selector({\n  key: \"action.NewFile\",\n  get: ({ get, getCallback }): ActionDefinition => ({\n    id: \"NewFile\",\n    icon: <PlatformIcon icon=\"fileTypes/text\" />,\n    title: \"File\",\n    description: \"Create new file\",\n    isDisabled: !get(activePathExistsState),\n    actionPerformed: getCallback(({ snapshot, refresh }) => async () => {\n      const activePaths = snapshot.getLoadable(activePathsState).getValue();\n      if (activePaths.length === 0) {\n        return;\n      }\n      const popupManager = snapshot\n        .getLoadable(projectPopupManagerRefState)\n        .getValue().current;\n\n      // TODO: open a dialog and let the user choose the destination\n      const destinationDir = (\n        await fs.promises.stat(activePaths[0])\n      ).isDirectory()\n        ? activePaths[0]\n        : path.dirname(activePaths[0]);\n\n      if (!popupManager) {\n        throw new Error(\"Could not find popup manager\");\n      }\n\n      popupManager.show(({ close }) => (\n        <NewFileNamePopup close={close} destinationDir={destinationDir} />\n      ));\n    }),\n  }),\n});\n\nconst StyledInput = styled(Input)`\n  width: 20.5rem;\n  /**\n   * To have the validation box shadow not clipped by the popup.\n   * Maybe it should be an option on input to make sure margin is always in sync with the box-shadow thickness\n   */\n  margin: 3px;\n  input {\n    padding-top: 1px;\n    padding-bottom: 1px;\n  }\n`;\n\nconst StyledHeader = styled(Popup.Header)`\n  border-bottom: 1px solid ${({ theme }) => theme.commonColors.border()};\n`;\n\nfunction NewFileNamePopup({\n  destinationDir,\n  close,\n}: {\n  close: () => void;\n  destinationDir: string;\n}) {\n  const createFile = useRecoilCallback(\n    (callbackInterface) => {\n      const createFile = createFileCallback(callbackInterface);\n      return async (filePath: string) => {\n        const { snapshot } = callbackInterface;\n        const editorManager = snapshot\n          .getLoadable(editorManagerState)\n          .getValue();\n        const windowManager = snapshot\n          .getLoadable(windowManagerRefState)\n          .getValue().current;\n        const repoDir = await snapshot.getPromise(vcsRootForFile(filePath));\n        await createFile(filePath);\n        // TODO: select it in the Project tool window, if it was created from the Project tool window\n        close();\n        editorManager.focus();\n        if (repoDir) {\n          windowManager?.open(({ close }) => (\n            <AddFileToGitWindow filepath={filePath} close={close} />\n          ));\n        }\n      };\n    },\n    [close]\n  );\n  const [filename, setFilename] = useState(\"\");\n  const [errorMessage, setErrorMessage] = useState(\"\");\n  const [validationState, setValidationState] = useState<\"valid\" | \"invalid\">(\n    \"valid\"\n  );\n  const submit = async () => {\n    const fullPath = path.join(destinationDir, filename);\n    const exists = await fs.promises.exists(fullPath);\n    if (exists) {\n      const stats = await fs.promises.stat(fullPath);\n      setValidationState(\"invalid\");\n      if (stats.isFile()) {\n        setErrorMessage(\n          `A file with the name '${path.basename(filename)}' already exists`\n        );\n      } else if (stats.isDirectory()) {\n        setErrorMessage(\n          `A directory with the name '${path.basename(\n            filename\n          )}' already exists`\n        );\n      }\n    } else {\n      await createFile(fullPath);\n    }\n  };\n\n  return (\n    <Popup>\n      <PopupLayout\n        header={<StyledHeader>New File</StyledHeader>}\n        content={\n          <form\n            onSubmit={(e) => {\n              e.preventDefault();\n              if (filename) {\n                submit(); // error handling?\n              }\n            }}\n            onMouseDown={() => {\n              setErrorMessage(\"\");\n            }}\n          >\n            <PositionedTooltipTrigger\n              isOpen={Boolean(errorMessage)}\n              placement=\"top\"\n              offset={6}\n              tooltip={\n                <ValidationTooltip type=\"error\">\n                  {errorMessage}\n                </ValidationTooltip>\n              }\n            >\n              <StyledInput\n                appearance=\"embedded\"\n                validationState={validationState}\n                placeholder=\"Name\"\n                value={filename}\n                onChange={(e: ChangeEvent<HTMLInputElement>) => {\n                  setValidationState(\"valid\");\n                  setErrorMessage(\"\");\n                  setFilename(e.target.value);\n                }}\n              />\n            </PositionedTooltipTrigger>\n          </form>\n        }\n      />\n    </Popup>\n  );\n}\n\nfunction useAddToGit() {\n  return useRecoilCallback(gitAddCallback, []);\n}\n\nfunction AddFileToGitWindow({\n  close,\n  filepath,\n}: {\n  close: () => void;\n  filepath: string;\n}) {\n  const addToGit = useAddToGit();\n  return (\n    <ModalWindow minWidth=\"content\" minHeight=\"content\">\n      <WindowLayout\n        header=\"Add File to Git\"\n        content={\n          <>\n            <div\n              style={{\n                display: \"flex\",\n                gap: \"1rem\",\n                padding: \"0.75rem 0.75rem 0rem\",\n              }}\n            >\n              <PlatformIcon icon=\"general/questionDialog.svg\" size={32} />\n              <div>\n                Do you want to add the following file to Git?\n                <br />\n                {filepath}\n                <br />\n                <br />\n                If you choose Cancel, you can still add it later manually.\n              </div>\n            </div>\n          </>\n        }\n        footer={\n          <WindowLayout.Footer\n            left={<Checkbox isDisabled>Don't ask again</Checkbox>}\n            right={\n              <>\n                <Button onPress={close}>Cancel</Button>\n                <Button\n                  autoFocus\n                  variant=\"default\"\n                  onPress={() => {\n                    addToGit(filepath).then(close);\n                  }}\n                >\n                  Add\n                </Button>\n              </>\n            }\n          />\n        }\n      />\n    </ModalWindow>\n  );\n}\n","import {\n  Button,\n  Checkbox,\n  InputField,\n  ModalWindow,\n  styled,\n  useBalloonManager,\n  WindowLayout,\n} from \"@intellij-platform/core\";\nimport React, { FormEvent, ReactNode, useState } from \"react\";\nimport { useRecoilValue } from \"recoil\";\nimport { activeFileRepoBranchesState } from \"../active-file.state\";\nimport { useCreateBranch } from \"./branches.state\";\nimport { Errors } from \"isomorphic-git\";\nimport {\n  BranchNameError,\n  cleanUpBranchName,\n  validateBranchName,\n} from \"./branch-name-utils\";\n\nconst StyledContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  padding: 1rem 0.875rem 0.25rem;\n  gap: 0.6rem;\n`;\nconst StyledCheckboxesContainer = styled.div`\n  margin-left: -0.25rem; // to align with the field. Maybe something to look into in checkbox.\n  display: flex;\n  gap: 0.75rem;\n`;\n\nconst ErrorMessages: Record<\n  BranchNameError,\n  (branchName: string) => ReactNode\n> = {\n  EXISTING: (branchName: string) => (\n    <>\n      Branch name {branchName} already exists. <br />\n      Change the name or overwrite existing branch\n    </>\n  ),\n  CLASHING_WITH_REMOTE: (branchName: string) => (\n    <>\n      Branch name {branchName} clashes with remote branch <br />\n      with the same name\n    </>\n  ),\n};\n\nexport function CreateNewBranchWindow({ close }: { close: () => void }) {\n  const [checkout, setCheckout] = useState(true);\n  const [overwrite, setOverwrite] = useState(false);\n  const branches = useRecoilValue(activeFileRepoBranchesState);\n  const [isErrorVisible, setIsErrorVisible] = useState(false);\n  const balloonManager = useBalloonManager();\n  const createBranch = useCreateBranch();\n  const currentBranchName = branches.currentBranch?.name;\n  const [branchName, setBranchName] = useState(currentBranchName || \"\");\n\n  const error = validateBranchName(branches, branchName);\n  const isValid = !error || (error === \"EXISTING\" && overwrite);\n  const validationState = !isValid && isErrorVisible ? \"invalid\" : \"valid\";\n\n  const create = () => {\n    if (isValid) {\n      createBranch(branches.repoRoot, branchName, checkout)\n        .catch((e) => {\n          if (e instanceof Errors.AlreadyExistsError) {\n            balloonManager.show({\n              icon: \"Error\",\n              title: \"Unimplemented action\",\n              body: \"Overwrite option is currently not supported.\", // TODO,\n            });\n          } else {\n            balloonManager.show({\n              icon: \"Error\",\n              title: \"Unexpected error\",\n              body: `Could not create branch ${branchName}.`,\n            });\n          }\n          console.error(\"Branch creation error: \", e);\n        })\n        .then(() => {\n          close();\n          // TODO: show toolwindow balloon, when/if git toolwindow is added\n        });\n    } else {\n      setIsErrorVisible(true);\n    }\n  };\n\n  return (\n    <ModalWindow minWidth=\"content\" minHeight=\"content\">\n      <WindowLayout\n        header=\"Create New Branch\"\n        content={\n          <StyledContainer\n            id=\"create_branch_form\"\n            as=\"form\"\n            onSubmit={(e: FormEvent) => {\n              e.preventDefault();\n              create();\n            }}\n          >\n            <InputField\n              autoFocus\n              autoSelect\n              value={branchName}\n              onChange={(newValue) => {\n                setBranchName(cleanUpBranchName(newValue));\n                setIsErrorVisible(true);\n              }}\n              validationState={validationState}\n              errorMessage={\n                validationState === \"invalid\" &&\n                error &&\n                ErrorMessages[error](branchName)\n              }\n              label=\"New branch name:\"\n              labelPlacement=\"above\"\n            />\n            <StyledCheckboxesContainer>\n              <Checkbox isSelected={checkout} onChange={setCheckout}>\n                Checkout branch\n              </Checkbox>\n              <Checkbox\n                isSelected={overwrite}\n                isDisabled={!isErrorVisible || error !== \"EXISTING\"}\n                onChange={setOverwrite}\n              >\n                Overwrite existing branch\n              </Checkbox>\n            </StyledCheckboxesContainer>\n          </StyledContainer>\n        }\n        footer={\n          <WindowLayout.Footer\n            right={\n              <>\n                <Button onPress={close}>Cancel</Button>\n                <Button\n                  variant=\"default\"\n                  type=\"submit\"\n                  form=\"create_branch_form\" // Using form in absence of built-in support for default button\n                  isDisabled={validationState === \"invalid\"}\n                >\n                  Create\n                </Button>\n              </>\n            }\n          />\n        }\n      />\n    </ModalWindow>\n  );\n}\n","import React, { CSSProperties, useRef } from \"react\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport {\n  ActionDefinition,\n  ActionsProvider,\n  ActionsProviderProps,\n  BalloonManager,\n  DefaultToolWindows,\n  styled,\n  ToolWindowRefValue,\n  useAlertDialog,\n  useBalloonManager,\n  usePopupManager,\n  useWindowManager,\n} from \"@intellij-platform/core\";\nimport { FileEditor } from \"../Editor/FileEditor\";\nimport { toolWindows } from \"./toolWindows\";\nimport { SyncChangeListsState } from \"../VersionControl/Changes/change-lists.state\";\nimport { IdeStatusBar } from \"../StatusBar/IdeStatusBar\";\nimport { usePersistenceFsNotification } from \"../usePersistenceFsNotification\";\nimport { RollbackWindow } from \"../VersionControl/Changes/Rollback/RollbackWindow\";\nimport { rollbackViewState } from \"../VersionControl/Changes/Rollback/rollbackView.state\";\nimport { toolWindowsState } from \"./toolWindows.state\";\nimport { SearchEverywherePopup } from \"../SearchEverywhere/SearchEverywherePopup\";\nimport { useProjectActions } from \"./useProjectActions\";\nimport { searchEverywhereState } from \"../SearchEverywhere/searchEverywhere.state\";\nimport { useVcsActions } from \"../VersionControl/useVcsActions\";\nimport { _balloonManagerRef } from \"./notImplemented\";\nimport { PersistentStateProvider } from \"./persistence/PersistentStateProvider\";\nimport { useTestActions } from \"../testActions/useTestActions\";\nimport { ToolWindowsRefContext } from \"./useToolWindowManager\";\nimport {\n  projectPopupManagerRefState,\n  windowManagerRefState,\n  alertDialogRefState,\n} from \"./project.state\";\n\nconst StyledWindowFrame = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  min-height: 0;\n`;\n\nexport const Project = ({ height }: { height: CSSProperties[\"height\"] }) => {\n  const toolWindowRef = useRef<ToolWindowRefValue>(null);\n  const [state, setState] = useRecoilState(toolWindowsState);\n  const isRollbackWindowOpen = useRecoilValue(rollbackViewState.isOpen);\n  const isSearchEveryWhereOpen = useRecoilValue(searchEverywhereState.isOpen);\n\n  useRecoilValue(projectPopupManagerRefState).current = usePopupManager();\n  useRecoilValue(windowManagerRefState).current = useWindowManager();\n  useRecoilValue(alertDialogRefState).current = useAlertDialog();\n\n  return (\n    <PersistentStateProvider>\n      <SyncChangeListsState />\n      <BalloonManager disablePortal>\n        <SetBalloonManagerRef />\n        <UsePersistentFsNotification />\n        {/* disablePortal to make example app more portable*/}\n        <ToolWindowsRefContext.Provider value={toolWindowRef}>\n          <StyledWindowFrame style={{ height }}>\n            <ProjectActionProvider>\n              {({ shortcutHandlerProps }) => (\n                <>\n                  <DefaultToolWindows\n                    ref={toolWindowRef}\n                    toolWindowsState={state}\n                    onToolWindowStateChange={(newState) => {\n                      setState(newState);\n                    }}\n                    windows={toolWindows}\n                    containerProps={shortcutHandlerProps}\n                  >\n                    <FileEditor />\n                  </DefaultToolWindows>\n                  <IdeStatusBar />\n                </>\n              )}\n            </ProjectActionProvider>\n            {isSearchEveryWhereOpen && <SearchEverywherePopup />}\n            {isRollbackWindowOpen && <RollbackWindow />}\n          </StyledWindowFrame>\n        </ToolWindowsRefContext.Provider>\n      </BalloonManager>\n    </PersistentStateProvider>\n  );\n};\n\nfunction ProjectActionProvider(\n  props: Omit<ActionsProviderProps, \"actions\" | \"useCapture\">\n) {\n  const allActions: ActionDefinition[] = [\n    ...useProjectActions(),\n    ...useVcsActions(),\n    ...useTestActions(),\n  ];\n  return (\n    <ActionsProvider\n      {...props}\n      actions={allActions}\n      useCapture /* useCapture because of Monaco's aggressive event handling. Specifically, Cmd+Shift+O in .ts files  */\n    />\n  );\n}\n\nfunction SetBalloonManagerRef() {\n  _balloonManagerRef.value = useBalloonManager();\n  return null;\n}\n\nfunction UsePersistentFsNotification() {\n  usePersistenceFsNotification();\n  return null;\n}\n","import React from \"react\";\nimport {\n  ModalWindow,\n  ModalWindowProps,\n} from \"@intellij-platform/core/ModalWindow\";\nimport { OverlayMoveHandle } from \"@intellij-platform/core/Overlay\";\nimport { styled } from \"../styled\";\nimport { StyledWindowContainer } from \"@intellij-platform/core/ModalWindow/ModalWindow\";\nimport { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport { Button } from \"@intellij-platform/core/Button\";\nimport { isEventOnEmptySpaces } from \"@intellij-platform/core/utils/interaction-utils/useMove\";\n\nexport interface AlertDialogProps\n  extends Pick<ModalWindowProps, \"minWidth\" | \"id\" | \"onClose\"> {\n  /**\n   * Content slot for the heading, aka. title of the dialog. Typically plain text.\n   */\n  heading?: React.ReactNode;\n  /**\n   * Content slot for the body, aka. message of the dialog. Typically plain text.\n   */\n  body?: React.ReactNode;\n  /**\n   * Content slot for the checkbox (\"Do not ask again\").\n   * @example\n   * ```jsx\n   * <AlertDialog checkbox={<Checkbox>Do not ask again</Checkbox>} />\n   * ```\n   * @see Checkbox\n   */\n  checkbox?: React.ReactNode;\n\n  /**\n   * Type of the alert dialog. The icon is set based on type.\n   */\n  type?: \"error\" | \"warning\" | \"information\" | \"question\";\n\n  /**\n   * Content slot for buttons.\n   * @example\n   * ```jsx\n   * <AlertDialog\n   *   buttons={\n   *     <>\n   *       <Button>Cancel</Button>\n   *       <Button variant=\"default\">Ok</Button>\n   *     </>\n   *   }\n   * />\n   * ```\n   * @see Button\n   */\n  buttons?: React.ReactNode;\n\n  /**\n   * Content slot for help icon button in the footer.\n   * @example\n   * ```jsx\n   * <AlertDialog\n   *   helpButton={\n   *     <TooltipTrigger tooltip={<HelpTooltip helpText=\"Show Help Contents\" />}>\n   *       <Button variant=\"icon\">\n   *         <PlatformIcon icon=\"actions/help\"></PlatformIcon>\n   *       </Button>\n   *     </TooltipTrigger>\n   *   }\n   * />\n   * ```\n   * @see Button\n   */\n  helpButton?: React.ReactNode;\n}\n\nconst StyledModalWindow = styled(ModalWindow)`\n  ${StyledWindowContainer} {\n    border-radius: 0;\n    outline: 0.5px solid rgba(0, 0, 0, 0.85); // FIXME\n  }\n`;\n\nconst StyledContainer = styled.div`\n  padding: 1.25rem;\n  display: grid;\n  grid-template-columns: auto 1fr;\n  grid-template-rows: auto auto;\n  align-items: center;\n  gap: 0.875rem;\n`;\n\nconst StyledHeading = styled.h2`\n  margin: 0;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n  font-weight: bold;\n`;\n\nconst StyledBody = styled.div`\n  line-height: 1.2;\n`;\n\nconst StyledContent = styled.div`\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  cursor: default;\n`;\n\nconst StyledCheckbox = styled.div`\n  padding: 0.375rem 0;\n  // to align the checkbox with the content, since the box has a padding. Maybe Checkbox should not have any padding.\n  margin-left: -0.25rem;\n`;\n\nconst StyledButtons = styled.div`\n  display: flex;\n  justify-self: end;\n  gap: 1rem;\n`;\n\nconst StyledIcon = styled.span`\n  align-self: start;\n`;\n\nconst StyledHelpIcon = styled.div`\n  justify-self: center;\n`;\n\n/**\n * A modal dialog implementing [Alert](https://jetbrains.github.io/ui/controls/alert), which is the\n * [notification](https://jetbrains.github.io/ui/controls/notifications/) pattern for use cases where\n * immediate user action is required.\n * Since the use cases are quite specific, and the component is expected to be used with pretty specific\n * content items, the layout is not implemented as a separate component, the way it is in many other components.\n *\n */\nexport const AlertDialog = ({\n  type = \"question\",\n  heading,\n  body,\n  checkbox,\n  helpButton,\n  buttons,\n  minWidth = 370,\n  ...otherProps\n}: AlertDialogProps): JSX.Element => {\n  return (\n    <StyledModalWindow\n      role=\"alertdialog\"\n      interactions=\"move\"\n      minWidth={minWidth}\n      defaultBounds={{\n        top: window.innerHeight / 4,\n      }}\n      // Reacting to content size, to make sure the content will be visible, considering the window is not resizable.\n      observeContentResize\n      {...otherProps}\n    >\n      <OverlayMoveHandle dragThreshold={6} canMoveStart={isEventOnEmptySpaces}>\n        {({ moveHandleProps }) => (\n          <StyledContainer {...moveHandleProps}>\n            <StyledIcon>\n              {/* Icon name is theme-able in the reference impl via OptionPane[`${icon}Icon`] */}\n              <PlatformIcon size={32} icon={`general/${type}Dialog`} />\n            </StyledIcon>\n            <StyledContent>\n              <StyledHeading>{heading}</StyledHeading>\n              <StyledBody>{body}</StyledBody>\n              {checkbox && <StyledCheckbox>{checkbox}</StyledCheckbox>}\n            </StyledContent>\n            <StyledHelpIcon>{helpButton}</StyledHelpIcon>\n            <StyledButtons>{buttons}</StyledButtons>\n          </StyledContainer>\n        )}\n      </OverlayMoveHandle>\n    </StyledModalWindow>\n  );\n};\n","import React, { FocusEventHandler, useContext, useRef } from \"react\";\nimport { useModal, useOverlay, usePreventScroll } from \"@react-aria/overlays\";\nimport { focusSafely, FocusScope } from \"@react-aria/focus\";\nimport { useDialog } from \"@react-aria/dialog\";\nimport { AriaDialogProps } from \"@react-types/dialog\"; // temporary phantom dependency\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport {\n  OverlayInteractionHandler,\n  OverlayResizeHandles,\n  ResizableMovableOverlayOptions,\n  useResizableMovableOverlay,\n} from \"@intellij-platform/core/Overlay\";\nimport { WindowContext } from \"@intellij-platform/core/ModalWindow/WindowContext\";\nimport { UNSAFE_React17SuspenseFix } from \"@intellij-platform/core/Overlay/UNSAFE_React17SuspenseFix\";\n\nexport interface ModalWindowProps\n  extends AriaDialogProps,\n    ResizableMovableOverlayOptions {\n  children: React.ReactNode;\n  className?: string;\n  onClose?: () => void;\n}\n\nconst StyledWindowUnderlay = styled.div`\n  position: fixed;\n  z-index: 1000; // FIXME: z-index should not be hard-coded like this\n  inset: 0;\n`;\n\nexport const StyledWindowContainer = styled.div`\n  position: fixed;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  border-radius: 8px;\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n  outline: 1px solid #555; // FIXME\n`;\n\n/**\n * only needed for setting overflow to hidden to make sure nothing will overflow a window under any circumstances.\n * The reason we can't set that overflow: \"hidden\" on the StyledWindowContainer itself is that we want resize handles\n * to overflow without bing clipped.\n */\nconst StyledWindowInnerContainer = styled.div`\n  height: inherit;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n`;\n\nexport const DEFAULT_WINDOW_MIN_WIDTH = 50;\nexport const DEFAULT_WINDOW_MIN_HEIGHT = 24;\n\nexport const WindowControllerContext = React.createContext<\n  Partial<Pick<ModalWindowProps, \"onClose\">>\n>({});\n\n/**\n * A movable/resizable modal window. The window header which holds the title, can be used to drag the window around.\n * In the reference impl, modal windows are os-native, and contain os-level buttons for minimize/close/maximise, which\n * are not relevant here since they wouldn't be os-native windows. A close button is still relevant (and kind of\n * necessary) and will be added in next iterations.\n *\n * The content container doesn't come with any padding. Other related components should be used for common layouts in\n * modal windows.\n * Example use cases: Window for git operations such as push, update, revert, new branch, etc.\n *\n * ![img.png](https://user-images.githubusercontent.com/3150694/181095858-968c5c66-2ae7-4e40-84e3-e6df43cd4aa4.png)\n *\n * NOTE: The part regarding rendering OverlayInteractionHandler, and rendering as a dialog with a focus scope, in an\n * overlay container could be extracted into a component which is then used to create custom resizable/movable overlay\n * dialogs, like \"Branches\", or \"Search Everywhere\".\n *\n * TODO: show close button (maybe os-aware styles?)\n *\n */\nexport const ModalWindow = ({\n  interactions = \"all\",\n  minWidth = DEFAULT_WINDOW_MIN_WIDTH,\n  minHeight = DEFAULT_WINDOW_MIN_HEIGHT,\n  className,\n  ...props\n}: ModalWindowProps): React.ReactElement => {\n  const { children } = props;\n  const propsContext = useContext(WindowControllerContext);\n  const onClose = () => {\n    propsContext.onClose?.();\n    props.onClose?.();\n  };\n\n  const ref = React.useRef<HTMLDivElement>(null);\n  const { overlayProps, underlayProps } = useOverlay(\n    {\n      isOpen: true, // maybe allow rendering closed window? :-?\n      onClose,\n      isDismissable: false,\n      isKeyboardDismissDisabled: false,\n      shouldCloseOnBlur: false,\n    },\n    ref\n  );\n  usePreventScroll();\n  const { modalProps } = useModal();\n\n  const { dialogProps, titleProps } = useDialog(props, ref);\n\n  const {\n    bounds: style,\n    overlayInteractionHandlerProps,\n    UNSAFE_measureContentSize,\n  } = useResizableMovableOverlay(ref, { ...props, minHeight, minWidth });\n\n  const { focusContainmentFixProps } = useFocusContainmentFix();\n\n  return (\n    <StyledWindowUnderlay {...underlayProps} className={className}>\n      <OverlayInteractionHandler {...overlayInteractionHandlerProps}>\n        <FocusScope contain restoreFocus autoFocus>\n          <StyledWindowContainer\n            {...mergeProps(\n              overlayProps,\n              dialogProps,\n              modalProps,\n              focusContainmentFixProps,\n              { style }\n            )}\n            ref={ref}\n          >\n            <StyledWindowInnerContainer>\n              <WindowContext.Provider\n                value={{\n                  isActive: true, // because it's modal. WindowContext would be used for non-modal windows too, in future\n                  titleProps,\n                  movable: interactions !== \"none\",\n                }}\n              >\n                <UNSAFE_React17SuspenseFix\n                  measureContentSize={UNSAFE_measureContentSize}\n                >\n                  {children}\n                </UNSAFE_React17SuspenseFix>\n              </WindowContext.Provider>\n            </StyledWindowInnerContainer>\n            {interactions === \"all\" && <OverlayResizeHandles />}\n          </StyledWindowContainer>\n        </FocusScope>\n      </OverlayInteractionHandler>\n    </StyledWindowUnderlay>\n  );\n};\n\n/**\n * The way FocusScope is implemented at the moment, it's possible for another focus scope to steal the focus,\n * right after the modal window is opened. The issue is not tracked down to the root cause. But with this hook,\n * we make sure there is no way for focus to go out of the modal window, when it's mounted.\n */\nfunction useFocusContainmentFix<T extends HTMLElement>() {\n  const lastFocusedElementRef = useRef<HTMLElement | null>(null);\n  const onFocus: FocusEventHandler<T> = (e) => {\n    lastFocusedElementRef.current = e.target;\n  };\n  const onBlur: FocusEventHandler = (e) => {\n    const probablyFocusedElement = e.relatedTarget;\n    if (\n      !probablyFocusedElement ||\n      (probablyFocusedElement instanceof Element &&\n        !e.currentTarget.contains(probablyFocusedElement))\n    ) {\n      const elementToFocus = lastFocusedElementRef.current;\n      if (elementToFocus) {\n        focusSafely(elementToFocus);\n      }\n    }\n  };\n  return {\n    focusContainmentFixProps: {\n      onFocus,\n      onBlur,\n    },\n  };\n}\n","import React, { HTMLAttributes, useContext } from \"react\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { OverlayMoveHandle } from \"@intellij-platform/core/Overlay\";\n\nimport { WindowContext } from \"./WindowContext\";\nimport { mergeProps } from \"@react-aria/utils\";\n\nconst StyledWindowTitle = styled.h1`\n  margin: 0;\n  text-align: center;\n  font-size: 13px; // not rem! intentional\n  line-height: 24px; // Double check\n  cursor: default;\n  user-select: none;\n  padding: 0 8px;\n`;\n\n/**\n * Implements appearance of Window header, and also acts as a handle for moving the window.\n * Expected to be used with {@link WindowLayout}:\n *\n * @example\n * ```tsx\n * <ModalWindow>\n *    <WindowLayout header={<WindowHeader>header</WindowHeader>} />\n * </ModalWindow>\n * ```\n */\nexport const WindowHeader = ({ children }: { children?: React.ReactNode }) => {\n  const { movable, titleProps } = useContext(WindowContext);\n  const renderTitle = (otherProps: HTMLAttributes<HTMLElement> = {}) => (\n    <StyledWindowTitle {...mergeProps(titleProps, otherProps)}>\n      {children || <>&nbsp;</>}\n    </StyledWindowTitle>\n  );\n  return movable ? (\n    <OverlayMoveHandle>\n      {({ moveHandleProps }) => renderTitle(moveHandleProps)}\n    </OverlayMoveHandle>\n  ) : (\n    renderTitle()\n  );\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\n\nconst StyledFooter = styled.div<{ hasBorder?: boolean }>`\n  padding: 0.625rem 0.875rem;\n  display: flex;\n  gap: 0.5rem;\n  justify-content: space-between;\n  align-items: center;\n  border-top: 1px solid transparent;\n  border-color: ${({ hasBorder, theme }) =>\n    hasBorder && theme.commonColors.contrastBorder};\n`;\nconst StyledFooterSide = styled.div`\n  display: flex;\n  gap: 0.75rem;\n`;\n\n/**\n * Implements the common layout for window footer, to be used in {@link ModalWindowProps#footer}.\n * Footer has a left and a right side. There is a standard gap between the children of each side.\n */\nexport function WindowFooter({\n  left,\n  right,\n  hasBorder,\n}: {\n  /**\n   * The content to go to the left side the footer. A help icon button is very common on the left side.\n   */\n  left?: React.ReactNode;\n  /**\n   * The content to go to the right side the footer. {@link Button}s are usually used inside the right content\n   */\n  right?: React.ReactNode;\n  /**\n   * Whether to show top border for footer or not\n   */\n  hasBorder?: boolean;\n}) {\n  return (\n    <StyledFooter hasBorder={hasBorder}>\n      <StyledFooterSide>{left}</StyledFooterSide>\n      <StyledFooterSide>{right}</StyledFooterSide>\n    </StyledFooter>\n  );\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { WindowHeader } from \"./WindowHeader\";\nimport { WindowFooter } from \"@intellij-platform/core/ModalWindow/WindowFooter\";\n\nconst StyledWindowFooter = styled.div`\n  min-height: min-content;\n`;\n\nconst StyledWindowContentWrapper = styled.div`\n  overflow: auto;\n  flex: 1;\n`;\n\n/**\n * Window content layout, supporting fixed `header` and `footer` sections, and a scrollable `content` area.\n */\nexport function WindowLayout({\n  header,\n  footer,\n  content,\n}: {\n  /**\n   * Fixed position header of the window at the top. Use {@link WindowLayout.Header} for the default window header,\n   * which also acts as a move handle for the window. If a string is passed, it will be wrapped by\n   * {@link WindowLayout.Header} automatically.\n   */\n  header: React.ReactNode;\n  /**\n   * Scrollable content of the window.\n   */\n  content: React.ReactNode;\n  /**\n   * An area at the bottom of the window which is not scrolled as opposed to `content`. Use {@link WindowLayout.Footer}\n   * for rendering the common layout of a window footer.\n   */\n  footer?: React.ReactNode;\n}) {\n  return (\n    <>\n      {header &&\n        (typeof header === \"string\" ? (\n          <WindowHeader>{header}</WindowHeader>\n        ) : (\n          header\n        ))}\n      <StyledWindowContentWrapper>{content}</StyledWindowContentWrapper>\n      {footer && <StyledWindowFooter>{footer}</StyledWindowFooter>}\n    </>\n  );\n}\n\n// Just for improved discoverability. Might as well export WindowFooter and WindowHeader instead.\nWindowLayout.Footer = WindowFooter;\nWindowLayout.Header = WindowHeader;\n","import React, { ComponentProps, useState } from \"react\";\nimport { mergeProps, useObjectRef } from \"@react-aria/utils\";\nimport { useControlledState } from \"@react-stately/utils\";\n\nimport { styled } from \"@intellij-platform/core/styled\";\nimport {\n  ActionDefinition,\n  ActionsProvider,\n  CommonActionId,\n  useGetActionShortcut,\n} from \"@intellij-platform/core/ActionSystem\";\nimport { Input, InputProps } from \"@intellij-platform/core/InputField\";\nimport {\n  AutoHoverPlatformIcon,\n  PlatformIcon,\n} from \"@intellij-platform/core/Icon\";\nimport { Menu, MenuTrigger } from \"@intellij-platform/core/Menu\";\nimport { Item } from \"@intellij-platform/core/Collections\";\nimport { ActionTooltip, TooltipTrigger } from \"@intellij-platform/core/Tooltip\";\n\nexport interface SearchInputProps\n  extends Omit<InputProps, \"onSubmit\" | \"onChange\"> {\n  /**\n   * Search history to be shown as a menu when the search icon is pressed.\n   */\n  searchHistory?: Array<string>;\n  /**\n   * The content of \"show history\" button tooltip, and the corresponding action title.\n   * @default \"Recent Search\"\n   */\n  historyButtonTitle?: string;\n  /**\n   * Called when the search input is cleared by either clear button or `Escape` key.\n   * `onChange` is also called with an empty string, whenever the input is cleared,\n   * so there is no need for updating the state using `onClear`, when the value is controlled.\n   *\n   * @param clearedValue the value before clearing.\n   */\n  onClear?: (clearedValue: string) => void;\n  /**\n   * Called when the search is submitted by pressing `Enter`\n   * @param value submitted text\n   */\n  onSubmit?: (value: string) => void;\n  /**\n   * Controlled value of the search input\n   */\n  value?: string;\n  /**\n   * Default value of the search input, used for initialization when value is uncontrolled.\n   */\n  defaultValue?: string;\n  /**\n   * Called when the value is changed.\n   */\n  onChange?: (value: string) => void;\n  /**\n   * Called when a history item is selected. `onChange` is called with the selected text, so\n   * there is no need for updating the state using `onHistoryItemSelected`, when the value is controlled.\n   *\n   * @param value text selected from history.\n   * @param previousValue the value of the input before the history item was selected.\n   */\n  onHistoryItemSelected?: (value: string, previousValue: string) => void;\n}\n\nconst StyledInput = styled(Input)`\n  input[type=\"search\"] {\n    -webkit-appearance: none;\n    &::-webkit-search-cancel-button {\n      -webkit-appearance: none;\n    }\n    &::-webkit-search-decoration {\n      -webkit-appearance: none;\n    }\n  }\n`;\n\n/**\n * A wrapper around {@link Input} with a few additions:\n * - A Search icon, added as an {@link InputProps#addonBefore addonBefore}.\n * - A clear button, added as an {@link InputProps#addonAfter addonAfter}, when the input has value.\n *   {@link SearchInputProps#onClear onClear} is called when the clear button is clicked.\n * - A list of search queries shown as a menu, when the search icon is clicked,\n *   if {@link SearchInputProps#searchHistory searchHistory} is provided.\n * - An action provided on the input element, to open the search history via\n *   {@link CommonActionId.SHOW_SEARCH_HISTORY} shortcut.\n * - Search submission callback ({@link SearchInputProps#onSubmit onSubmit}) called when search is submitted by pressing Enter\n *\n * {@link InputProps#onChange onChange} and {@link InputProps#onSubmit onSubmit} props are also different in SearchInput, compared to\n * the corresponding props of the native input.\n *\n * Caveat: If the width is not set (either explicitly or via the entailing layout), the width of the input will change when clear button shows/hides.\n *\n */\nexport const SearchInput = React.forwardRef(function SearchInput(\n  {\n    addonBefore,\n    addonAfter,\n    searchHistory,\n    onClear,\n    onSubmit,\n    onHistoryItemSelected,\n    historyButtonTitle = \"Recent Search\",\n    value: valueProp,\n    defaultValue = \"\",\n    onChange,\n    type = \"search\",\n    inputRef: inputRefProp,\n    ...props\n  }: SearchInputProps,\n  forwardedRef: React.Ref<HTMLDivElement>\n) {\n  const [value, setValue] = useControlledState(\n    valueProp!,\n    defaultValue,\n    onChange!\n  );\n  const inputContainerRef = useObjectRef(forwardedRef);\n  const inputRef = useObjectRef(inputRefProp);\n  const [isSearchHistoryOpen, setSearchHistoryOpen] = useState(false);\n  const showSearchHistoryAction: ActionDefinition = {\n    id: CommonActionId.SHOW_SEARCH_HISTORY,\n    title: historyButtonTitle,\n    actionPerformed: () => {\n      setSearchHistoryOpen(true);\n    },\n  };\n  // TODO: rename HelpTooltip, ActionTooltip, etc. to Tooltip.Action Tooltip.Help, then add ActionTooltip in action\n  //  components, and use that instead of the more low-level API used here.\n  const getShortcut = useGetActionShortcut();\n  const searchIcon = searchHistory ? (\n    <MenuTrigger\n      isOpen={isSearchHistoryOpen}\n      onOpenChange={setSearchHistoryOpen}\n      positioningTargetRef={inputContainerRef}\n      renderMenu={({ menuProps }) => (\n        <Menu\n          {...menuProps}\n          autoFocus=\"first\"\n          onAction={(key) => {\n            const historyItemText =\n              searchHistory[parseInt(`${key}`.split(\"_\")[0])];\n            if (historyItemText !== undefined) {\n              setValue(historyItemText);\n              onHistoryItemSelected?.(historyItemText, value);\n              inputRef.current?.focus();\n            }\n          }}\n        >\n          {searchHistory.map((historyItem, index) => (\n            <Item key={`${index}_${historyItem}`}>{historyItem}</Item>\n          ))}\n        </Menu>\n      )}\n    >\n      {(menuTriggerProps, ref) => (\n        <TooltipTrigger\n          tooltip={\n            <ActionTooltip\n              actionName={historyButtonTitle}\n              shortcut={getShortcut(CommonActionId.SHOW_SEARCH_HISTORY)}\n            />\n          }\n        >\n          {(tooltipTriggerProps) => (\n            <PlatformIcon\n              {...mergeProps(tooltipTriggerProps, menuTriggerProps)}\n              ref={ref}\n              icon=\"actions/searchWithHistory.svg\"\n              role=\"button\"\n              aria-label={historyButtonTitle}\n            />\n          )}\n        </TooltipTrigger>\n      )}\n    </MenuTrigger>\n  ) : (\n    <PlatformIcon icon=\"actions/search.svg\" />\n  );\n  const clear = () => {\n    setValue(\"\");\n    onClear?.(value);\n  };\n  const inputProps = mergeProps<ComponentProps<typeof Input>[]>(props, {\n    ref: inputContainerRef,\n    inputRef,\n    value,\n    type,\n    onChange: (event) => {\n      setValue(event.target.value);\n    },\n    addonBefore: (\n      <>\n        {searchIcon}\n        {addonBefore}\n      </>\n    ),\n    addonAfter: (\n      <>\n        {value && (\n          <AutoHoverPlatformIcon\n            onClick={clear}\n            role=\"button\"\n            aria-label=\"Clear search\"\n            icon=\"actions/close\"\n            hoverIcon=\"actions/closeHovered\"\n          />\n        )}\n        {addonAfter}\n      </>\n    ),\n    onKeyDown: (event) => {\n      if (event.repeat) {\n        return;\n      }\n      if (event.key === \"Enter\") {\n        onSubmit?.(event.currentTarget.value);\n      } else if (event.key === \"Escape\") {\n        clear();\n      }\n    },\n  });\n  if (searchHistory) {\n    return (\n      <ActionsProvider actions={[showSearchHistoryAction]}>\n        {({ shortcutHandlerProps }) => (\n          <StyledInput {...mergeProps(inputProps, shortcutHandlerProps)} />\n        )}\n      </ActionsProvider>\n    );\n  }\n  return <StyledInput {...inputProps} />;\n});\n"],"names":[],"sourceRoot":""}