{"version":3,"file":"508.c537750c.iframe.bundle.js","mappings":";AAOA;;;;AAOA;;;;;;;;;AAYA;;AAkCA;;;;ACzCA;;AAIA;;;;AAIA;AAMA;;ACbA;;;;AAIA;AASA;;;AAMA;AACA;AAGA;;;AAUA;;;;ACAA;;;AAKA;;AAEA;;;AAKA;AACA;;;;;;;;;AAgBA;;ACzBA;AACA;AAGA;;;;;;;;AAUA;AACA;;;AAGA;;;AAKA;;;;;AAoBA;AAGA;AAXA;;;;AAgBA;;;AAGA;AAlBA;;AAuBA;;;;;AAvBA;AA6BA;;;AAGA;AAhCA;;AAqCA;;;;AAOA;;;;;;;AAOA;AAQA;;;;;AASA;AAoMA;AAGA;;;AAGA;;;;AASA","sources":["webpack://@intellij-platform/core/./src/Icon/AutoHoverPlatformIcon.tsx","webpack://@intellij-platform/core/./src/Menu/MenuItemLayout.tsx","webpack://@intellij-platform/core/./src/SpeedSearch/SpeedSearchInput.tsx","webpack://@intellij-platform/core/./src/Menu/SpeedSearchMenu.tsx","webpack://@intellij-platform/core/./src/Toolbar/Toolbar.tsx"],"sourcesContent":["import { styled } from \"@intellij-platform/core/styled\";\nimport React, { ForwardedRef } from \"react\";\nimport { amendName, PlatformIcon, PlatformIconProps } from \"./PlatformIcon\";\n\nexport const StyledHoverContainer = styled.span<{\n  hoverContainerSelector?: string;\n}>`\n  ${({ hoverContainerSelector }) =>\n    hoverContainerSelector\n      ? `${hoverContainerSelector} &`\n      : \"\"} .icon[data-hover] {\n    display: none;\n  }\n\n  ${({ hoverContainerSelector }) =>\n    hoverContainerSelector ? `${hoverContainerSelector}:hover &` : \"&:hover\"} {\n    .icon {\n      display: none;\n    }\n\n    .icon[data-hover] {\n      display: inline-flex;\n    }\n  }\n`;\n\nconst StyledIconHoverContainer = styled(StyledHoverContainer)`\n  display: inline-flex;\n`;\n\n/**\n * A common use case for PlatformIcons is to have a default icon and a hover icon.\n * This component captures that simple use case, by rendering both icons, and hiding one based on a hover selector.\n *\n * ### Parent hover container\n *\n * If the hover-able element is a parent of the icon, and not the icon itself (i.e., the icon should change if the\n * that parent is hovered), you can use `StyledHoverContainer` to define that parent element:\n *\n * ```tsx\n * const SomeParent = styled(StyledHoverContainer)`...`;\n * <SomeParent><AutoHoverPlatformIcon icon=\"...\" /></SomeParent>\n * ```\n *\n * If the hover-able element is a parent of the icon, with a known selector, you can pass `hoverContainerSelector`,\n * instead of using `StyledHoverContainer`:\n *\n * ```tsx\n * <AutoHoverPlatformIcon icon=\"...\" hoverContainerSelector=\"[role=menuitem]\" />\n * ```\n *\n * If the hover container is a styled component, you can have it converted to selector like this:\n *\n * ```tsx\n * <AutoHoverPlatformIcon icon=\"...\" hoverContainerSelector={`${MyStyledHoverContainer}`} />\n * ```\n *\n * In all examples above, the hover icon is shown when the parent is hovered, instead of the icon itself.\n *\n */\nexport const AutoHoverPlatformIcon = React.forwardRef(\n  function AutoHoverPlatformIcon(\n    {\n      hoverIcon,\n      hoverContainerSelector,\n      ...props\n    }: PlatformIconProps & {\n      /**\n       * The icon to be used when hovered. If not provided, it will be the \"somethingHovered\" where \"something\" is the `icon`\n       */\n      hoverIcon?: string;\n      hoverContainerSelector?: string;\n    },\n    ref: ForwardedRef<HTMLSpanElement>\n  ) {\n    const className = `icon ${props.className || \"\"}`;\n    return (\n      <StyledIconHoverContainer\n        ref={ref}\n        hoverContainerSelector={hoverContainerSelector}\n      >\n        <PlatformIcon {...props} className={className} />\n        <PlatformIcon\n          {...props}\n          className={className}\n          icon={hoverIcon ?? amendName(props.icon, \"Hover\")}\n          data-hover\n        />\n      </StyledIconHoverContainer>\n    );\n  }\n);\n","import React from \"react\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections/ItemStateContext\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { useContextOrThrow } from \"@intellij-platform/core/utils/useContextOrThrow\";\n\nimport { useMenuItemLayout } from \"./MenuItem\";\nimport { StyledMenuItemIcon } from \"./StyledMenuItem\";\n\ninterface MenuItemLayoutProps {\n  icon?: React.ReactNode;\n  content: React.ReactNode;\n  shortcut?: React.ReactNode;\n}\n\nconst StyledMenuItemLayout = styled.div`\n  display: flex;\n  align-items: center;\n  flex: 1; // to make sure it takes as much space as available in the menu item row, so that the suffix (shortcut) is pushed to the right\n`;\nconst Content = styled.span`\n  flex: 1;\n`;\n\nconst Shortcut = styled.kbd`\n  font-family: system-ui, sans-serif;\n  margin-left: 30px;\n  margin-right: -0.625rem;\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(\n      theme.color(\"MenuItem.acceleratorForeground\")\n    )};\n`;\n\nexport const MenuItemLayout = ({\n  content,\n  shortcut,\n  icon,\n}: MenuItemLayoutProps) => {\n  const { isSelected } = useContextOrThrow(\n    ItemStateContext,\n    \"MenuItemLayout is meant to be rendered in Item component in Menus\"\n  );\n  const { labelProps, keyboardShortcutProps } = useMenuItemLayout();\n  const allowedIcon = !isSelected && icon;\n  return (\n    <StyledMenuItemLayout>\n      {allowedIcon && <StyledMenuItemIcon>{allowedIcon}</StyledMenuItemIcon>}\n      <Content {...labelProps}>{content}</Content>\n      {shortcut && <Shortcut {...keyboardShortcutProps}>{shortcut}</Shortcut>}\n    </StyledMenuItemLayout>\n  );\n};\n","import React, { useRef } from \"react\";\nimport { useButton } from \"@react-aria/button\";\nimport {\n  AutoHoverPlatformIcon,\n  PlatformIcon,\n} from \"@intellij-platform/core/Icon\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\n\nexport interface SpeedSearchInputProps {\n  children: string | undefined;\n  match?: boolean;\n  active: boolean | undefined;\n  clear: () => void;\n}\n\nconst StyledSearchIcon = styled(PlatformIcon)`\n  margin-right: 0.25rem;\n`;\n\nconst StyledSpeedSearchInput = styled.span<{ noMatch?: boolean }>`\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  background: ${({ theme, noMatch }) =>\n    noMatch\n      ? theme.color(\n          \"SearchField.errorBackground\",\n          theme.dark ? \"#743A3A\" : \"#ffcccc\"\n        )\n      : theme.color(\n          \"TextField.background\"\n        )}; // fallback logic not checked with the ref impl\n  color: ${({ theme }) =>\n    theme.color(\n      \"TextField.foreground\" as UnknownThemeProp<\"TextField.foreground\">\n    )}; // fallback logic not checked with the ref impl\n  height: 1.5rem; // 24px, JBTextField COMPACT_HEIGHT\n  padding: 0.125rem 0.375rem;\n  border: 1px solid ${({ theme }) => theme.getOutlineColor(true, false)};\n  border-radius: ${({ theme }) =>\n    ((theme.value(\"Component.arc\") as number) ?? 5) / 2}px;\n`;\nconst StyledSearchText = styled.span`\n  flex: 1;\n  font-size: 0.91em; // RelativeFont.SMALL\n`;\n\n/**\n * An input field to be rendered to show the filter value in speed search in menus and similar speedSearch-enabled\n * components.\n * @see SpeedSearchPopup\n */\nexport const SpeedSearchInput = React.forwardRef<\n  HTMLElement,\n  SpeedSearchInputProps\n>(({ active, match, children, clear }, ref) => {\n  const clearButtonRef = useRef<HTMLElement>(null);\n  const { buttonProps } = useButton(\n    {\n      elementType: \"span\",\n      \"aria-label\": \"Clear search\",\n      excludeFromTabOrder: true,\n      // @ts-expect-error: preventFocusOnPress is not defined in public API of useButton\n      preventFocusOnPress: true,\n      onPress: clear,\n    },\n    clearButtonRef\n  );\n\n  // Temporary styled components until SearchInput is implemented\n  return active ? (\n    <StyledSpeedSearchInput ref={ref} noMatch={!match}>\n      <StyledSearchIcon icon={\"actions/search\"} />\n      <StyledSearchText>\n        {(children || \"\").replace(/ /g, \"\\u00A0\")}\n      </StyledSearchText>\n      {children && (\n        <AutoHoverPlatformIcon\n          {...buttonProps}\n          ref={clearButtonRef}\n          icon=\"actions/close\"\n          hoverIcon=\"actions/closeHovered\"\n        />\n      )}\n    </StyledSpeedSearchInput>\n  ) : null;\n});\n","import React, {\n  HTMLAttributes,\n  RefObject,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { Node } from \"@react-types/shared\";\nimport {\n  mergeProps,\n  useLayoutEffect,\n  useResizeObserver,\n} from \"@react-aria/utils\";\nimport { focusSafely } from \"@react-aria/focus\";\nimport { ListCollection } from \"@react-stately/list\";\nimport { TreeState } from \"@react-stately/tree\";\nimport { useEventCallback } from \"@intellij-platform/core/utils/useEventCallback\";\nimport {\n  useCollectionSpeedSearch,\n  CollectionSpeedSearchMatches,\n} from \"@intellij-platform/core/CollectionSpeedSearch\";\nimport {\n  SpeedSearchInput,\n  SpeedSearchPopupProps,\n  SpeedSearchState,\n} from \"@intellij-platform/core/SpeedSearch\";\n\nimport { StyledMenu } from \"./StyledMenu\";\nimport { MenuContext, MenuProps, useMenu, useMenuState } from \"./Menu\";\nimport { renderMenuNodes } from \"./renderMenuNodes\";\nimport { SubmenuProps, useSubmenu } from \"./Submenu\";\nimport { useSubmenuState } from \"./_useSubmenuState\";\nimport { MenuKeyboardDelegate } from \"./_useSubmenu\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { StyledVerticalSeparator } from \"@intellij-platform/core/StyledSeparator\";\n\nexport interface SpeedSearchMenuProps<T>\n  extends Omit<MenuProps<T>, \"submenuBehavior\"> {\n  submenuBehavior?: Exclude<MenuProps<T>[\"submenuBehavior\"], \"default\">;\n  /**\n   * Text to show when the filtering is active but no match is found for the current query.\n   * @default \"Nothing to show\"\n   */\n  emptyText?: React.ReactNode;\n}\n\nconst StyledItemsContainer = styled.ul`\n  all: unset;\n  flex: 1;\n  overflow: auto;\n`;\n\nconst StyledSearchFieldWrapper = styled.div`\n  flex-shrink: 0;\n  padding: 0 0.2rem 0.3rem;\n`;\n\nconst StyledSpeedSearchMenu = styled(StyledMenu)`\n  --jui-menu-item-padding: 1.25rem;\n  ${StyledVerticalSeparator} {\n    margin: 0 3px; // FIXME: probably use theme\n  }\n`;\n\nconst StyledPlaceholder = styled.div`\n  color: ${({ theme }) =>\n    // Ref: StatusText => DEFAULT_ATTRIBUTES => SimpleTextAttributes.GRAYED_ATTRIBUTES\n    theme.color(\n      \"Component.infoForeground\",\n      theme.dark ? \"#787878\" : \"#999999\"\n    )};\n\n  // center positioning. Intentionally different from reference impl.\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n\n  white-space: nowrap;\n`;\n\nfunction useSpeedSearchMenu<T>(\n  state: TreeState<T>,\n  rootKey: React.Key | null,\n  ref: React.RefObject<HTMLUListElement>,\n  containerRef: React.RefObject<HTMLDivElement>\n) {\n  const {\n    speedSearch,\n    selectionManager,\n    keyboardDelegate,\n    containerProps: speedSearchContainerProps,\n    searchPopupProps,\n  } = useCollectionSpeedSearch({\n    collection: useMemo(\n      () =>\n        new ListCollection(\n          rootKey\n            ? state.collection.getItem(rootKey).childNodes\n            : state.collection\n        ),\n      [rootKey, state.collection]\n    ),\n    selectionManager: state.selectionManager,\n    keyboardDelegate: new MenuKeyboardDelegate(\n      rootKey,\n      state.collection,\n      state.disabledKeys,\n      ref\n    ),\n    keepSearchActiveOnBlur: true,\n    focusBestMatch: true,\n    ref,\n  });\n\n  // When a menu item which was focused is filtered out, the focus goes to body.\n  // We manually move focus back to the container.\n  useEffect(() => {\n    const element = ref.current;\n    if (\n      element &&\n      state.selectionManager.isFocused &&\n      !element?.contains(document.activeElement)\n    ) {\n      focusSafely(element);\n    }\n  });\n\n  const lastSize = useRef<{ width: number; height: number } | null>(null);\n  const [size, setSize] = useState<{ width: number; height: number } | null>(\n    null\n  );\n  const measureSize = () => {\n    const { offsetWidth = 0, offsetHeight = 0 } = containerRef.current || {};\n    if (offsetWidth > 0 && offsetHeight > 0) {\n      lastSize.current = {\n        width: offsetWidth,\n        height: offsetHeight,\n      };\n    }\n  };\n  const isSearchActive =\n    speedSearch.active && speedSearch.searchTerm.length > 0;\n  useResizeObserver({\n    ref: containerRef,\n    onResize: useEventCallback(() => {\n      if (!isSearchActive) {\n        measureSize();\n      }\n    }),\n  });\n  useLayoutEffect(() => {\n    if (isSearchActive) {\n      if (lastSize.current) {\n        setSize(lastSize.current);\n      }\n    } else {\n      if (!lastSize.current) {\n        measureSize();\n      }\n      setSize(null);\n    }\n  }, [isSearchActive]);\n\n  const sizeStyleProps: HTMLAttributes<HTMLElement> = size\n    ? {\n        style: {\n          ...size,\n          minHeight: size.height,\n          maxHeight: size.height,\n        },\n      }\n    : {};\n  return {\n    speedSearch,\n    keyboardDelegate,\n    selectionManager,\n    speedSearchContainerProps: mergeProps<HTMLAttributes<HTMLElement>[]>(\n      speedSearchContainerProps,\n      sizeStyleProps,\n      {\n        onMouseDown: (e: React.MouseEvent) => {\n          // Until SearchInput and connecting that to a selectable list is implemented, we should prevent menu from\n          // losing focus when the fake search input is clicked\n          e.preventDefault();\n        },\n      }\n    ),\n    searchPopupProps,\n  };\n}\n\n/**\n * Drop-in replacement for Menu, which implements SpeedSearch.\n *\n *\n */\nexport const SpeedSearchMenu = <T extends object>({\n  submenuBehavior = \"toggleOnPress\",\n  autoFocus = \"first\",\n  emptyText = \"Nothing to show\",\n  minWidth,\n  ...props\n}: SpeedSearchMenuProps<T>) => {\n  const onAction = (key: React.Key) => {\n    props.onAction?.(key);\n    speedSearch.clear();\n  };\n  const ref = React.useRef<HTMLUListElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const state = useMenuState({ ...props });\n  const {\n    speedSearch,\n    speedSearchContainerProps,\n    searchPopupProps,\n    keyboardDelegate,\n  } = useSpeedSearchMenu(state, null, ref, containerRef);\n  const { menuContextValue, menuProps } = useMenu(\n    {\n      ...props,\n      autoFocus,\n      onAction,\n      keyboardDelegate,\n      submenuBehavior,\n    },\n    state,\n    ref\n  );\n\n  return (\n    <MenuContext.Provider\n      value={{\n        ...menuContextValue,\n        renderSubmenu: (props) => (\n          <SpeedSearchSubmenu emptyText={emptyText} {...props} />\n        ),\n      }}\n    >\n      <StyledSpeedSearchMenu\n        as=\"div\"\n        ref={containerRef}\n        style={{ minWidth }}\n        {...speedSearchContainerProps}\n        fillAvailableSpace={props.fillAvailableSpace}\n      >\n        <SpeedSearchMenuContent\n          items={[...state.collection]}\n          emptyText={emptyText}\n          speedSearch={speedSearch}\n          searchPopupProps={searchPopupProps}\n          state={state}\n          menuProps={menuProps}\n          menuRef={ref}\n        />\n      </StyledSpeedSearchMenu>\n    </MenuContext.Provider>\n  );\n};\n\nfunction SpeedSearchMenuContent<T>({\n  items,\n  state,\n  speedSearch,\n  searchPopupProps,\n  menuProps,\n  menuRef,\n  emptyText,\n}: {\n  state: TreeState<T>;\n  items: Node<T>[];\n  speedSearch: SpeedSearchState & { matches: CollectionSpeedSearchMatches };\n  searchPopupProps: SpeedSearchPopupProps;\n  menuProps: HTMLAttributes<HTMLElement>;\n  menuRef: RefObject<HTMLUListElement>;\n  emptyText: React.ReactNode;\n}) {\n  const filter = speedSearch.active\n    ? ({ key, type }: Node<T>) =>\n        type !== \"item\" || speedSearch.matches.has(key)\n    : undefined;\n  return (\n    <>\n      {searchPopupProps.children && (\n        <StyledSearchFieldWrapper\n          onClick={(e) => {\n            e.preventDefault();\n          }}\n        >\n          <SpeedSearchInput {...searchPopupProps} clear={speedSearch.clear} />\n        </StyledSearchFieldWrapper>\n      )}\n      <StyledItemsContainer {...menuProps} ref={menuRef}>\n        {renderMenuNodes(state, items, filter)}\n        {speedSearch.active && speedSearch.matches.size === 0 && (\n          <StyledPlaceholder>{emptyText}</StyledPlaceholder>\n        )}\n      </StyledItemsContainer>\n    </>\n  );\n}\n\nfunction SpeedSearchSubmenu<T>({\n  parentState,\n  rootKey,\n  emptyText,\n}: SubmenuProps<T> & { emptyText: React.ReactNode }) {\n  const ref = useRef<HTMLUListElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const state = useSubmenuState(parentState);\n  const rootItem = state.collection.getItem(rootKey);\n\n  const {\n    speedSearch,\n    speedSearchContainerProps,\n    searchPopupProps,\n    keyboardDelegate,\n  } = useSpeedSearchMenu(state, rootKey, ref, containerRef);\n  const { submenuProps } = useSubmenu(\n    { rootKey, parentState, keyboardDelegate },\n    state,\n    ref\n  );\n\n  return (\n    <StyledSpeedSearchMenu\n      {...speedSearchContainerProps}\n      as=\"div\"\n      ref={containerRef}\n    >\n      <SpeedSearchMenuContent\n        items={[...(rootItem?.childNodes || [])]}\n        speedSearch={speedSearch}\n        searchPopupProps={searchPopupProps}\n        state={state}\n        menuProps={submenuProps}\n        menuRef={ref}\n        emptyText={emptyText}\n      />\n    </StyledSpeedSearchMenu>\n  );\n}\n","import React, {\n  CSSProperties,\n  MouseEvent,\n  useContext,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { styled, css } from \"../styled\";\nimport {\n  StyledHorizontalSeparator,\n  StyledSeparator,\n  StyledVerticalSeparator,\n} from \"../StyledSeparator\";\nimport { useOverflowObserver } from \"@intellij-platform/core/utils/overflow-utils/useOverflowObserver\";\nimport { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport { Overlay, useOverlayPosition } from \"@react-aria/overlays\";\nimport { StyledPopupContainer } from \"@intellij-platform/core/Popup/Popup\";\nimport { mergeProps } from \"@react-aria/utils\";\n\ntype ToolbarBorderProp =\n  | true\n  | \"horizontal\"\n  | \"vertical\"\n  | \"bottom\"\n  | \"top\"\n  | \"left\"\n  | \"right\";\n\nexport type ToolbarProps = {\n  children: React.ReactNode;\n  orientation?: \"vertical\" | \"horizontal\";\n  border?: ToolbarBorderProp;\n  style?: CSSProperties;\n  className?: string;\n} & (\n  | {\n      orientation: \"vertical\";\n    }\n  | {\n      orientation?: \"horizontal\";\n      /**\n       * Defines how the toolbar should handle its children when there is not enough room\n       * to fit all:\n       * - popup: the overflowed children will be hidden behind a show more arrow icon that\n       *   shows the rest of the items in a popup.\n       * - wrap: children will be wrapped so that they fit the available width/height\n       **/\n      overflowBehavior?: \"popup\" | \"wrap\";\n    }\n);\n\nconst borderStyle = ({ border }: { border?: ToolbarBorderProp }) =>\n  border &&\n  css`\n    border-style: solid;\n    border-color: ${({ theme }) => theme.commonColors.borderColor};\n    border-width: ${border === true ? \"1px\" : borderPropToCssProp[border]};\n  `;\n\nconst StyledToolbar = styled.div<{\n  border?: ToolbarBorderProp;\n}>`\n  display: inline-flex;\n  box-sizing: border-box;\n  overflow: hidden;\n  // NOTE: in the original implementation, there is no empty space between buttons, but buttons have kind of an\n  // invisible left padding, which is mouse-intractable, but doesn't visually seem a part of the button.\n  // Although implementable, it didn't seem necessary to follow the exact same thing. Margin should be fine.\n  gap: 4px;\n  ${borderStyle}\n  ${StyledSeparator}:first-child {\n    display: none;\n  }\n  ${StyledSeparator}:last-child {\n    display: none;\n  }\n`;\n\nconst borderPropToCssProp: Record<\n  Exclude<ToolbarBorderProp, boolean>,\n  CSSProperties[\"borderWidth\"]\n> = {\n  top: \"1px 0 0 0\",\n  bottom: \"0 0 1px 0\",\n  right: \"0 1px 0 0\",\n  left: \"0 0 0 1px\",\n  horizontal: \"0 1px\",\n  vertical: \"1px 0\",\n};\n\nconst SIDE_PADDING = 3;\nconst END_PADDING = 4;\n\nconst StyledShowMoreButton = styled.button`\n  all: unset;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ${borderStyle};\n`;\n\nconst StyledHorizontalToolbar = styled(StyledToolbar)`\n  padding: ${SIDE_PADDING}px ${END_PADDING}px;\n  max-width: 100%;\n  /*noinspection CssInvalidPropertyValue*/\n  max-width: -webkit-fill-available;\n  ${StyledHorizontalSeparator} {\n    margin: 1px 0;\n  }\n  ${StyledShowMoreButton} {\n    margin-right: -${END_PADDING}px;\n  }\n`;\n\nconst StyledVerticalToolbar = styled(StyledToolbar)`\n  flex-direction: column;\n  max-height: 100%;\n  /*noinspection CssInvalidPropertyValue*/\n  max-height: -webkit-fill-available;\n  padding: ${END_PADDING}px ${SIDE_PADDING}px;\n  ${StyledVerticalSeparator} {\n    margin: 0 1px;\n  }\n  ${StyledShowMoreButton} {\n    margin-bottom: -${END_PADDING}px;\n  }\n`;\n\nconst StyledToolbarContent = styled.div<{\n  shouldWrap?: boolean;\n  firstOverflowedIndex: number;\n}>`\n  box-sizing: inherit;\n  display: inherit;\n  flex-direction: inherit;\n  flex-wrap: ${({ shouldWrap }) => (shouldWrap ? \"wrap\" : \"nowrap\")};\n  gap: inherit;\n  max-height: inherit;\n  max-width: inherit;\n  min-height: 0;\n  min-width: 0;\n\n  ${({ firstOverflowedIndex }) =>\n    /**\n     * The hidden styles should be in a way that the hidden element:\n     * - occupies its space in the document layout.\n     * - doesn't capture mouse events. (e.g. a half-overflowing hidden element shouldn't show tooltip)\n     * - remains accessible to screen readers.\n     */\n    css`\n      > ${firstOverflowedIndex === 0\n          ? \"*\"\n          : `:nth-child(${firstOverflowedIndex}) ~ *`} {\n        opacity: 0 !important;\n        pointer-events: none !important;\n      }\n    `}\n`;\n// This can be used in other places if use-cases are raised for keeping orientation in the context.\nconst OrientationContext = React.createContext<\"horizontal\" | \"vertical\">(\n  \"horizontal\"\n);\n\n/**\n * ## Toolbar API/Implementation notes\n *\n * ### Handling Overflow\n *\n * Handling the overflow popup on DOM-level, allows for a simple and flexible implementation that doesn't\n * require any coupling between Toolbar and components like IconButton. Other components can also similarly be\n * rendered inside toolbar without adopting any specific API. It's worth noting that any generic approach based\n * on children react nodes instead of children DOM nodes will have many edge cases and will involve assumptions\n * that will limit the API of toolbar. Also, any approach based on moving dom nodes to the overflow popup will\n * conflict with React owning the DOM.\n *\n * #### Assumption\n *\n * Since the overflow popup renders the same `children`, and items in the toolbar and popup overflow are made\n * visible/hidden based on the index of DOM nodes, it's important than children deterministically results in the\n * same dom structure. i.e. if a component in children randomly renders different number of root dom nodes in\n * each render, it can cause issues in hiding/showing elements.\n *\n * ### Orientation\n * A few reasons for not having separate `HorizontalToolbar` and `VerticalToolbar` components instead of `Toolbar` with\n * `orientation` prop:\n * - From usage side, a single `Toolbar` component is considered a more discoverable API.\n * - Separate components would require abstracting common parts which unnecessarily adds to complexity.\n *   The amount of branching to handle the differences is considered ok, at the current state of the component.\n */\n\n/**\n * @description\n * A toolbar is a container for {@link IconButton} and similar UI components.\n *\n * ## Features:\n * - A toolbar can be horizontal or vertical\n * - When there is not enough space for all children, toolbar shows an arrow icon, which shows the overflowing\n *   items in a popup, upon mouseover.\n *   Optionally, overflow can be wrapped into multiple lines, in horizontal toolbars.\n *\n * @example\n * <Toolbar>\n *   <IconButton aria-label=\"Show Diff\">\n *     <PlatformIcon icon=\"actions/diff\" />\n *   </IconButton>\n *   </Toolbar>\n */\nexport const Toolbar: React.FC<ToolbarProps> = ({\n  border,\n  orientation = \"horizontal\",\n  ...props\n}): React.ReactElement => {\n  const overflowBehavior =\n    orientation === \"horizontal\" && \"overflowBehavior\" in props\n      ? props.overflowBehavior\n      : null;\n  const rootProps = { style: props.style, className: props.className };\n  const ref = useRef<HTMLDivElement>(null);\n  const overlayRef = useRef<HTMLDivElement>(null);\n  const showMoreButtonRef = useRef<HTMLButtonElement>(null);\n  const StyledToolbar =\n    orientation === \"horizontal\"\n      ? StyledHorizontalToolbar\n      : StyledVerticalToolbar;\n  const { overflowedElements } = useOverflowObserver(ref, { threshold: 0.8 });\n  const [isOverflowPopupVisible, setOverflowPopupVisible] = useState(false);\n  const [popupHeight, setPopupHeight] = useState(30);\n  const [firstOverflowedChildIndex, setFirstOverflowedChildIndex] =\n    useState<number>(-1);\n  const firstOverflowedChildRef = useRef<HTMLElement | undefined>();\n\n  useLayoutEffect(() => {\n    if (ref.current) {\n      const childElements = [...ref.current.children].filter(\n        (node): node is HTMLElement => node instanceof HTMLElement\n      );\n      const firstOverflowedChild = childElements.findIndex((child) =>\n        overflowedElements.includes(child)\n      );\n      setFirstOverflowedChildIndex(firstOverflowedChild);\n      firstOverflowedChildRef.current = childElements[firstOverflowedChild];\n    }\n  }, [overflowedElements]);\n\n  useLayoutEffect(() => {\n    if (overlayRef.current && popupHeight !== overlayRef.current.offsetHeight) {\n      setPopupHeight(overlayRef.current.offsetHeight);\n    }\n  });\n\n  const { overlayProps } = useOverlayPosition({\n    isOpen: isOverflowPopupVisible,\n    placement: \"bottom left\",\n    offset:\n      // in lack of positioning options for aligning bottom and left of of the overflow popup with the bottom and left\n      // of the toolbar itself, we have to measure the popup height, and use offset to achieve the same\n      orientation === \"horizontal\"\n        ? -popupHeight + SIDE_PADDING + 1\n        : -popupHeight + 1,\n    crossOffset:\n      orientation === \"horizontal\" ? -(SIDE_PADDING + 2) : -(SIDE_PADDING + 1),\n    containerPadding: 0,\n    shouldFlip: false,\n    targetRef: orientation === \"horizontal\" ? ref : showMoreButtonRef,\n    overlayRef: overlayRef,\n    onClose: () => {\n      setOverflowPopupVisible(false);\n    },\n  });\n\n  const showOverflowPopup = () => {\n    setOverflowPopupVisible(true);\n  };\n\n  const toolbarProps = {\n    onMouseMove: (event: MouseEvent) => {\n      const firstOverflowedElement = firstOverflowedChildRef.current;\n      if (!firstOverflowedElement) {\n        return;\n      }\n      const shouldShow =\n        orientation === \"vertical\"\n          ? event.clientY > firstOverflowedElement.getBoundingClientRect().top\n          : event.clientX > firstOverflowedElement.getBoundingClientRect().left;\n      if (shouldShow !== isOverflowPopupVisible) {\n        setOverflowPopupVisible(shouldShow);\n      }\n    },\n    onMouseLeave: () => {\n      if (isOverflowPopupVisible) {\n        setOverflowPopupVisible(false);\n      }\n    },\n  };\n  const toolbarOverflowPopupProps = {\n    onMouseEnter: () => setOverflowPopupVisible(true),\n    onMouseLeave: () => setOverflowPopupVisible(false),\n  };\n  return (\n    <OrientationContext.Provider value={orientation}>\n      <StyledToolbar\n        border={border}\n        {...mergeProps(rootProps, toolbarProps)}\n        role=\"toolbar\"\n      >\n        <StyledToolbarContent\n          ref={ref}\n          role=\"presentation\"\n          firstOverflowedIndex={firstOverflowedChildIndex}\n          shouldWrap={overflowBehavior === \"wrap\"}\n        >\n          {props.children}\n        </StyledToolbarContent>\n        {overflowedElements.length > 0 && (\n          <StyledShowMoreButton\n            ref={showMoreButtonRef}\n            tabIndex={-1}\n            onMouseEnter={showOverflowPopup}\n          >\n            <PlatformIcon icon=\"ide/link\" />\n          </StyledShowMoreButton>\n        )}\n      </StyledToolbar>\n      {isOverflowPopupVisible && overflowedElements.length > 0 && (\n        // Maybe more accessible to reuse the entire Popup here? it would require more flexible API to handle mouseleave though\n        // Note: we could also render the whole toolbar with the same props and only orientation being overwritten,\n        // but it has the risk of infinite overlay opening in some edge cases, and that level of generality doesn't\n        // seem to be necessary, at least at the moment.\n        <OrientationContext.Provider value=\"horizontal\">\n          <Overlay>\n            <StyledPopupContainer\n              ref={overlayRef}\n              {...mergeProps(overlayProps, toolbarOverflowPopupProps)}\n            >\n              <ToolbarInOverlay\n                border\n                firstVisibleIndex={\n                  orientation === \"vertical\"\n                    ? firstOverflowedChildIndex\n                    : undefined\n                }\n              >\n                {props.children}\n              </ToolbarInOverlay>\n            </StyledPopupContainer>\n          </Overlay>\n        </OrientationContext.Provider>\n      )}\n    </OrientationContext.Provider>\n  );\n};\n\nconst ToolbarInOverlay = styled(StyledHorizontalToolbar)<{\n  firstVisibleIndex?: number;\n}>`\n  ${({ firstVisibleIndex }) =>\n    firstVisibleIndex &&\n    css`\n      ${StyledSeparator}:nth-child(${firstVisibleIndex + 1}) {\n        display: none;\n      }\n      > :not(:nth-child(${firstVisibleIndex}) ~ *) {\n        display: none;\n      }\n    `};\n`;\n\n/**\n * Separator to be used between items in a toolbar.\n */\nexport const ToolbarSeparator = (): React.ReactElement => {\n  const orientation = useContext(OrientationContext);\n  return orientation === \"horizontal\" ? (\n    <StyledHorizontalSeparator />\n  ) : (\n    <StyledVerticalSeparator />\n  );\n};\n"],"names":[],"sourceRoot":""}