{"version":3,"file":"2199.88e34ef3.iframe.bundle.js","mappings":";;;;;;;;;AAqCA;AACA;;;;;;;;;;;AAWA;AAEA;;;;AAKA;AAEA;;AASA;;;;AChDA;;AAIA;;;;AAIA;AAMA;;ACZA;;AAiBA;AACA;;;;;;AAMA;;;AAKA;;;AAKA;;AAEA;;;AAGA;;;AAMA","sources":["webpack://@intellij-platform/core/./src/IconButton/IconButton.tsx","webpack://@intellij-platform/core/./src/Menu/MenuItemLayout.tsx","webpack://@intellij-platform/core/./src/Toolbar/Toolbar.tsx"],"sourcesContent":["import { PressProps, usePress } from \"@react-aria/interactions\";\nimport React, { ForwardedRef, HTMLProps } from \"react\";\nimport { styled } from \"../styled\";\nimport { mergeProps, useObjectRef } from \"@react-aria/utils\";\nimport { useFocusable } from \"@react-aria/focus\";\n\nexport interface IconButtonProps\n  extends PressProps,\n    // Maybe we should allow any arbitrary HTMLProps<HTMLButtonElement> props, instead of whitelisting?\n    Pick<\n      HTMLProps<HTMLButtonElement>,\n      \"onFocus\" | \"onBlur\" | \"style\" | \"className\"\n    > {\n  children?: React.ReactNode;\n  /**\n   * The minimum width/height of the button.\n   */\n  minSize?: number;\n  /**\n   * Whether the button should be focusable by pressing tab. The default is true for icon buttons (aka. action buttons),\n   * which means they are not included in the tab order.\n   */\n  excludeFromTabOrder?: boolean;\n}\n\nexport const DEFAULT_MINIMUM_BUTTON_SIZE = 22;\nexport const NAVBAR_MINIMUM_BUTTON_SIZE = 20;\n\nexport const StyledIconButton = styled.button<{ minSize: number }>`\n  position: relative; // to allow absolutely positioned overlays like an dropdown icon at the bottom right corner\n  background: none;\n  color: inherit;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  min-height: ${({ minSize }) => `${minSize}px`};\n  min-width: ${({ minSize }) => `${minSize}px`};\n  padding: 0;\n  margin: 0;\n  &:disabled {\n    opacity: 0.25; // not quite accurate implementation. There might be better ways to style disabled state.\n  }\n  &:hover:not(:disabled),\n  &:focus:not(:disabled) /* in intellij platform, the button doesn't grab the focus after being active. This is not the case in web,\n  for better accessibility. But there is no existing UI spec for it in intellij platform obviously. So for now, we\n  fallback to the same UI as hover state. Perhaps it can be improved with a opacity or something.*/ {\n    outline: none;\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBackground\", \"#DFDFDF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBorderColor\", \"#DFDFDF\")};\n  }\n  &:active:not(:disabled),\n  &.active:not(:disabled) {\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBackground\", \"#CFCFCF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBorderColor\", \"#CFCFCF\")};\n  }\n`;\n\n/**\n * Icon button, aka Action Button, in the reference implementation.\n * @see https://jetbrains.github.io/ui/controls/icon_button/\n */\nexport const IconButton = React.forwardRef(function IconButton(\n  {\n    minSize = DEFAULT_MINIMUM_BUTTON_SIZE,\n    preventFocusOnPress = true,\n    excludeFromTabOrder = true,\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    ...otherProps\n  }: IconButtonProps,\n  forwardedRef: ForwardedRef<HTMLButtonElement>\n) {\n  // FIXME: use useButton\n\n  const ref = useObjectRef(forwardedRef);\n  const { focusableProps } = useFocusable({ isDisabled }, ref);\n  const { pressProps, isPressed } = usePress({\n    ref,\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    preventFocusOnPress,\n  });\n\n  return (\n    <StyledIconButton\n      className={isPressed ? \"active\" : \"\"}\n      disabled={isDisabled}\n      {...mergeProps(pressProps, otherProps, focusableProps)}\n      minSize={minSize}\n      tabIndex={excludeFromTabOrder && !isDisabled ? -1 : undefined}\n      ref={ref}\n    />\n  );\n});\n","import React from \"react\";\nimport { ItemStateContext } from \"@intellij-platform/core/Collections/ItemStateContext\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { useContextOrThrow } from \"@intellij-platform/core/utils/useContextOrThrow\";\n\nimport { useMenuItemLayout } from \"./MenuItem\";\nimport { StyledMenuItemIcon } from \"./StyledMenuItem\";\n\ninterface MenuItemLayoutProps {\n  icon?: React.ReactNode;\n  content: React.ReactNode;\n  shortcut?: React.ReactNode;\n}\n\nconst StyledMenuItemLayout = styled.div`\n  display: flex;\n  align-items: center;\n  flex: 1; // to make sure it takes as much space as available in the menu item row, so that the suffix (shortcut) is pushed to the right\n`;\nconst Content = styled.span`\n  flex: 1;\n`;\n\nconst Shortcut = styled.kbd`\n  font-family: system-ui, sans-serif;\n  margin-left: 30px;\n  margin-right: -0.625rem;\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(\n      theme.color(\"MenuItem.acceleratorForeground\")\n    )};\n`;\n\nexport const MenuItemLayout = ({\n  content,\n  shortcut,\n  icon,\n}: MenuItemLayoutProps) => {\n  const { isSelected } = useContextOrThrow(\n    ItemStateContext,\n    \"MenuItemLayout is meant to be rendered in Item component in Menus\"\n  );\n  const { labelProps, keyboardShortcutProps } = useMenuItemLayout();\n  const allowedIcon = !isSelected && icon;\n  return (\n    <StyledMenuItemLayout>\n      {allowedIcon && <StyledMenuItemIcon>{allowedIcon}</StyledMenuItemIcon>}\n      <Content {...labelProps}>{content}</Content>\n      {shortcut && <Shortcut {...keyboardShortcutProps}>{shortcut}</Shortcut>}\n    </StyledMenuItemLayout>\n  );\n};\n","import React, { useContext } from \"react\";\nimport { Theme } from \"@intellij-platform/core/Theme\";\n\nimport { StyledIconButton } from \"../IconButton\";\nimport { styled } from \"../styled\";\nimport {\n  StyledHorizontalSeparator,\n  StyledVerticalSeparator,\n} from \"../StyledSeparator\";\n\ninterface ToolbarProps {\n  orientation?: \"vertical\" | \"horizontal\";\n  /**\n   * Whether to include a border to the bottom/right the toolbar, or not.\n   */\n  hasBorder?: boolean;\n}\nconst StyledToolbar = styled.div`\n  display: flex;\n`;\n\nconst getBorder = ({\n  theme,\n  hasBorder,\n}: {\n  theme: Theme;\n  hasBorder?: boolean;\n}) =>\n  hasBorder\n    ? `1px solid ${theme.color(\n        \"Borders.color\",\n        theme.dark ? \"rgb(50,50,50)\" : \"rgb(192, 192, 192)\"\n      )}`\n    : \"none\";\nconst StyledHorizontalToolbar = styled(StyledToolbar)<{\n  hasBorder?: boolean;\n}>`\n  padding: 2px;\n  border-bottom: ${getBorder};\n  ${StyledHorizontalSeparator} {\n    margin: 1px 2px;\n  }\n  // NOTE: in the original implementation, there is no empty space between buttons, but buttons have kind of an\n  // invisible left padding, which is mouse-intractable, but doesn't visually seem a part of the button.\n  // Although implementable, it didn't seem necessary to follow the exact same thing. Margin should be fine.\n  ${StyledIconButton} {\n    margin: 0 2px 0 2px;\n  }\n`;\n\nconst StyledVerticalToolbar = styled(StyledToolbar)<{\n  hasBorder?: boolean;\n}>`\n  flex-direction: column;\n  padding: 0 2px;\n  border-right: ${getBorder};\n\n  ${StyledVerticalSeparator} {\n    margin: 4px 1px;\n  }\n  ${StyledIconButton} {\n    margin: 2px 0 1px 0;\n  }\n`;\n\n// This can be used in other places if use-cases are raised for keeping orientation in the context.\nconst OrientationContext = React.createContext<\"horizontal\" | \"vertical\">(\n  \"horizontal\"\n);\n\n/**\n * Remaining features:\n * - overflow behaviour:\n *   - wrap. like main action toolbar.\n *   - hidden, shown by arrow. Similar to actions in Git->Log. Note that the behaviour for horizontal and vertical\n *     modes are different apparently.\n */\nexport const Toolbar: React.FC<ToolbarProps> = ({\n  orientation = \"horizontal\",\n  hasBorder = false,\n  children,\n}): React.ReactElement => {\n  return (\n    <OrientationContext.Provider value={orientation}>\n      {orientation === \"horizontal\" ? (\n        <StyledHorizontalToolbar hasBorder={hasBorder}>\n          {children}\n        </StyledHorizontalToolbar>\n      ) : (\n        <StyledVerticalToolbar hasBorder={hasBorder}>\n          {children}\n        </StyledVerticalToolbar>\n      )}\n    </OrientationContext.Provider>\n  );\n};\n\n/**\n * Separator to be used between items in a toolbar.\n */\nexport const ToolbarSeparator = (): React.ReactElement => {\n  const orientation = useContext(OrientationContext);\n  return orientation === \"horizontal\" ? (\n    <StyledHorizontalSeparator />\n  ) : (\n    <StyledVerticalSeparator />\n  );\n};\n"],"names":[],"sourceRoot":""}