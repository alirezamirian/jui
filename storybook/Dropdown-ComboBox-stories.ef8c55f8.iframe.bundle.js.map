{"version":3,"file":"Dropdown-ComboBox-stories.ef8c55f8.iframe.bundle.js","mappings":";;AAmFA;AASA;;;;;;AAMA;;AAKA;;;;AAIA;;;;;;AAMA;;;;;;;;;;;;;;;;AAuBA;;;AC5BA;AAGA;;;;AAMA;;;;;;ACzGA;AAIA;;AAOA;;;;AAQA;;;AAOA;;;AAOA;;;AAOA;;;;;;;;;ACrCA;;;ACOA;AAGA;;;;;;AAQA;;;;;;AAaA;;AC7BA;;;AAMA;AACA;;;AASA;;;;;;AClBA;AACA;;AAEA;;;;;;;ACFA;;AAEA;;;;AAMA;;ACVA;;;;;;;;;;;;ACQA;AACA;;AAEA;AAEA;;ACIA;AACA;AAEA;;AAEA;AACA;;;;ACtBA;AAEA;;AAGA;AAGA;AACA;AAEA;AAOA","sources":["webpack://@intellij-platform/core/./src/Dropdown/ComboBox.tsx","webpack://@intellij-platform/core/./src/Dropdown/StatelessListBox.tsx","webpack://@intellij-platform/core/./src/Dropdown/StyledContainer.tsx","webpack://@intellij-platform/core/./src/Dropdown/StyledDropdownArrowIcon.tsx","webpack://@intellij-platform/core/./src/Field/ContextHelp.tsx","webpack://@intellij-platform/core/./src/Field/Label.tsx","webpack://@intellij-platform/core/./src/Icon/StyledIconWrapper.tsx","webpack://@intellij-platform/core/./src/List/StyledList.tsx","webpack://@intellij-platform/core/./src/List/StyledListItem.tsx","webpack://@intellij-platform/core/./src/Overlay/Popover.tsx","webpack://@intellij-platform/core/./src/StyledSeparator.tsx","webpack://@intellij-platform/core/./src/Tooltip/ValidationTooltip.tsx"],"sourcesContent":["import React, {\n  CSSProperties,\n  ForwardedRef,\n  forwardRef,\n  HTMLProps,\n  Ref,\n  useRef,\n} from \"react\";\nimport { mergeProps, useObjectRef } from \"@react-aria/utils\";\nimport { AriaComboBoxProps, useComboBox } from \"@react-aria/combobox\";\nimport { useComboBoxState } from \"@react-stately/combobox\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { ControlledStateProps } from \"@intellij-platform/core/type-utils\";\nimport { BareButton } from \"@intellij-platform/core/Button\";\nimport { Popover } from \"@intellij-platform/core/Overlay\";\nimport { StatelessListBox } from \"./StatelessListBox\";\nimport { StyledContainer } from \"./StyledContainer\";\nimport { LabelPlacement, WithLabel } from \"../Field/Label\";\nimport { StyledDropdownArrowIcon } from \"./StyledDropdownArrowIcon\";\nimport {\n  PositionedTooltipTrigger,\n  ValidationTooltip,\n} from \"@intellij-platform/core/Tooltip\";\nimport {\n  ContextHelpProps,\n  WithInlineContextHelp,\n} from \"@intellij-platform/core/Field/ContextHelp\";\n\ntype AriaProps<T> = {\n  [K in keyof T as K extends `aria-${string}` ? K : never]: T[K];\n};\n\nexport interface ComboBoxProps<T extends object>\n  extends Pick<\n      AriaComboBoxProps<T>,\n      | \"disabledKeys\"\n      | \"defaultSelectedKey\"\n      | \"selectedKey\"\n      | \"isDisabled\"\n      | \"children\"\n      | \"items\"\n      | \"label\"\n      | \"autoFocus\"\n      | \"menuTrigger\"\n      | \"placeholder\"\n      | \"onFocus\"\n      | \"onBlur\"\n      | \"onKeyDown\"\n      | \"onKeyUp\"\n      | \"onOpenChange\"\n      | \"onFocusChange\"\n      | \"onSelectionChange\"\n    >,\n    AriaProps<AriaComboBoxProps<T>>,\n    ControlledStateProps<{\n      value: string;\n    }>,\n    ContextHelpProps {\n  labelPlacement?: LabelPlacement;\n  className?: string;\n  style?: CSSProperties;\n\n  validationState?: \"valid\" | \"error\" | \"warning\";\n\n  /**\n   * Validation message shown as a {@link ValidationTooltip} above the component.\n   * {@link ValidationTooltipProps#type} is defined based on `validationState`.\n   */\n  validationMessage?: React.ReactNode;\n\n  /**\n   * props to apply on input, excluding value that's controlled by the component\n   */\n  inputProps?: Omit<\n    HTMLProps<HTMLInputElement>,\n    \"value\" | \"defaultValue\" | \"as\"\n  >;\n  inputRef?: Ref<HTMLInputElement>;\n}\n\nconst StyledComboBoxContainer = styled(StyledContainer)`\n  padding: 0;\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\n          \"TextField.disabledForeground\" as UnknownThemeProp<\"TextField.disabledForeground\">\n        )\n      : theme.color(\n          \"TextField.foreground\" as UnknownThemeProp<\"TextField.foreground\">\n        )};\n`;\nconst StyledComboBoxInput = styled.input`\n  flex: 1;\n  background: none;\n  border: none;\n  outline: none;\n  color: inherit;\n  padding: ${({ theme }) =>\n    theme.inset(\"ComboBox.padding\") ?? \"1px 6px 1px 6px\"};\n  height: 100%;\n`;\n\nconst StyledDropdownButton = styled.button`\n  // Resetting default styles\n  appearance: none;\n  border: none;\n  background: ${({ theme }) => theme.color(\"ComboBox.ArrowButton.background\")};\n  outline: none;\n  font: inherit;\n  padding: 0;\n\n  // Custom styles\n  border-left: 1px solid ${({ theme }) => theme.commonColors.border()};\n  height: 100%;\n  aspect-ratio: 1;\n  /**\n   * In the reference impl, the clickable area exceeds the left border by a\n   * few pixels. The following trick implements that\n   */\n  position: relative;\n  ::before {\n    content: \"\";\n    position: absolute;\n    left: -4px;\n    top: 0;\n    bottom: 0;\n    width: 4px;\n  }\n`;\n\n/**\n * [Combobox](https://plugins.jetbrains.com/docs/intellij/combo-box.html) implementation.\n * Known differences with the reference impl:\n * - selected key doesn't focus when opened the dropdown manually.\n *   Opening the dropdown by pressing ArrowDown does focus the previously selected item.\n */\nexport const ComboBox = forwardRef(\n  <T extends object>(\n    {\n      labelPlacement,\n      style,\n      className,\n      value,\n      defaultValue,\n      onValueChange,\n      validationState,\n      validationMessage,\n      contextHelp,\n      contextHelpPlacement,\n      inputProps,\n      inputRef: inputRefProp,\n      ...props\n    }: ComboBoxProps<T>,\n    forwardedRef: ForwardedRef<HTMLDivElement>\n  ): React.JSX.Element => {\n    const ref = useObjectRef(forwardedRef);\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const inputRef = useObjectRef(inputRefProp);\n    const dropdownContainerRef = useRef<HTMLDivElement>(null);\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const listBoxRef = useRef<HTMLDivElement>(null);\n    const isInvalid = Boolean(validationState) && validationState !== \"valid\";\n\n    const state = useComboBoxState({\n      // defaultFilter not provided based on how ComboBoxes don't filter based on input in Intellij Platform\n      // filtering can still be implemented by controlling `value` and `items`.\n      menuTrigger: \"manual\", // overridable via props\n      allowsCustomValue: true,\n      inputValue: value,\n      defaultInputValue: defaultValue,\n      onInputChange: onValueChange,\n      isInvalid,\n      ...props,\n    });\n    const {\n      descriptionProps,\n      errorMessageProps,\n      labelProps,\n      inputProps: comboboxInputProps,\n      listBoxProps,\n      buttonProps,\n    } = useComboBox(\n      {\n        ...props,\n        allowsCustomValue: true,\n        buttonRef,\n        inputRef,\n        popoverRef,\n        listBoxRef,\n      },\n      state\n    );\n\n    // minWidth is not kept in the state, assuming it's unnecessary, considering the width is expected to be\n    // stable when the popover opens.\n    const minWidth = dropdownContainerRef.current\n      ? dropdownContainerRef.current?.offsetWidth + 2 /* for box shadow*/\n      : undefined;\n    return (\n      <>\n        <WithLabel\n          ref={ref}\n          isDisabled={props.isDisabled}\n          label={props.label}\n          labelPlacement={labelPlacement}\n          labelProps={labelProps}\n          className={className}\n          style={style}\n        >\n          {/* probably no need for HiddenSelect as autofilling doesn't seem relevant for applications using this library */}\n          <WithInlineContextHelp\n            contextHelp={contextHelp}\n            contextHelpPlacement={contextHelpPlacement}\n            descriptionProps={descriptionProps}\n          >\n            <StyledComboBoxContainer\n              ref={dropdownContainerRef}\n              validationState={validationState}\n              disabled={props.isDisabled}\n              className={state.isFocused ? \"is-focus\" : \"\"}\n            >\n              {/* FIXME: tooltip comes and goes on mouse enter/leave, which is especially weird when trying to open options */}\n              <PositionedTooltipTrigger\n                placement=\"top\"\n                showOnFocus\n                isDisabled={!validationMessage}\n                triggerRef={inputRef}\n                tooltip={\n                  <ValidationTooltip\n                    type={\n                      validationState !== \"valid\" ? validationState : undefined\n                    }\n                  >\n                    <div {...errorMessageProps}>{validationMessage}</div>\n                  </ValidationTooltip>\n                }\n                delay={0}\n              >\n                {(tooltipTriggerProps) => (\n                  <StyledComboBoxInput\n                    {...mergeProps(\n                      comboboxInputProps,\n                      inputProps,\n                      tooltipTriggerProps\n                    )}\n                  />\n                )}\n              </PositionedTooltipTrigger>\n\n              <BareButton {...buttonProps} ref={buttonRef}>\n                <StyledDropdownButton>\n                  <StyledDropdownArrowIcon\n                    disabled={props.isDisabled}\n                    size={20}\n                    icon=\"general/arrowDown.svg\"\n                  />\n                </StyledDropdownButton>\n              </BareButton>\n            </StyledComboBoxContainer>\n          </WithInlineContextHelp>\n        </WithLabel>\n        {state.isOpen && (\n          <Popover\n            ref={popoverRef}\n            state={state}\n            triggerRef={dropdownContainerRef}\n            placement=\"bottom start\"\n            containerPadding={0}\n            offset={2}\n            crossOffset={-1}\n          >\n            <StatelessListBox\n              {...listBoxProps}\n              ref={listBoxRef}\n              state={state}\n              style={{ minWidth }}\n            />\n          </Popover>\n        )}\n      </>\n    );\n  }\n);\n","import React, { CSSProperties, ForwardedRef } from \"react\";\nimport {\n  AriaListBoxOptions,\n  useListBox,\n  useListBoxSection,\n  useOption,\n} from \"@react-aria/listbox\";\nimport { useObjectRef } from \"@react-aria/utils\";\nimport { ListState } from \"@react-stately/list\";\nimport { Node } from \"@react-types/shared\";\n\nimport {\n  CollectionFocusProxyProps,\n  ItemStateContext,\n  useCollectionFocusProxy,\n} from \"@intellij-platform/core/Collections\";\nimport { StyledListItem } from \"@intellij-platform/core/List/StyledListItem\";\nimport { StyledList } from \"@intellij-platform/core/List/StyledList\";\nimport { StyledVerticalSeparator } from \"@intellij-platform/core/StyledSeparator\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\ninterface StatelessListBoxProps<T extends object>\n  extends AriaListBoxOptions<T>,\n    CollectionFocusProxyProps {\n  state: ListState<T>;\n  style?: CSSProperties;\n  className?: string;\n}\n\nexport const StatelessListBox = React.forwardRef(function StatelessListBox<\n  T extends object\n>(\n  {\n    state,\n    style,\n    className,\n    focusProxyRef,\n    ...props\n  }: StatelessListBoxProps<T>,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const ref = useObjectRef(forwardedRef);\n  const { listBoxProps, labelProps } = useListBox(props, state, ref);\n\n  useCollectionFocusProxy({\n    state,\n    collectionRef: ref,\n    focusProxyRef,\n    onAction: props.onAction,\n  });\n\n  return (\n    <>\n      <div {...labelProps}>{props.label}</div>\n      <StyledList\n        {...listBoxProps}\n        ref={ref}\n        style={style}\n        className={className}\n      >\n        {[...state.collection].map((item) =>\n          item.type === \"section\" ? (\n            <ListBoxSection key={item.key} section={item} state={state} />\n          ) : (\n            <Option key={item.key} item={item} state={state} />\n          )\n        )}\n      </StyledList>\n    </>\n  );\n});\nfunction Option<T extends object>({\n  item,\n  state,\n}: {\n  item: Node<T>;\n  state: ListState<T>;\n}) {\n  const ref = React.useRef<HTMLDivElement>(null);\n  const { optionProps } = useOption({ key: item.key }, state, ref);\n\n  const isDisabled = state.disabledKeys.has(item.key);\n  const isSelected = state.selectionManager.focusedKey === item.key;\n  return (\n    <ItemStateContext.Provider\n      value={{\n        isDisabled,\n        isContainerFocused: state.selectionManager.isFocused,\n        isSelected,\n        node: item,\n      }}\n    >\n      <StyledListItem\n        {...optionProps}\n        ref={ref}\n        disabled={isDisabled}\n        selected={isSelected}\n        containerFocused\n      >\n        {item.rendered}\n      </StyledListItem>\n    </ItemStateContext.Provider>\n  );\n}\n\nconst StyledSectionHeading = styled.div`\n  font-size: 0.6875rem;\n  padding: 0 0.5rem;\n  color: ${({ theme }) => theme.commonColors.inactiveTextColor}; // not verified\n`;\n\nconst StyledSection = styled.div`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nfunction ListBoxSection<T extends object>({\n  section,\n  state,\n}: {\n  section: Node<T>;\n  state: ListState<T>;\n}) {\n  let { itemProps, headingProps, groupProps } = useListBoxSection({\n    heading: section.rendered,\n    \"aria-label\": section[\"aria-label\"],\n  });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() && (\n        <StyledVerticalSeparator role=\"presentation\" />\n      )}\n      <li {...itemProps}>\n        {section.rendered && (\n          <StyledSectionHeading {...headingProps}>\n            {section.rendered}\n          </StyledSectionHeading>\n        )}\n        <StyledSection {...groupProps}>\n          {[\n            ...(state.collection.getChildren?.(section.key) ??\n              section.childNodes),\n          ].map((node) => (\n            <Option key={node.key} item={node} state={state} />\n          ))}\n        </StyledSection>\n      </li>\n    </>\n  );\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\n\nexport const StyledContainer = styled.div<{\n  disabled?: boolean;\n  validationState?: \"valid\" | \"error\" | \"warning\";\n}>`\n  box-sizing: border-box;\n  display: flex;\n  width: 100%;\n  align-items: center;\n  height: 1.5rem;\n  background: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"ComboBox.disabledBackground\")\n      : theme.color(\"ComboBox.background\")};\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"ComboBox.disabledForeground\")\n      : theme.color(\n          \"ComboBox.foreground\" as UnknownThemeProp<\"ComboBox.foreground\">\n        )};\n  border: 1px solid\n    ${({ theme, disabled, validationState }) =>\n      theme.commonColors.border({\n        disabled,\n        validationState,\n      })};\n  // The focus style is applied unconditionally in the reference impl, so no use of focus-visible or js-based focus visible detection\n\n  box-shadow: 0 0 0 0.125rem\n    ${({ theme, validationState }) =>\n      theme.commonColors.focusRing({\n        validationState,\n        focused: false,\n      })};\n  &:focus,\n  &.is-focus {\n    border-color: ${({ theme, validationState }) =>\n      theme.commonColors.border({\n        focused: true,\n        validationState,\n      })};\n    outline: none;\n    box-shadow: 0 0 0 0.125rem\n      ${({ theme, validationState }) =>\n        theme.commonColors.focusRing({\n          validationState,\n          focused: true,\n        })};\n  }\n\n  border-radius: ${({ theme }) => theme.borderRadius.default}px;\n`;\n","import { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport const StyledDropdownArrowIcon = styled(PlatformIcon).attrs<{\n  disabled?: boolean;\n}>({\n  \"aria-hidden\": \"true\",\n})`\n  // NOTE: \"ArrowButton.nonEditableBackground\" theme key is used in the reference impl, but it doesn't seem necessary to allow\n  // for a separate arrow background in Dropdown (aka non-editable combobox), since the arrow is not really a\n  // separate button, but a visual indicator for the whole trigger. Also there is no mention of it in designs\n  // There is also separate theme properties for color and disabled color, but inheriting it (via currentColor)\n  // makes more sense\n\n  * {\n    fill: ${({ theme, disabled }) =>\n      disabled\n        ? theme.color(\"ComboBox.ArrowButton.disabledIconColor\")\n        : theme.color(\"ComboBox.ArrowButton.iconColor\")};\n  }\n`;\n","import { css, styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { DOMAttributes, DOMProps } from \"@react-types/shared\";\n\n/**\n * Interface to inherit in props of components that support rendering context help.\n */\nexport interface ContextHelpProps {\n  /**\n   * Context help, shown below the input.\n   * A typical use case is\n   * [to provide example values](https://jetbrains.github.io/ui/principles/context_help/#07).\n   */\n  contextHelp?: React.ReactNode; // TODO: implement\n  /**\n   * Placement of the contextHelp text with respect to the control.\n   * See more: https://plugins.jetbrains.com/docs/intellij/inline-help-text.html#placement\n   */\n  contextHelpPlacement?: \"below\" | \"after\";\n}\n\nconst StyledContextHelp = styled.div`\n  color: ${({ theme }) => theme.commonColors.contextHelpForeground};\n`;\n\nconst StyledContextHelpWrapper = styled.div<{\n  placement: ContextHelpProps[\"contextHelpPlacement\"];\n}>`\n  font-size: 0.75rem; // 12px, in new UI. It's 11px in the old UI.\n  display: flex;\n  flex-direction: column;\n  align-items: start;\n  gap: 0.25rem; /* Not checked with the reference impl */\n  ${({ placement }) =>\n    placement === \"after\" &&\n    css`\n      flex-direction: row;\n      align-items: center;\n      gap: 1rem; /* Not checked with the reference impl */\n    `}\n  flex-grow: 1; /* Needed for when the control is inside a flex layout */\n`;\n\n/**\n * Implements [inline context help](https://plugins.jetbrains.com/docs/intellij/inline-help-text.html),\n * for its children.\n */\nexport const WithInlineContextHelp = ({\n  children,\n  descriptionProps,\n  contextHelpPlacement,\n  contextHelp,\n}: {\n  children: React.ReactNode;\n  /**\n   * Props to apply on the context help wrapper, to make the connected control\n   * described by the context help.\n   */\n  descriptionProps: DOMAttributes;\n} & ContextHelpProps) => {\n  return (\n    <StyledContextHelpWrapper placement={contextHelpPlacement}>\n      {children}\n      {contextHelp && (\n        <StyledContextHelp {...descriptionProps}>\n          {contextHelp}\n        </StyledContextHelp>\n      )}\n    </StyledContextHelpWrapper>\n  );\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React, {\n  ForwardedRef,\n  forwardRef,\n  RefObject,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport { DOMAttributes } from \"@react-types/shared\";\n\nexport type LabelPlacement = \"above\" | \"before\";\n\nconst StyledLabelContainer = styled.div<{\n  labelPlacement?: LabelPlacement;\n}>`\n  display: inline-flex;\n  flex-direction: ${({ labelPlacement }) =>\n    labelPlacement === \"above\" ? \"column\" : \"row\"};\n  align-items: start;\n  gap: 0.375rem;\n`;\n\nconst StyledLabel = styled.label<{ isDisabled?: boolean }>`\n  color: ${({ theme, isDisabled: disabled }) =>\n    theme.commonColors.label({ disabled })};\n  margin-top: 0.25rem;\n  line-height: 1.2;\n`;\n\n/**\n * Implements [label](https://jetbrains.github.io/ui/controls/input_field/#label),\n * for elements like Input, Dropdown, etc.\n */\nexport const WithLabel = forwardRef(function WithLabel(\n  {\n    label,\n    labelPlacement,\n    labelProps,\n    children,\n    isDisabled,\n    ...props\n  }: {\n    isDisabled: boolean | undefined;\n    label: React.ReactNode;\n    labelPlacement: LabelPlacement | undefined /* intentionally not optional */;\n    labelProps?: DOMAttributes;\n  } & DOMAttributes,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const labelRef = React.useRef<HTMLLabelElement>(null);\n  useAlignedLabels({ ref: labelRef, enabled: labelPlacement !== \"above\" });\n  return (\n    <StyledLabelContainer\n      {...props}\n      labelPlacement={labelPlacement}\n      ref={forwardedRef}\n    >\n      {label && (\n        <StyledLabel {...labelProps} isDisabled={isDisabled} ref={labelRef}>\n          {label}\n        </StyledLabel>\n      )}\n      {children}\n    </StyledLabelContainer>\n  );\n});\n\nfunction useAlignedLabels({\n  ref,\n  enabled,\n}: {\n  ref: RefObject<HTMLElement>;\n  enabled?: boolean;\n}) {\n  const { applyLabelWidth, commonWidth } = useContext(LabelAlignmentContext);\n  useLayoutEffect(() => {\n    const apply = (): boolean => {\n      const width = ref.current?.offsetWidth;\n      if (width) {\n        applyLabelWidth(width);\n        return true;\n      }\n      return false;\n    };\n    // In some situations, the width is zero in the first render.\n    if (!apply()) {\n      setTimeout(apply, 0);\n    }\n  });\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.style.width =\n        commonWidth && enabled ? `${commonWidth}px` : \"\";\n    }\n  }, [commonWidth, enabled]);\n}\n\nconst LabelAlignmentContext = React.createContext<{\n  commonWidth: number | null;\n  applyLabelWidth: (width: number) => void;\n}>({ commonWidth: null, applyLabelWidth: () => {} });\n\n/**\n * Provides a context for\n * [labeled input controls](https://jetbrains.github.io/ui/principles/layout/#labeled-input-controls)\n * with side-positioned labels to have their input boxes aligned.\n * It doesn't render anything in DOM and only provides a context used\n * by labeled controls to set a common width on labels so that the input boxes\n * align.\n * Labeled input controls are:\n * - {@link InputField}\n * - {@link ComboBox}\n * - {@link Dropdown}\n */\nexport function LabeledControlsAlignmentProvider({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const [commonWidth, setCommonWidth] = React.useState<null | number>(null);\n\n  const applyLabelWidth = (width: number) => {\n    setCommonWidth((currentWidth) =>\n      width > (currentWidth ?? 0)\n        ? width + 1 /* without 1px it wraps in some cases ¯\\_(ツ)_/¯ */\n        : currentWidth\n    );\n  };\n  return (\n    <LabelAlignmentContext.Provider value={{ commonWidth, applyLabelWidth }}>\n      {children}\n    </LabelAlignmentContext.Provider>\n  );\n}\n","import { styled } from \"../styled\";\nimport { IconSize } from \"@intellij-platform/core/Icon/IconProps\";\n\nconst DEFAULT_ICON_SIZE: IconSize = 16;\n\nexport const StyledIconWrapper = styled.span<{\n  size?: IconSize;\n  useCurrentColor?: boolean;\n  role?: string;\n}>`\n  box-sizing: border-box;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  line-height: 0;\n  width: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  height: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  position: relative; // to allow absolute positioned indicators and overlays on icon\n  cursor: ${({ role }) => (role === \"button\" ? \"pointer\" : undefined)};\n`;\n","import { css } from \"styled-components\";\nimport { styled } from \"../styled\";\n\ntype StyledListProps = {\n  fillAvailableSpace?: boolean;\n};\nexport const StyledList = styled.div\n  .attrs<StyledListProps>((props) => ({ role: props.role || \"list\" }))\n  .withConfig<StyledListProps>({\n    shouldForwardProp: (prop) => prop !== \"fillAvailableSpace\",\n  })<StyledListProps>`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  max-height: 100%;\n  overflow: auto;\n  color: ${({ theme }) => theme.color(\"*.textForeground\")};\n  outline: none;\n  ${({ fillAvailableSpace }) =>\n    fillAvailableSpace &&\n    css`\n      flex: 1;\n      height: fill-available; // will be converted to --webkit-fill-available and --moz-available, but doesn't work in FF\n    `}\n  background: ${({ theme }) => theme.color(\"List.background\")};\n`;\n","import { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { styled } from \"../styled\";\n\nexport type StyledListItemProps = {\n  containerFocused: boolean;\n  selected: boolean;\n  disabled: boolean;\n};\n\nexport const StyledListItem = styled.div.attrs<StyledListItemProps>(\n  (props) => ({\n    role: props.role || \"listitem\",\n  })\n)<StyledListItemProps>`\n  ${({ containerFocused, selected, disabled, theme }) => {\n    let backgroundColor;\n    let color = disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\n          \"List.foreground\" as UnknownThemeProp<\"List.foreground\">,\n          theme.commonColors.labelForeground\n        );\n    if (selected) {\n      if (containerFocused) {\n        color = theme.asCurrentForeground(\n          theme.color(\n            \"List.selectionForeground\" as UnknownThemeProp<\"List.selectionForeground\">\n          ) || theme.commonColors.labelSelectedForeground\n        ) /* Prioritizing \"*.selectionForeground\" over labelSelectedForeground*/;\n        backgroundColor = theme.color(\n          \"List.selectionBackground\" as UnknownThemeProp<\"List.selectionBackground\">\n        );\n      } else {\n        color = theme.color(\n          \"List.selectionInactiveForeground\" as UnknownThemeProp<\"List.selectionInactiveForeground\">,\n          color\n        );\n        backgroundColor = theme.color(\n          \"List.selectionBackgroundInactive\" as UnknownThemeProp<\"List.selectionBackgroundInactive\">\n        );\n      }\n    }\n    return {\n      backgroundColor: theme.asCurrentBackground(backgroundColor),\n      color,\n    };\n  }};\n  position: relative;\n  display: flex;\n  white-space: nowrap;\n  padding: 0 0.5rem; // themed?\n  line-height: 1.25rem;\n  outline: none;\n  cursor: default;\n  min-width: min-content; // Needed for content sizing for when list/tree is used inside popup or modal window\n`;\n","import React, { ForwardedRef } from \"react\";\nimport {\n  AriaPopoverProps,\n  DismissButton,\n  Overlay,\n  usePopover,\n} from \"@react-aria/overlays\";\nimport { OverlayTriggerState } from \"@react-stately/overlays\";\n\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\n\nimport { styled } from \"../styled\";\nimport { useObjectRef } from \"@react-aria/utils\";\n\nexport interface PopoverProps extends Omit<AriaPopoverProps, \"popoverRef\"> {\n  children: React.ReactNode;\n  state: OverlayTriggerState;\n}\n\nconst StyledPopover = styled.div`\n  box-sizing: border-box;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  outline: none; // Focus will be reflected in header. No need for outline or any other focus style on the container\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n`;\nexport const Popover = React.forwardRef(function Popover(\n  { children, state, offset = 8, ...props }: PopoverProps,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const popoverRef = useObjectRef(forwardedRef);\n  const { popoverProps } = usePopover(\n    {\n      ...props,\n      offset,\n      popoverRef,\n    },\n    state\n  );\n\n  return (\n    <Overlay>\n      {/* Rendering underlay doesn't seem necessary based on the reference impl */}\n      <StyledPopover {...popoverProps} ref={popoverRef}>\n        <DismissButton onDismiss={state.close} />\n        {children}\n        <DismissButton onDismiss={state.close} />\n      </StyledPopover>\n    </Overlay>\n  );\n});\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nexport const StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","import React from \"react\";\nimport { Tooltip } from \"@intellij-platform/core/Tooltip/Tooltip\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport interface ValidationTooltipProps {\n  children: React.ReactNode;\n  /**\n   * @default error\n   */\n  type?: \"error\" | \"warning\";\n}\n\nconst StyledValidationTooltip = styled(Tooltip)`\n  box-shadow: none;\n  padding: 0.25rem 0.5rem; // from ComponentValidator class in the reference impl\n  max-width: ${({ theme }) =>\n    `${theme.value<number>(\"ValidationTooltip.maxWidth\")}px`};\n  background: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.errorBackground\")};\n  border: 1px solid\n    ${({ theme }) => theme.color(\"ValidationTooltip.errorBorderColor\")};\n`;\n\nconst StyledWarningValidationTooltip = styled(StyledValidationTooltip)`\n  background: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.warningBackground\")};\n  border-color: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.warningBorderColor\")};\n`;\n\n/**\n * Tooltip to be used for validation error messages\n * @see https://jetbrains.github.io/ui/principles/validation_errors/\n */\nexport const ValidationTooltip = ({\n  type = \"error\",\n  children,\n}: ValidationTooltipProps): JSX.Element => {\n  const Component =\n    type === \"error\" ? StyledValidationTooltip : StyledWarningValidationTooltip;\n  return <Component multiline>{children}</Component>;\n};\n"],"names":[],"sourceRoot":""}