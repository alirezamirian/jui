{"version":3,"file":"ModalWindow-ModalWindow-stories.78eccb2f.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAqCA;AACA;;;;;;;AAOA;AAEA;;;;AAKA;AAEA;;;;AAQA;AAEA;;AASA;;;;;;;;AC7CA;;;;;;;ACjBA;AAGA;;;AASA;;ACdA;;;AAQA;;;;ACVA;AACA;;AAEA;;;ACqBA;AACA;AAEA;;AAEA;AACA;;;ACoBA;AACA;AAGA;;;;;;;;AAUA;AACA;;;AAGA;;;AAKA;;;;;AAoBA;AAGA;AAXA;;;;AAgBA;;;AAGA;AAlBA;;AAuBA;;;;;AAvBA;AA6BA;;;AAGA;AAhCA;;AAqCA;;;;AAOA;;;;;;;AAOA;AAQA;;;;;AASA;AAoMA;AAGA;;;AAGA;;;;AASA;AC7WA;AAEA","sources":["webpack://@intellij-platform/core/./src/IconButton/IconButton.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowHeader.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowFooter.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowLayout.tsx","webpack://@intellij-platform/core/./src/Popup/StyledPopupContainer.tsx","webpack://@intellij-platform/core/./src/StyledSeparator.tsx","webpack://@intellij-platform/core/./src/Toolbar/Toolbar.tsx","webpack://@intellij-platform/core/./src/story-components.tsx"],"sourcesContent":["import { PressProps, usePress } from \"@react-aria/interactions\";\nimport React, { ForwardedRef, HTMLProps } from \"react\";\nimport { styled } from \"../styled\";\nimport { mergeProps, useObjectRef } from \"@react-aria/utils\";\nimport { useFocusable } from \"@react-aria/focus\";\n\nexport interface IconButtonProps\n  extends PressProps,\n    // Maybe we should allow any arbitrary HTMLProps<HTMLButtonElement> props, instead of whitelisting?\n    Pick<\n      HTMLProps<HTMLButtonElement>,\n      \"onFocus\" | \"onBlur\" | \"style\" | \"className\"\n    > {\n  children?: React.ReactNode;\n  /**\n   * The minimum width/height of the button.\n   */\n  minSize?: number;\n  /**\n   * Whether the button should be focusable by pressing tab. The default is true for icon buttons (aka. action buttons),\n   * which means they are not included in the tab order.\n   */\n  excludeFromTabOrder?: boolean;\n}\n\nexport const DEFAULT_MINIMUM_BUTTON_SIZE = 22;\nexport const NAVBAR_MINIMUM_BUTTON_SIZE = 20;\n\nexport const StyledIconButton = styled.button<{ minSize: number }>`\n  position: relative; // to allow absolutely positioned overlays like an dropdown icon at the bottom right corner\n  background: none;\n  color: inherit;\n  border: 1px solid transparent;\n  border-radius: 3px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  min-height: ${({ minSize }) => `${minSize}px`};\n  min-width: ${({ minSize }) => `${minSize}px`};\n  padding: 0;\n  margin: 0;\n  &:disabled {\n    opacity: 0.25; // not quite accurate implementation. There might be better ways to style disabled state.\n  }\n  &:hover:not(:disabled) {\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBackground\", \"#DFDFDF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.hoverBorderColor\", \"#DFDFDF\")};\n  }\n  &:focus-visible:not(:disabled) {\n    outline: none;\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBackground\", \"#CFCFCF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\n        \"ActionButton.focusedBorderColor\",\n        theme.dark ? \"#5eacd0\" : \"#62b8de\"\n      )};\n  }\n  &:active:not(:disabled),\n  &.active:not(:disabled) {\n    background: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBackground\", \"#CFCFCF\")};\n    border-color: ${({ theme }) =>\n      theme.color(\"ActionButton.pressedBorderColor\", \"#CFCFCF\")};\n  }\n`;\n\n/**\n * Icon button, aka Action Button, in the reference implementation.\n * @see https://jetbrains.github.io/ui/controls/icon_button/\n */\nexport const IconButton = React.forwardRef(function IconButton(\n  {\n    minSize = DEFAULT_MINIMUM_BUTTON_SIZE,\n    preventFocusOnPress = true,\n    excludeFromTabOrder = true,\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    ...otherProps\n  }: IconButtonProps,\n  forwardedRef: ForwardedRef<HTMLButtonElement>\n) {\n  // FIXME: use useButton\n\n  const ref = useObjectRef(forwardedRef);\n  const { focusableProps } = useFocusable({ isDisabled }, ref);\n  const { pressProps, isPressed } = usePress({\n    ref,\n    isPressed: isPressedInput,\n    isDisabled,\n    onPress,\n    onPressChange,\n    onPressEnd,\n    onPressStart,\n    onPressUp,\n    shouldCancelOnPointerExit,\n    preventFocusOnPress,\n  });\n\n  return (\n    <StyledIconButton\n      className={isPressed ? \"active\" : \"\"}\n      disabled={isDisabled}\n      {...mergeProps(pressProps, otherProps, focusableProps)}\n      minSize={minSize}\n      tabIndex={excludeFromTabOrder && !isDisabled ? -1 : undefined}\n      ref={ref}\n    />\n  );\n});\n","import React, { HTMLAttributes, useContext } from \"react\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { OverlayMoveHandle } from \"@intellij-platform/core/Overlay\";\n\nimport { WindowContext } from \"./WindowContext\";\nimport { mergeProps } from \"@react-aria/utils\";\n\nconst StyledWindowTitle = styled.h1`\n  margin: 0;\n  text-align: center;\n  font-size: 13px; // not rem! intentional\n  line-height: 24px; // Double check\n  cursor: default;\n  user-select: none;\n  padding: 0 8px;\n`;\n\n/**\n * Implements appearance of Window header, and also acts as a handle for moving the window.\n * Expected to be used with {@link WindowLayout}:\n *\n * @example\n * ```tsx\n * <ModalWindow>\n *    <WindowLayout header={<WindowHeader>header</WindowHeader>} />\n * </ModalWindow>\n * ```\n */\nexport const WindowHeader = ({ children }: { children?: React.ReactNode }) => {\n  const { movable, titleProps } = useContext(WindowContext);\n  const renderTitle = (otherProps: HTMLAttributes<HTMLElement> = {}) => (\n    <StyledWindowTitle {...mergeProps(titleProps, otherProps)}>\n      {children || <>&nbsp;</>}\n    </StyledWindowTitle>\n  );\n  return movable ? (\n    <OverlayMoveHandle>\n      {({ moveHandleProps }) => renderTitle(moveHandleProps)}\n    </OverlayMoveHandle>\n  ) : (\n    renderTitle()\n  );\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { ButtonGroup } from \"@intellij-platform/core/ButtonGroup\";\n\nconst StyledFooter = styled.div<{ hasBorder?: boolean }>`\n  padding: 0.625rem 0.875rem;\n  display: flex;\n  gap: 0.5rem;\n  justify-content: space-between;\n  align-items: center;\n  border-top: 1px solid transparent;\n  border-color: ${({ hasBorder, theme }) =>\n    hasBorder && theme.commonColors.contrastBorder};\n`;\nconst StyledFooterSide = styled.div`\n  display: flex;\n  gap: 0.75rem;\n`;\n\n/**\n * Implements the common layout for window footer, to be used in {@link ModalWindowProps#footer}.\n * Footer has a left and a right side. There is a standard gap between the children of each side.\n */\nexport function WindowFooter({\n  left,\n  right,\n  hasBorder,\n}: {\n  /**\n   * The content to go to the left side the footer. A help icon button is very common on the left side.\n   */\n  left?: React.ReactNode;\n  /**\n   * The content to go to the right side the footer.\n   * {@link Button}s are usually used inside the right content.\n   * A {@link ButtonGroup} is rendered around the content to allow for keyboard navigation with arrow keys.\n   */\n  right?: React.ReactNode;\n  /**\n   * Whether to show top border for footer or not\n   */\n  hasBorder?: boolean;\n}) {\n  return (\n    <StyledFooter hasBorder={hasBorder}>\n      <StyledFooterSide>{left}</StyledFooterSide>\n      <StyledFooterSide>\n        <ButtonGroup>{right}</ButtonGroup>\n      </StyledFooterSide>\n    </StyledFooter>\n  );\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { WindowHeader } from \"./WindowHeader\";\nimport { WindowFooter } from \"@intellij-platform/core/ModalWindow/WindowFooter\";\n\nconst StyledWindowFooter = styled.div`\n  min-height: min-content;\n`;\n\nconst StyledWindowContentWrapper = styled.div`\n  overflow: auto;\n  flex: 1;\n`;\n\n/**\n * Window content layout, supporting fixed `header` and `footer` sections, and a scrollable `content` area.\n */\nexport function WindowLayout({\n  header,\n  footer,\n  content,\n}: {\n  /**\n   * Fixed position header of the window at the top. Use {@link WindowLayout.Header} for the default window header,\n   * which also acts as a move handle for the window. If a string is passed, it will be wrapped by\n   * {@link WindowLayout.Header} automatically.\n   */\n  header: React.ReactNode;\n  /**\n   * Scrollable content of the window.\n   */\n  content: React.ReactNode;\n  /**\n   * An area at the bottom of the window which is not scrolled as opposed to `content`. Use {@link WindowLayout.Footer}\n   * for rendering the common layout of a window footer.\n   */\n  footer?: React.ReactNode;\n}) {\n  return (\n    <>\n      {header &&\n        (typeof header === \"string\" ? (\n          <WindowHeader>{header}</WindowHeader>\n        ) : (\n          header\n        ))}\n      <StyledWindowContentWrapper>{content}</StyledWindowContentWrapper>\n      {footer && <StyledWindowFooter>{footer}</StyledWindowFooter>}\n    </>\n  );\n}\n\n// Just for improved discoverability. Might as well export WindowFooter and WindowHeader instead.\nWindowLayout.Footer = WindowFooter;\nWindowLayout.Header = WindowHeader;\n","import { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport const StyledPopupContainer = styled.div`\n  position: fixed;\n  box-sizing: border-box;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  outline: none; // Focus will be reflected in header. No need for outline or any other focus style on the container\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n`;\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nexport const StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","import React, {\n  CSSProperties,\n  MouseEvent,\n  useContext,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from \"react\";\n\nimport { styled, css } from \"../styled\";\nimport {\n  StyledHorizontalSeparator,\n  StyledSeparator,\n  StyledVerticalSeparator,\n} from \"../StyledSeparator\";\nimport { useOverflowObserver } from \"@intellij-platform/core/utils/overflow-utils/useOverflowObserver\";\nimport { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport { Overlay, useOverlayPosition } from \"@react-aria/overlays\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { StyledPopupContainer } from \"@intellij-platform/core/Popup/StyledPopupContainer\";\n\ntype ToolbarBorderProp =\n  | true\n  | \"horizontal\"\n  | \"vertical\"\n  | \"bottom\"\n  | \"top\"\n  | \"left\"\n  | \"right\";\n\nexport type ToolbarProps = {\n  children: React.ReactNode;\n  orientation?: \"vertical\" | \"horizontal\";\n  border?: ToolbarBorderProp;\n  style?: CSSProperties;\n  className?: string;\n} & (\n  | {\n      orientation: \"vertical\";\n    }\n  | {\n      orientation?: \"horizontal\";\n      /**\n       * Defines how the toolbar should handle its children when there is not enough room\n       * to fit all:\n       * - popup: the overflowed children will be hidden behind a show more arrow icon that\n       *   shows the rest of the items in a popup.\n       * - wrap: children will be wrapped so that they fit the available width/height\n       **/\n      overflowBehavior?: \"popup\" | \"wrap\";\n    }\n);\n\nconst borderStyle = ({ border }: { border?: ToolbarBorderProp }) =>\n  border &&\n  css`\n    border-style: solid;\n    border-color: ${({ theme }) => theme.commonColors.borderColor};\n    border-width: ${border === true ? \"1px\" : borderPropToCssProp[border]};\n  `;\n\nconst StyledToolbar = styled.div<{\n  border?: ToolbarBorderProp;\n}>`\n  display: inline-flex;\n  box-sizing: border-box;\n  overflow: hidden;\n  // NOTE: in the original implementation, there is no empty space between buttons, but buttons have kind of an\n  // invisible left padding, which is mouse-intractable, but doesn't visually seem a part of the button.\n  // Although implementable, it didn't seem necessary to follow the exact same thing. Margin should be fine.\n  gap: 4px;\n  ${borderStyle}\n  ${StyledSeparator}:first-child {\n    display: none;\n  }\n  ${StyledSeparator}:last-child {\n    display: none;\n  }\n`;\n\nconst borderPropToCssProp: Record<\n  Exclude<ToolbarBorderProp, boolean>,\n  CSSProperties[\"borderWidth\"]\n> = {\n  top: \"1px 0 0 0\",\n  bottom: \"0 0 1px 0\",\n  right: \"0 1px 0 0\",\n  left: \"0 0 0 1px\",\n  horizontal: \"0 1px\",\n  vertical: \"1px 0\",\n};\n\nconst SIDE_PADDING = 3;\nconst END_PADDING = 4;\n\nconst StyledShowMoreButton = styled.button`\n  all: unset;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  ${borderStyle};\n`;\n\nconst StyledHorizontalToolbar = styled(StyledToolbar)`\n  padding: ${SIDE_PADDING}px ${END_PADDING}px;\n  max-width: 100%;\n  /*noinspection CssInvalidPropertyValue*/\n  max-width: -webkit-fill-available;\n  ${StyledHorizontalSeparator} {\n    margin: 1px 0;\n  }\n  ${StyledShowMoreButton} {\n    margin-right: -${END_PADDING}px;\n  }\n`;\n\nconst StyledVerticalToolbar = styled(StyledToolbar)`\n  flex-direction: column;\n  max-height: 100%;\n  /*noinspection CssInvalidPropertyValue*/\n  max-height: -webkit-fill-available;\n  padding: ${END_PADDING}px ${SIDE_PADDING}px;\n  ${StyledVerticalSeparator} {\n    margin: 0 1px;\n  }\n  ${StyledShowMoreButton} {\n    margin-bottom: -${END_PADDING}px;\n  }\n`;\n\nconst StyledToolbarContent = styled.div<{\n  shouldWrap?: boolean;\n  firstOverflowedIndex: number;\n}>`\n  box-sizing: inherit;\n  display: inherit;\n  flex-direction: inherit;\n  flex-wrap: ${({ shouldWrap }) => (shouldWrap ? \"wrap\" : \"nowrap\")};\n  gap: inherit;\n  max-height: inherit;\n  max-width: inherit;\n  min-height: 0;\n  min-width: 0;\n\n  ${({ firstOverflowedIndex }) =>\n    /**\n     * The hidden styles should be in a way that the hidden element:\n     * - occupies its space in the document layout.\n     * - doesn't capture mouse events. (e.g. a half-overflowing hidden element shouldn't show tooltip)\n     * - remains accessible to screen readers.\n     */\n    css`\n      > ${firstOverflowedIndex === 0\n          ? \"*\"\n          : `:nth-child(${firstOverflowedIndex}) ~ *`} {\n        opacity: 0 !important;\n        pointer-events: none !important;\n      }\n    `}\n`;\n// This can be used in other places if use-cases are raised for keeping orientation in the context.\nconst OrientationContext = React.createContext<\"horizontal\" | \"vertical\">(\n  \"horizontal\"\n);\n\n/**\n * ## Toolbar API/Implementation notes\n *\n * ### Handling Overflow\n *\n * Handling the overflow popup on DOM-level, allows for a simple and flexible implementation that doesn't\n * require any coupling between Toolbar and components like IconButton. Other components can also similarly be\n * rendered inside toolbar without adopting any specific API. It's worth noting that any generic approach based\n * on children react nodes instead of children DOM nodes will have many edge cases and will involve assumptions\n * that will limit the API of toolbar. Also, any approach based on moving dom nodes to the overflow popup will\n * conflict with React owning the DOM.\n *\n * #### Assumption\n *\n * Since the overflow popup renders the same `children`, and items in the toolbar and popup overflow are made\n * visible/hidden based on the index of DOM nodes, it's important than children deterministically results in the\n * same dom structure. i.e. if a component in children randomly renders different number of root dom nodes in\n * each render, it can cause issues in hiding/showing elements.\n *\n * ### Orientation\n * A few reasons for not having separate `HorizontalToolbar` and `VerticalToolbar` components instead of `Toolbar` with\n * `orientation` prop:\n * - From usage side, a single `Toolbar` component is considered a more discoverable API.\n * - Separate components would require abstracting common parts which unnecessarily adds to complexity.\n *   The amount of branching to handle the differences is considered ok, at the current state of the component.\n */\n\n/**\n * @description\n * A toolbar is a container for {@link IconButton} and similar UI components.\n *\n * ## Features:\n * - A toolbar can be horizontal or vertical\n * - When there is not enough space for all children, toolbar shows an arrow icon, which shows the overflowing\n *   items in a popup, upon mouseover.\n *   Optionally, overflow can be wrapped into multiple lines, in horizontal toolbars.\n *\n * @example\n * <Toolbar>\n *   <IconButton aria-label=\"Show Diff\">\n *     <PlatformIcon icon=\"actions/diff\" />\n *   </IconButton>\n *   </Toolbar>\n */\nexport const Toolbar: React.FC<ToolbarProps> = ({\n  border,\n  orientation = \"horizontal\",\n  ...props\n}): React.ReactElement => {\n  const overflowBehavior =\n    orientation === \"horizontal\" && \"overflowBehavior\" in props\n      ? props.overflowBehavior\n      : null;\n  const rootProps = { style: props.style, className: props.className };\n  const ref = useRef<HTMLDivElement>(null);\n  const overlayRef = useRef<HTMLDivElement>(null);\n  const showMoreButtonRef = useRef<HTMLButtonElement>(null);\n  const StyledToolbar =\n    orientation === \"horizontal\"\n      ? StyledHorizontalToolbar\n      : StyledVerticalToolbar;\n  const { overflowedElements } = useOverflowObserver(ref, { threshold: 0.8 });\n  const [isOverflowPopupVisible, setOverflowPopupVisible] = useState(false);\n  const [popupHeight, setPopupHeight] = useState(30);\n  const [firstOverflowedChildIndex, setFirstOverflowedChildIndex] =\n    useState<number>(-1);\n  const firstOverflowedChildRef = useRef<HTMLElement | undefined>();\n\n  useLayoutEffect(() => {\n    if (ref.current) {\n      const childElements = [...ref.current.children].filter(\n        (node): node is HTMLElement => node instanceof HTMLElement\n      );\n      const firstOverflowedChild = childElements.findIndex((child) =>\n        overflowedElements.includes(child)\n      );\n      setFirstOverflowedChildIndex(firstOverflowedChild);\n      firstOverflowedChildRef.current = childElements[firstOverflowedChild];\n    }\n  }, [overflowedElements]);\n\n  useLayoutEffect(() => {\n    if (overlayRef.current && popupHeight !== overlayRef.current.offsetHeight) {\n      setPopupHeight(overlayRef.current.offsetHeight);\n    }\n  });\n\n  const { overlayProps } = useOverlayPosition({\n    isOpen: isOverflowPopupVisible,\n    placement: \"bottom left\",\n    offset:\n      // in lack of positioning options for aligning bottom and left of of the overflow popup with the bottom and left\n      // of the toolbar itself, we have to measure the popup height, and use offset to achieve the same\n      orientation === \"horizontal\"\n        ? -popupHeight + SIDE_PADDING + 1\n        : -popupHeight + 1,\n    crossOffset:\n      orientation === \"horizontal\" ? -(SIDE_PADDING + 2) : -(SIDE_PADDING + 1),\n    containerPadding: 0,\n    shouldFlip: false,\n    targetRef: orientation === \"horizontal\" ? ref : showMoreButtonRef,\n    overlayRef: overlayRef,\n    onClose: () => {\n      setOverflowPopupVisible(false);\n    },\n  });\n\n  const showOverflowPopup = () => {\n    setOverflowPopupVisible(true);\n  };\n\n  const toolbarProps = {\n    onMouseMove: (event: MouseEvent) => {\n      const firstOverflowedElement = firstOverflowedChildRef.current;\n      if (!firstOverflowedElement) {\n        return;\n      }\n      const shouldShow =\n        orientation === \"vertical\"\n          ? event.clientY > firstOverflowedElement.getBoundingClientRect().top\n          : event.clientX > firstOverflowedElement.getBoundingClientRect().left;\n      if (shouldShow !== isOverflowPopupVisible) {\n        setOverflowPopupVisible(shouldShow);\n      }\n    },\n    onMouseLeave: () => {\n      if (isOverflowPopupVisible) {\n        setOverflowPopupVisible(false);\n      }\n    },\n  };\n  const toolbarOverflowPopupProps = {\n    onMouseEnter: () => setOverflowPopupVisible(true),\n    onMouseLeave: () => setOverflowPopupVisible(false),\n  };\n  return (\n    <OrientationContext.Provider value={orientation}>\n      <StyledToolbar\n        border={border}\n        {...mergeProps(rootProps, toolbarProps)}\n        role=\"toolbar\"\n      >\n        <StyledToolbarContent\n          ref={ref}\n          role=\"presentation\"\n          firstOverflowedIndex={firstOverflowedChildIndex}\n          shouldWrap={overflowBehavior === \"wrap\"}\n        >\n          {props.children}\n        </StyledToolbarContent>\n        {overflowedElements.length > 0 && (\n          <StyledShowMoreButton\n            ref={showMoreButtonRef}\n            tabIndex={-1}\n            onMouseEnter={showOverflowPopup}\n          >\n            <PlatformIcon icon=\"ide/link\" />\n          </StyledShowMoreButton>\n        )}\n      </StyledToolbar>\n      {isOverflowPopupVisible && overflowedElements.length > 0 && (\n        // Maybe more accessible to reuse the entire Popup here? it would require more flexible API to handle mouseleave though\n        // Note: we could also render the whole toolbar with the same props and only orientation being overwritten,\n        // but it has the risk of infinite overlay opening in some edge cases, and that level of generality doesn't\n        // seem to be necessary, at least at the moment.\n        <OrientationContext.Provider value=\"horizontal\">\n          <Overlay>\n            <StyledPopupContainer\n              ref={overlayRef}\n              {...mergeProps(overlayProps, toolbarOverflowPopupProps)}\n            >\n              <ToolbarInOverlay\n                border\n                firstVisibleIndex={\n                  orientation === \"vertical\"\n                    ? firstOverflowedChildIndex\n                    : undefined\n                }\n              >\n                {props.children}\n              </ToolbarInOverlay>\n            </StyledPopupContainer>\n          </Overlay>\n        </OrientationContext.Provider>\n      )}\n    </OrientationContext.Provider>\n  );\n};\n\nconst ToolbarInOverlay = styled(StyledHorizontalToolbar)<{\n  firstVisibleIndex?: number;\n}>`\n  ${({ firstVisibleIndex }) =>\n    firstVisibleIndex &&\n    css`\n      ${StyledSeparator}:nth-child(${firstVisibleIndex + 1}) {\n        display: none;\n      }\n      > :not(:nth-child(${firstVisibleIndex}) ~ *) {\n        display: none;\n      }\n    `};\n`;\n\n/**\n * Separator to be used between items in a toolbar.\n */\nexport const ToolbarSeparator = (): React.ReactElement => {\n  const orientation = useContext(OrientationContext);\n  return orientation === \"horizontal\" ? (\n    <StyledHorizontalSeparator />\n  ) : (\n    <StyledVerticalSeparator />\n  );\n};\n","import { Selection } from \"@react-types/shared\";\nimport React, { HTMLProps, Key } from \"react\";\nimport { styled } from \"./styled\";\nimport { SpeedSearchTree, TreeRefValue } from \"@intellij-platform/core/Tree\";\nimport { staticSpeedSearchTreeItems } from \"@intellij-platform/core/Tree/story-helpers\";\n\nexport const Container = styled.div`\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n`;\nexport const Pane: React.FC<Omit<HTMLProps<HTMLDivElement>, \"style\">> = (\n  props\n) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"column\",\n      width: 400,\n      marginTop: 25,\n      height: \"calc(100vh - 70px)\",\n    }}\n    {...props}\n  />\n);\n\nexport function SelectionLog({ selection }: { selection: Selection }) {\n  return (\n    <pre>\n      {selection instanceof Set && (\n        <div>{JSON.stringify([...selection], null, 2)}</div>\n      )}\n      {JSON.stringify(selection, null, 2)}\n    </pre>\n  );\n}\n\ntype SelectedKeysType = \"all\" | Iterable<Key>;\nexport const SpeedSearchTreeSample = ({\n  selectedKeys,\n  defaultSelectedKeys = [\"BasicList\"],\n  onSelectedKeysChange,\n  treeRef,\n}: {\n  selectedKeys?: SelectedKeysType;\n  defaultSelectedKeys?: SelectedKeysType;\n  onSelectedKeysChange?: (selectedKeys: Selection) => void;\n  treeRef?: React.RefObject<TreeRefValue>;\n}): React.ReactElement => {\n  return (\n    <SpeedSearchTree\n      treeRef={treeRef}\n      autoFocus\n      fillAvailableSpace\n      selectionMode=\"multiple\"\n      defaultExpandedKeys={[\"List\", \"Theme\", \"BasicList\", \"Foo\"]}\n      selectedKeys={selectedKeys}\n      defaultSelectedKeys={new Set(defaultSelectedKeys)}\n      onSelectionChange={onSelectedKeysChange}\n    >\n      {staticSpeedSearchTreeItems}\n    </SpeedSearchTree>\n  );\n};\n"],"names":[],"sourceRoot":""}