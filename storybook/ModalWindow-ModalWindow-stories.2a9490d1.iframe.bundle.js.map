{"version":3,"file":"ModalWindow-ModalWindow-stories.2a9490d1.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;AASA;AAEA;;AAOA;AAIA;AAEA;;;;;;;AAaA;;AAGA;;AAWA;AACA;AAEA;AAEA;;;AAIA;;AAKA;;;;;;;;;;;ACkBA;;AAIA;AAWA;;;;;;;;;AAkBA;;;;ACrFA;;;AAGA;AACA;;AAEA;;AASA;;;;;AAUA;;;;;;;;AC5BA;;;;;;;AClBA;AAGA;;;AASA;;ACbA;;;AAQA;;ACcA;AACA;AAEA;;AAEA;AACA;;AC9BA;AAEA","sources":["webpack://@intellij-platform/core/./src/Button/StyledButton.tsx","webpack://@intellij-platform/core/./src/Checkbox/Checkbox.tsx","webpack://@intellij-platform/core/./src/ModalWindow/ModalWindow.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowHeader.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowFooter.tsx","webpack://@intellij-platform/core/./src/ModalWindow/WindowLayout.tsx","webpack://@intellij-platform/core/./src/StyledSeparator.tsx","webpack://@intellij-platform/core/./src/story-components.tsx"],"sourcesContent":["import { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\n\nexport const StyledButton = styled.button<{ disabled?: boolean }>`\n  box-sizing: border-box;\n  min-width: 4.5rem; // https://jetbrains.github.io/ui/controls/button/#28\n  padding: 0 0.875rem; // https://jetbrains.github.io/ui/controls/button/#28\n  height: 1.5rem;\n  font-family: inherit;\n  background-color: ${({ theme, disabled }) =>\n    disabled ? \"transparent\" : theme.color(\"Button.startBackground\")};\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"Button.disabledText\")\n      : theme.color(\n          \"Button.foreground\" as UnknownThemeProp<\"Button.foreground\">\n        )};\n  border: 1px solid\n    ${({ theme, disabled }) =>\n      disabled\n        ? theme.color(\"Button.disabledBorderColor\")\n        : theme.color(\"Button.startBorderColor\")};\n  border-radius: ${({ theme }) =>\n    (theme.value<number>(\"Button.arc\") ?? 6) / 2}px;\n  box-shadow: ${({ theme }) =>\n    theme.value(\"Button.paintShadow\")\n      ? `0 0 0 ${theme.value(\"Button.shadowWidth\") ?? 2}px ${\n          theme.color(\"Button.shadowColor\") ?? // Button.darcula.shadowColor default is skipped.\n          (theme.dark ? \"#36363680\" : \"#a6a6a633\")\n        }`\n      : \"\"};\n  white-space: nowrap; // https://jetbrains.github.io/ui/controls/button/#29\n\n  flex-shrink: 0; // button should not shrink when rendered in a flex container\n\n  &:focus,\n  &.focus /* for testing purposes*/ {\n    border-color: ${({ theme }) =>\n      theme.color(\"Button.focusedBorderColor\", \"#87afda\")};\n    outline: none;\n    box-shadow: ${({ theme }) =>\n      `0 0 0 2px ${\n        // NOTE: by not using the second argument for default value, we prioritize *.focusColor over the rest.\n        theme.color(\"Component.focusColor\") ??\n        theme.color(\n          \"Focus.borderColor\" as UnknownThemeProp<\"Focus.borderColor\">,\n          \"#8ab2eb\"\n        )\n      }`};\n  }\n`;\nexport const StyledDefaultButton = styled(StyledButton)`\n  background-color: ${({ theme, disabled }) =>\n    !disabled && theme.color(\"Button.default.startBackground\", \"#384f6b\")};\n  color: ${({ theme, disabled }) =>\n    !disabled && theme.color(\"Button.default.foreground\")};\n  border-color: ${({ theme, disabled }) =>\n    !disabled && theme.color(\"Button.default.startBorderColor\", \"#BFBFBF\")};\n  &:focus,\n  &.focus /* for testing purposes*/ {\n    border-color: ${({ theme }) =>\n      theme.color(\"Button.default.focusedBorderColor\", \"#87afda\")};\n  }\n`;\n\nexport const StyledIconButton = styled(StyledButton)`\n  border-radius: 1000px;\n  padding: 0;\n  line-height: 0;\n  min-width: 0;\n  height: 1.5rem;\n  width: 1.5rem;\n`;\n","import React, { HTMLProps, ReactNode } from \"react\";\nimport { useToggleState } from \"@react-stately/toggle\";\nimport { useCheckbox } from \"@react-aria/checkbox\";\nimport {\n  AriaLabelingProps,\n  FocusableDOMProps,\n  FocusableProps,\n  InputBase,\n} from \"@react-types/shared\";\nimport { useFocusRing } from \"@react-aria/focus\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nimport { CheckboxIcon } from \"./CheckboxIcon\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\n\nexport interface CheckboxProps\n  extends InputBase,\n    FocusableDOMProps,\n    AriaLabelingProps,\n    FocusableProps {\n  /**\n   * If set to true, the checkbox won't be focusable.\n   * Common use cases:\n   * - When checkbox is rendered in a focusable container, like a list item where the focus should not be taken away\n   *   from that container.\n   * - \"Amend\" checkbox in \"Commit\" tool window. The focus is kept in the commit message or changes tree, perhaps, for\n   *   a questionably better UX.\n   * Note: Passing {@link excludeFromTabOrder} will still let the checkbox be focusable, while `preventFocus`, doesn't\n   * let the component get focused at all.\n   * TODO(potential): it might be nicer to have a `preventFocusOnPress` prop consistent with IconButton, instead.\n   *  In that case preventing focus completely would be achieved with `preventFocusOnPres` and `excludeFromTabOrder`.\n   */\n  preventFocus?: boolean;\n\n  /**\n   * By default, focus ring is always shown when the checkbox is focused, independent of the interaction method.\n   * if set to false, the focus will be only visible if the interaction is done via keyboard or screen readers.\n   * Similar to how [:focus-visible](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible) works.\n   */\n  disableFocusAlwaysVisible?: boolean;\n\n  /**\n   * Indeterminism is presentational only.\n   * The indeterminate visual representation remains regardless of user interaction.\n   */\n  isIndeterminate?: boolean;\n\n  /**\n   * The label for the element.\n   */\n  children?: ReactNode;\n\n  /**\n   * Whether the element should be selected (uncontrolled).\n   */\n  defaultSelected?: boolean;\n  /**\n   * Whether the element should be selected (controlled).\n   */\n  isSelected?: boolean;\n  /**\n   * Handler that is called when the element's selection state changes.\n   */\n  onChange?: (isSelected: boolean) => void;\n  /**\n   * The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue).\n   */\n  value?: string;\n  /**\n   * The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).\n   */\n  name?: string;\n\n  className?: string; // to support styled-components\n}\n\nconst StyledWrapperLabel = styled.label`\n  position: relative;\n  display: inline-flex;\n  align-items: center;\n`;\n\nconst StyledCheckboxLabelText = styled.span<{\n  isDisabled: boolean | undefined;\n}>`\n  margin-left: 0.25rem;\n  color: ${({ theme, isDisabled }) =>\n    isDisabled\n      ? theme.color(\n          \"CheckBox.disabledText\" as UnknownThemeProp<\"CheckBox.disabledText\">,\n          \"#808080\" /* this default value was a bit tricky. Still not clear from where it comes in darcular \n          theme when there is no clue of Checkbox.disabledText or *.disabledText. Note that using \n          CheckBox.disabledForeground is not a good option, because it's something other than #808080 for darcula */\n        )\n      : theme.color(\"*.foreground\")};\n`;\n\nconst StyledInput = styled.input`\n  opacity: 0.0001;\n  position: absolute;\n  z-index: 1;\n  inset: 0;\n  cursor: default;\n  &:disabled {\n    cursor: default;\n  }\n`;\n\n/**\n * Checkbox component to be used with or without a label.\n *\n * While the checkbox without the label + preventFocus makes it usable in tree/list, it might be more optimized to\n * use a more lightweight component like ListItemCheckbox, which uses CheckboxIcon with a simple press handle. Without\n * any input, state, etc.\n */\nexport const Checkbox = ({\n  preventFocus,\n  className,\n  disableFocusAlwaysVisible,\n  ...props\n}: CheckboxProps) => {\n  const state = useToggleState(props);\n  const ref = React.useRef<HTMLInputElement>(null);\n  const { inputProps } = useCheckbox(props, state, ref);\n\n  const { isFocusVisible, isFocused, focusProps } = useFocusRing({\n    autoFocus: props.autoFocus,\n  });\n\n  const focusDisabledProps: Pick<\n    HTMLProps<HTMLInputElement>,\n    \"onFocusCapture\" | \"tabIndex\"\n  > = preventFocus\n    ? {\n        onFocusCapture: (event) => {\n          event.stopPropagation();\n          event.preventDefault();\n          if (event.relatedTarget instanceof HTMLElement) {\n            event.relatedTarget.focus();\n          } else {\n            event.target.blur();\n          }\n        },\n        tabIndex: -1,\n      }\n    : {};\n\n  return (\n    <StyledWrapperLabel className={className}>\n      <StyledInput\n        {...mergeProps(inputProps, focusProps, focusDisabledProps)}\n        ref={ref}\n      />\n      <CheckboxIcon\n        isIndeterminate={props.isIndeterminate}\n        isFocused={disableFocusAlwaysVisible ? isFocusVisible : isFocused}\n        isSelected={props.isIndeterminate || state.isSelected}\n        isDisabled={props.isDisabled}\n        aria-hidden=\"true\"\n        style={{\n          pointerEvents: \"none\",\n        }}\n      />\n      {props.children && (\n        <StyledCheckboxLabelText isDisabled={props.isDisabled}>\n          {props.children}\n        </StyledCheckboxLabelText>\n      )}\n    </StyledWrapperLabel>\n  );\n};\n","import React, { FocusEventHandler, useContext, useRef } from \"react\";\nimport { useModal, useOverlay, usePreventScroll } from \"@react-aria/overlays\";\nimport { focusSafely, FocusScope } from \"@react-aria/focus\";\nimport { useDialog } from \"@react-aria/dialog\";\nimport { AriaDialogProps } from \"@react-types/dialog\"; // temporary phantom dependency\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\nimport { mergeProps } from \"@react-aria/utils\";\nimport {\n  OverlayInteractionHandler,\n  OverlayResizeHandles,\n  ResizableMovableOverlayOptions,\n  useResizableMovableOverlay,\n} from \"@intellij-platform/core/Overlay\";\nimport { WindowContext } from \"@intellij-platform/core/ModalWindow/WindowContext\";\nimport { UNSAFE_React17SuspenseFix } from \"@intellij-platform/core/Overlay/UNSAFE_React17SuspenseFix\";\n\nexport interface ModalWindowProps\n  extends AriaDialogProps,\n    ResizableMovableOverlayOptions {\n  children: React.ReactNode;\n  className?: string;\n  onClose?: () => void;\n}\n\nconst StyledWindowUnderlay = styled.div`\n  position: fixed;\n  z-index: 1000; // FIXME: z-index should not be hard-coded like this\n  inset: 0;\n`;\n\nexport const StyledWindowContainer = styled.div`\n  position: fixed;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  border-radius: 8px;\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n  outline: 1px solid #555; // FIXME\n`;\n\n/**\n * only needed for setting overflow to hidden to make sure nothing will overflow a window under any circumstances.\n * The reason we can't set that overflow: \"hidden\" on the StyledWindowContainer itself is that we want resize handles\n * to overflow without bing clipped.\n */\nconst StyledWindowInnerContainer = styled.div`\n  height: inherit;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n`;\n\nexport const DEFAULT_WINDOW_MIN_WIDTH = 50;\nexport const DEFAULT_WINDOW_MIN_HEIGHT = 24;\n\nexport const WindowControllerContext = React.createContext<\n  Partial<Pick<ModalWindowProps, \"onClose\">>\n>({});\n\n/**\n * A movable/resizable modal window. The window header which holds the title, can be used to drag the window around.\n * In the reference impl, modal windows are os-native, and contain os-level buttons for minimize/close/maximise, which\n * are not relevant here since they wouldn't be os-native windows. A close button is still relevant (and kind of\n * necessary) and will be added in next iterations.\n *\n * The content container doesn't come with any padding. Other related components should be used for common layouts in\n * modal windows.\n * Example use cases: Window for git operations such as push, update, revert, new branch, etc.\n *\n * ![img.png](https://user-images.githubusercontent.com/3150694/181095858-968c5c66-2ae7-4e40-84e3-e6df43cd4aa4.png)\n *\n * NOTE: The part regarding rendering OverlayInteractionHandler, and rendering as a dialog with a focus scope, in an\n * overlay container could be extracted into a component which is then used to create custom resizable/movable overlay\n * dialogs, like \"Branches\", or \"Search Everywhere\".\n *\n * TODO: show close button (maybe os-aware styles?)\n *\n */\nexport const ModalWindow = ({\n  interactions = \"all\",\n  minWidth = DEFAULT_WINDOW_MIN_WIDTH,\n  minHeight = DEFAULT_WINDOW_MIN_HEIGHT,\n  className,\n  ...props\n}: ModalWindowProps): React.ReactElement => {\n  const { children } = props;\n  const propsContext = useContext(WindowControllerContext);\n  const onClose = () => {\n    propsContext.onClose?.();\n    props.onClose?.();\n  };\n\n  const ref = React.useRef<HTMLDivElement>(null);\n  const { overlayProps, underlayProps } = useOverlay(\n    {\n      isOpen: true, // maybe allow rendering closed window? :-?\n      onClose,\n      isDismissable: false,\n      isKeyboardDismissDisabled: false,\n      shouldCloseOnBlur: false,\n    },\n    ref\n  );\n  usePreventScroll();\n  const { modalProps } = useModal();\n\n  const { dialogProps, titleProps } = useDialog(props, ref);\n\n  const {\n    bounds: style,\n    overlayInteractionHandlerProps,\n    UNSAFE_measureContentSize,\n  } = useResizableMovableOverlay(ref, { ...props, minHeight, minWidth });\n\n  const { focusContainmentFixProps } = useFocusContainmentFix();\n\n  return (\n    <StyledWindowUnderlay {...underlayProps} className={className}>\n      <OverlayInteractionHandler {...overlayInteractionHandlerProps}>\n        <FocusScope contain restoreFocus autoFocus>\n          <StyledWindowContainer\n            {...mergeProps(\n              overlayProps,\n              dialogProps,\n              modalProps,\n              focusContainmentFixProps,\n              { style }\n            )}\n            ref={ref}\n          >\n            <StyledWindowInnerContainer>\n              <WindowContext.Provider\n                value={{\n                  isActive: true, // because it's modal. WindowContext would be used for non-modal windows too, in future\n                  titleProps,\n                  movable: interactions !== \"none\",\n                }}\n              >\n                <UNSAFE_React17SuspenseFix\n                  measureContentSize={UNSAFE_measureContentSize}\n                >\n                  {children}\n                </UNSAFE_React17SuspenseFix>\n              </WindowContext.Provider>\n            </StyledWindowInnerContainer>\n            {interactions === \"all\" && <OverlayResizeHandles />}\n          </StyledWindowContainer>\n        </FocusScope>\n      </OverlayInteractionHandler>\n    </StyledWindowUnderlay>\n  );\n};\n\n/**\n * The way FocusScope is implemented at the moment, it's possible for another focus scope to steal the focus,\n * right after the modal window is opened. The issue is not tracked down to the root cause. But with this hook,\n * we make sure there is no way for focus to go out of the modal window, when it's mounted.\n */\nfunction useFocusContainmentFix<T extends HTMLElement>() {\n  const lastFocusedElementRef = useRef<HTMLElement | null>(null);\n  const onFocus: FocusEventHandler<T> = (e) => {\n    lastFocusedElementRef.current = e.target;\n  };\n  const onBlur: FocusEventHandler = (e) => {\n    const probablyFocusedElement = e.relatedTarget;\n    if (\n      !probablyFocusedElement ||\n      (probablyFocusedElement instanceof Element &&\n        !e.currentTarget.contains(probablyFocusedElement))\n    ) {\n      const elementToFocus = lastFocusedElementRef.current;\n      if (elementToFocus) {\n        focusSafely(elementToFocus);\n      }\n    }\n  };\n  return {\n    focusContainmentFixProps: {\n      onFocus,\n      onBlur,\n    },\n  };\n}\n","import React, { HTMLAttributes, useContext } from \"react\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { OverlayMoveHandle } from \"@intellij-platform/core/Overlay\";\n\nimport { WindowContext } from \"./WindowContext\";\nimport { mergeProps } from \"@react-aria/utils\";\n\nconst StyledWindowTitle = styled.h1`\n  margin: 0;\n  text-align: center;\n  font-size: 13px; // not rem! intentional\n  line-height: 24px; // Double check\n  cursor: default;\n  user-select: none;\n  padding: 0 8px;\n`;\n\n/**\n * Implements appearance of Window header, and also acts as a handle for moving the window.\n * Expected to be used with {@link WindowLayout}:\n *\n * @example\n * ```tsx\n * <ModalWindow>\n *    <WindowLayout header={<WindowHeader>header</WindowHeader>} />\n * </ModalWindow>\n * ```\n */\nexport const WindowHeader = ({ children }: { children?: React.ReactNode }) => {\n  const { movable, titleProps } = useContext(WindowContext);\n  const renderTitle = (otherProps: HTMLAttributes<HTMLElement> = {}) => (\n    <StyledWindowTitle {...mergeProps(titleProps, otherProps)}>\n      {children || <>&nbsp;</>}\n    </StyledWindowTitle>\n  );\n  return movable ? (\n    <OverlayMoveHandle>\n      {({ moveHandleProps }) => renderTitle(moveHandleProps)}\n    </OverlayMoveHandle>\n  ) : (\n    renderTitle()\n  );\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\n\nconst StyledFooter = styled.div<{ hasBorder?: boolean }>`\n  padding: 0.625rem 0.875rem;\n  display: flex;\n  gap: 0.5rem;\n  justify-content: space-between;\n  align-items: center;\n  border-top: 1px solid transparent;\n  border-color: ${({ hasBorder, theme }) =>\n    hasBorder && theme.commonColors.contrastBorder};\n`;\nconst StyledFooterSide = styled.div`\n  display: flex;\n  gap: 0.75rem;\n`;\n\n/**\n * Implements the common layout for window footer, to be used in {@link ModalWindowProps#footer}.\n * Footer has a left and a right side. There is a standard gap between the children of each side.\n */\nexport function WindowFooter({\n  left,\n  right,\n  hasBorder,\n}: {\n  /**\n   * The content to go to the left side the footer. A help icon button is very common on the left side.\n   */\n  left?: React.ReactNode;\n  /**\n   * The content to go to the right side the footer. {@link Button}s are usually used inside the right content\n   */\n  right?: React.ReactNode;\n  /**\n   * Whether to show top border for footer or not\n   */\n  hasBorder?: boolean;\n}) {\n  return (\n    <StyledFooter hasBorder={hasBorder}>\n      <StyledFooterSide>{left}</StyledFooterSide>\n      <StyledFooterSide>{right}</StyledFooterSide>\n    </StyledFooter>\n  );\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { WindowHeader } from \"./WindowHeader\";\nimport { WindowFooter } from \"@intellij-platform/core/ModalWindow/WindowFooter\";\n\nconst StyledWindowFooter = styled.div`\n  min-height: min-content;\n`;\n\nconst StyledWindowContentWrapper = styled.div`\n  overflow: auto;\n  flex: 1;\n`;\n\n/**\n * Window content layout, supporting fixed `header` and `footer` sections, and a scrollable `content` area.\n */\nexport function WindowLayout({\n  header,\n  footer,\n  content,\n}: {\n  /**\n   * Fixed position header of the window at the top. Use {@link WindowLayout.Header} for the default window header,\n   * which also acts as a move handle for the window. If a string is passed, it will be wrapped by\n   * {@link WindowLayout.Header} automatically.\n   */\n  header: React.ReactNode;\n  /**\n   * Scrollable content of the window.\n   */\n  content: React.ReactNode;\n  /**\n   * An area at the bottom of the window which is not scrolled as opposed to `content`. Use {@link WindowLayout.Footer}\n   * for rendering the common layout of a window footer.\n   */\n  footer?: React.ReactNode;\n}) {\n  return (\n    <>\n      {header &&\n        (typeof header === \"string\" ? (\n          <WindowHeader>{header}</WindowHeader>\n        ) : (\n          header\n        ))}\n      <StyledWindowContentWrapper>{content}</StyledWindowContentWrapper>\n      {footer && <StyledWindowFooter>{footer}</StyledWindowFooter>}\n    </>\n  );\n}\n\n// Just for improved discoverability. Might as well export WindowFooter and WindowHeader instead.\nWindowLayout.Footer = WindowFooter;\nWindowLayout.Header = WindowHeader;\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nexport const StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","import { Selection } from \"@react-types/shared\";\nimport React, { HTMLProps, Key } from \"react\";\nimport { styled } from \"./styled\";\nimport { SpeedSearchTree, TreeRefValue } from \"@intellij-platform/core/Tree\";\nimport { staticSpeedSearchTreeItems } from \"@intellij-platform/core/Tree/story-helpers\";\n\nexport const Container = styled.div`\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n`;\nexport const Pane: React.FC<Omit<HTMLProps<HTMLDivElement>, \"style\">> = (\n  props\n) => (\n  <div\n    style={{\n      display: \"flex\",\n      flexDirection: \"column\",\n      width: 400,\n      marginTop: 25,\n      height: \"calc(100vh - 70px)\",\n    }}\n    {...props}\n  />\n);\n\nexport function SelectionLog({ selection }: { selection: Selection }) {\n  return (\n    <pre>\n      {selection instanceof Set && (\n        <div>{JSON.stringify([...selection], null, 2)}</div>\n      )}\n      {JSON.stringify(selection, null, 2)}\n    </pre>\n  );\n}\n\ntype SelectedKeysType = \"all\" | Iterable<Key>;\nexport const SpeedSearchTreeSample = ({\n  selectedKeys,\n  defaultSelectedKeys = [\"BasicList\"],\n  onSelectedKeysChange,\n  treeRef,\n}: {\n  selectedKeys?: SelectedKeysType;\n  defaultSelectedKeys?: SelectedKeysType;\n  onSelectedKeysChange?: (selectedKeys: Selection) => void;\n  treeRef?: React.RefObject<TreeRefValue>;\n}): React.ReactElement => {\n  return (\n    <SpeedSearchTree\n      treeRef={treeRef}\n      autoFocus\n      fillAvailableSpace\n      selectionMode=\"multiple\"\n      defaultExpandedKeys={[\"List\", \"Theme\", \"BasicList\", \"Foo\"]}\n      selectedKeys={selectedKeys}\n      defaultSelectedKeys={new Set(defaultSelectedKeys)}\n      onSelectionChange={onSelectedKeysChange}\n    >\n      {staticSpeedSearchTreeItems}\n    </SpeedSearchTree>\n  );\n};\n"],"names":[],"sourceRoot":""}