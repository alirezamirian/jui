{"version":3,"file":"Dropdown-Dropdown-stories.ea8562c1.iframe.bundle.js","mappings":";;;AAqBA;AACA;;AAEA;AAEA;;;AC0CA;AAGA;;;;AAMA;;ACtDA;;;AAMA;;;AAKA;;;;;AAQA;AACA;;AAKA;;;;;AASA;;;AAOA;;;AAOA;AACA;AAIA;;;;AAMA;;;;;;;;;;AAcA;;;;AC3FA;AAQA;;AAEA;;AAGA;AAGA;;;;AAhBA;AAwCA;AC1CA;;;;;;;ACaA;;AAEA;AAMA;;ACVA","sources":["webpack://@intellij-platform/core/./src/Overlay/Popover.tsx","webpack://@intellij-platform/core/./src/Dropdown/StatelessListBox.tsx","webpack://@intellij-platform/core/./src/Dropdown/Dropdown.tsx","webpack://@intellij-platform/core/./src/Collections/ItemLayout.tsx","webpack://@intellij-platform/core/./src/Label/StyledLabel.ts","webpack://@intellij-platform/core/./src/List/StyledList.tsx","webpack://@intellij-platform/core/./src/List/StyledListItem.tsx"],"sourcesContent":["import React from \"react\";\nimport {\n  AriaPopoverProps,\n  DismissButton,\n  Overlay,\n  usePopover,\n} from \"@react-aria/overlays\";\nimport { OverlayTriggerState } from \"@react-stately/overlays\";\n\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\n\nimport { styled } from \"../styled\";\n\nexport interface PopoverProps extends Omit<AriaPopoverProps, \"popoverRef\"> {\n  children: React.ReactNode;\n  state: OverlayTriggerState;\n}\n\nconst StyledPopover = styled.div`\n  box-sizing: border-box;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  outline: none; // Focus will be reflected in header. No need for outline or any other focus style on the container\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n`;\nexport function Popover({\n  children,\n  state,\n  offset = 8,\n  ...props\n}: PopoverProps) {\n  const popoverRef = React.useRef(null);\n  const { popoverProps } = usePopover(\n    {\n      ...props,\n      offset,\n      popoverRef,\n    },\n    state\n  );\n\n  return (\n    <Overlay>\n      {/* Rendering underlay doesn't seem necessary based on the reference impl */}\n      <StyledPopover {...popoverProps} ref={popoverRef}>\n        <DismissButton onDismiss={state.close} />\n        {children}\n        <DismissButton onDismiss={state.close} />\n      </StyledPopover>\n    </Overlay>\n  );\n}\n","import React, { useRef } from \"react\";\nimport {\n  AriaListBoxOptions,\n  useListBox,\n  useListBoxSection,\n  useOption,\n} from \"@react-aria/listbox\";\nimport { ListState } from \"@react-stately/list\";\nimport { Node } from \"@react-types/shared\";\n\nimport { StyledListItem } from \"@intellij-platform/core/List/StyledListItem\";\nimport { StyledList } from \"@intellij-platform/core/List/StyledList\";\nimport { StyledVerticalSeparator } from \"@intellij-platform/core/StyledSeparator\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport function StatelessListBox<T extends object>({\n  state,\n  minWidth,\n  ...props\n}: AriaListBoxOptions<T> & {\n  state: ListState<T>;\n  minWidth?: number;\n}) {\n  const ref = useRef(null);\n  const { listBoxProps, labelProps } = useListBox(props, state, ref);\n\n  return (\n    <>\n      <div {...labelProps}>{props.label}</div>\n      <StyledList {...listBoxProps} ref={ref} style={{ minWidth }}>\n        {[...state.collection].map((item) =>\n          item.type === \"section\" ? (\n            <ListBoxSection key={item.key} section={item} state={state} />\n          ) : (\n            <Option key={item.key} item={item} state={state} />\n          )\n        )}\n      </StyledList>\n    </>\n  );\n}\n\nfunction Option<T extends object>({\n  item,\n  state,\n}: {\n  item: Node<T>;\n  state: ListState<T>;\n}) {\n  const ref = React.useRef<HTMLDivElement>(null);\n  const { optionProps } = useOption({ key: item.key }, state, ref);\n\n  return (\n    <StyledListItem\n      {...optionProps}\n      ref={ref}\n      disabled={state.disabledKeys.has(item.key)}\n      selected={state.selectionManager.focusedKey === item.key}\n      containerFocused\n    >\n      {item.rendered}\n    </StyledListItem>\n  );\n}\n\nconst StyledSectionHeading = styled.div`\n  font-size: 0.6875rem;\n  padding: 0 0.5rem;\n  color: ${({ theme }) => theme.commonColors.inactiveTextColor}; // not verified\n`;\n\nconst StyledSection = styled.div`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nfunction ListBoxSection<T extends object>({\n  section,\n  state,\n}: {\n  section: Node<T>;\n  state: ListState<T>;\n}) {\n  let { itemProps, headingProps, groupProps } = useListBoxSection({\n    heading: section.rendered,\n    \"aria-label\": section[\"aria-label\"],\n  });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() && (\n        <StyledVerticalSeparator role=\"presentation\" />\n      )}\n      <li {...itemProps}>\n        {section.rendered && (\n          <StyledSectionHeading {...headingProps}>\n            {section.rendered}\n          </StyledSectionHeading>\n        )}\n        <StyledSection {...groupProps}>\n          {[\n            ...(state.collection.getChildren?.(section.key) ??\n              section.childNodes),\n          ].map((node) => (\n            <Option key={node.key} item={node} state={state} />\n          ))}\n        </StyledSection>\n      </li>\n    </>\n  );\n}\n","import React, { CSSProperties, ForwardedRef, forwardRef } from \"react\";\nimport { AriaSelectProps, useSelect } from \"@react-aria/select\";\nimport { useObjectRef } from \"@react-aria/utils\";\nimport { useSelectState } from \"@react-stately/select\";\n\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { Label } from \"@intellij-platform/core/Label\";\n\nimport { PlatformIcon } from \"../Icon\";\nimport { BareButton } from \"../Button\";\nimport { Popover } from \"../Overlay\";\nimport { StatelessListBox } from \"./StatelessListBox\";\n\nexport interface DropdownProps<T extends object> extends AriaSelectProps<T> {\n  labelPlacement?: LabelPlacement;\n  className?: string;\n  style?: CSSProperties;\n}\n\n// NOTE: LabelPlacement, StyledLabelContainer and StyledLabel copied from InputField and can be made reusable.\ntype LabelPlacement = \"above\" | \"before\";\nconst StyledLabelContainer = styled.div<{ labelPlacement?: LabelPlacement }>`\n  display: inline-flex;\n  flex-direction: ${({ labelPlacement }) =>\n    labelPlacement === \"above\" ? \"column\" : \"row\"};\n  align-items: start;\n  gap: 0.375rem;\n`;\n\nconst StyledLabel = styled(Label)`\n  margin-top: 0.25rem;\n  line-height: 1.2;\n`;\n\nconst StyledDropdownTrigger = styled.button<{\n  disabled?: boolean;\n  invalid?: boolean;\n}>`\n  box-sizing: border-box;\n  display: inline-flex;\n  align-items: center;\n  height: 1.5rem;\n  background: ${({ theme }) => theme.color(\"ComboBox.nonEditableBackground\")};\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\"*.foreground\")};\n  border: 1px solid\n    ${({ theme, disabled, invalid }) =>\n      theme.commonColors.border({\n        disabled,\n        validationState: invalid ? \"error\" : \"valid\",\n      })};\n  // The focus style is applied unconditionally in the reference impl, so no use of focus-visible or js-based focus visible detection\n\n  &:focus,\n  &.is-focus {\n    border-color: ${({ theme, invalid }) =>\n      theme.commonColors.border({\n        focused: true,\n        validationState: invalid ? \"error\" : \"valid\",\n      })};\n    outline: none;\n    box-shadow: 0 0 0 0.125rem\n      ${({ theme, invalid }) =>\n        theme.commonColors.focusRing({\n          validationState: invalid ? \"error\" : \"valid\",\n          focused: true,\n        })};\n  }\n\n  border-radius: ${({ theme }) => theme.borderRadius.default}px;\n  padding: ${({ theme }) =>\n    theme.inset(\"ComboBox.padding\") ?? \"1px 6px 1px 6px\"};\n`;\n\nconst StyledDropdownValue = styled.span`\n  flex: 1;\n  text-align: initial;\n  white-space: nowrap;\n`;\n\nconst StyledDropdownArrowIcon = styled(PlatformIcon).attrs({\n  \"aria-hidden\": \"true\",\n})`\n  // NOTE: \"ArrowButton.nonEditableBackground\" theme key is used in the reference impl, but it doesn't seem necessary to allow\n  // for a separate arrow background in Dropdown (aka non-editable combobox), since the arrow is not really a\n  // separate button, but a visual indicator for the whole trigger. Also there is no mention of it in designs\n  // There is also separate theme properties for color and disabled color, but inheriting it (via currentColor)\n  // makes more sense\n  padding-left: 5px;\n  * {\n    fill: currentColor;\n  }\n`;\n\nexport const Dropdown = forwardRef(\n  <T extends object>(\n    { labelPlacement, style, className, ...props }: DropdownProps<T>,\n    forwardedRef: ForwardedRef<HTMLButtonElement>\n  ): React.JSX.Element => {\n    const ref = useObjectRef(forwardedRef);\n    const state = useSelectState(props);\n    const { menuProps, labelProps, triggerProps, valueProps, isInvalid } =\n      useSelect(props, state, ref);\n\n    // minWidth is not kept in the state, assuming it's not needed, considering the width is expected to be\n    // stable when the popover opens.\n    const minWidth = ref.current\n      ? ref.current?.offsetWidth + 2 /* for box shadow*/\n      : undefined;\n\n    return (\n      <StyledLabelContainer\n        labelPlacement={labelPlacement}\n        className={className}\n        style={style}\n      >\n        {/* probably no need for HiddenSelect as auto-filling doesn't seem relevant for applications using this library */}\n        {props.label && (\n          <StyledLabel {...labelProps}>{props.label}</StyledLabel>\n        )}\n        <BareButton {...triggerProps} ref={ref}>\n          <StyledDropdownTrigger\n            invalid={isInvalid}\n            className={state.isOpen ? \"is-focus\" : \"\"}\n          >\n            <StyledDropdownValue {...valueProps}>\n              {state.selectedItem?.rendered}\n            </StyledDropdownValue>\n            <StyledDropdownArrowIcon\n              disabled={props.isDisabled}\n              size={20}\n              icon=\"general/arrowDown.svg\"\n            />\n          </StyledDropdownTrigger>\n        </BareButton>\n        {state.isOpen && (\n          <Popover\n            state={state}\n            triggerRef={ref}\n            placement=\"bottom start\"\n            containerPadding={0}\n            offset={2}\n            crossOffset={-1}\n          >\n            <StatelessListBox\n              {...menuProps}\n              state={state}\n              minWidth={minWidth}\n            />\n          </Popover>\n        )}\n      </StyledLabelContainer>\n    );\n  }\n);\n","import React from \"react\";\nimport { styled } from \"../styled\";\nimport { DOMAttributes } from \"@react-types/shared\";\nimport { MENU_POSITION_TARGET_DATA_ATTRIBUTE } from \"@intellij-platform/core/Menu/ContextMenuContainer\";\n\nconst GAP = \"0.1875rem\";\nconst StyledItemLayout = styled.div`\n  display: flex;\n  align-items: center;\n  padding-right: 0.25rem;\n  gap: ${GAP};\n`;\n\nconst StyledHint = styled.span<{ small?: boolean }>`\n  display: inline-flex;\n  color: ${({ theme }) =>\n    theme.currentForegroundAware(theme.commonColors.inactiveTextColor)};\n  padding-left: 0.1rem;\n  font-size: ${({ small }) => small && \"0.9em\"};\n`;\n\nconst StyledGroup = styled.span.attrs({\n  role: \"presentation\" as string,\n})`\n  display: inline-flex;\n  display: flex;\n  align-items: center;\n  gap: ${GAP};\n`;\n/**\n * Generic layout component capturing common use cases of tree or list items.\n * It handles the spacing between parts, and provides styled components for parts that need specific styling.\n * For more flexibility over the order of various pieces of content in list/tree items, there is no specific props\n * for parts. Different parts should just be rendered in children.\n *\n * @example\n * ```tsx\n * <ItemLayout>\n *   <PlatformIcon icon=\"nodes/folder\" />\n *   <HighlightedTextValue />\n *   <ItemLayout.Hint>~/workspace/jui</ItemLayout.Hint>\n * </ItemLayout>\n * ```\n * @beta\n */\nexport const ItemLayout = (\n  props: { children: React.ReactNode } & DOMAttributes\n) => {\n  return (\n    <StyledItemLayout\n      {...{ [MENU_POSITION_TARGET_DATA_ATTRIBUTE]: true }}\n      {...props}\n    />\n  );\n};\n\n/**\n * A more subtle text usually rendered next to the main text in the item.\n * @example: project path in project root node, in project view\n * @example: \"library root\" rendered next to \"node_modules\" folders in project view.\n */\nItemLayout.Hint = StyledHint;\n\n/**\n * Useful when a number of items need to be grouped by a wrapper, e.g. to have a tooltip.\n * @example: project path in project root node, in project view\n * @example: \"library root\" rendered next to \"node_modules\" folders in project view.\n */\nItemLayout.Group = StyledGroup;\n","import { styled } from \"@intellij-platform/core/styled\";\n\nexport const StyledLabel = styled.label<{ disabled?: boolean }>`\n  color: ${({ theme, disabled }) => theme.commonColors.label({ disabled })};\n`;\n","import { css } from \"styled-components\";\nimport { styled } from \"../styled\";\n\ntype StyledListProps = {\n  fillAvailableSpace?: boolean;\n};\nexport const StyledList = styled.div\n  .attrs<StyledListProps>((props) => ({ role: props.role || \"list\" }))\n  .withConfig<StyledListProps>({\n    shouldForwardProp: (prop) => prop !== \"fillAvailableSpace\",\n  })<StyledListProps>`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  max-height: 100%;\n  overflow: auto;\n  color: ${({ theme }) => theme.color(\"*.textForeground\")};\n  outline: none;\n  ${({ fillAvailableSpace }) =>\n    fillAvailableSpace &&\n    css`\n      flex: 1;\n      height: fill-available; // will be converted to --webkit-fill-available and --moz-available, but doesn't work in FF\n    `}\n  background: ${({ theme }) => theme.color(\"List.background\")};\n`;\n","import { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { styled } from \"../styled\";\n\nexport type StyledListItemProps = {\n  containerFocused: boolean;\n  selected: boolean;\n  disabled: boolean;\n};\n\nexport const StyledListItem = styled.div.attrs<StyledListItemProps>(\n  (props) => ({\n    role: props.role || \"listitem\",\n  })\n)<StyledListItemProps>`\n  ${({ containerFocused, selected, disabled, theme }) => {\n    let backgroundColor;\n    let color = disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\n          \"List.foreground\" as UnknownThemeProp<\"List.foreground\">,\n          theme.commonColors.labelForeground\n        );\n    if (selected) {\n      if (containerFocused) {\n        color = theme.asCurrentForeground(\n          theme.color(\n            \"List.selectionForeground\" as UnknownThemeProp<\"List.selectionForeground\">\n          ) || theme.commonColors.labelSelectedForeground\n        ) /* Prioritizing \"*.selectionForeground\" over labelSelectedForeground*/;\n        backgroundColor = theme.color(\n          \"List.selectionBackground\" as UnknownThemeProp<\"List.selectionBackground\">\n        );\n      } else {\n        color = theme.color(\n          \"List.selectionInactiveForeground\" as UnknownThemeProp<\"List.selectionInactiveForeground\">,\n          color\n        );\n        backgroundColor = theme.color(\n          \"List.selectionBackgroundInactive\" as UnknownThemeProp<\"List.selectionBackgroundInactive\">\n        );\n      }\n    }\n    return {\n      backgroundColor: theme.asCurrentBackground(backgroundColor),\n      color,\n    };\n  }};\n  position: relative;\n  display: flex;\n  white-space: nowrap;\n  padding: 0 0.5rem; // themed?\n  line-height: 1.25rem;\n  outline: none;\n  cursor: default;\n  min-width: min-content; // Needed for content sizing for when list/tree is used inside popup or modal window\n`;\n"],"names":[],"sourceRoot":""}