{"version":3,"file":"Dropdown-ComboBox-stories.05883e4b.iframe.bundle.js","mappings":";;AAmFA;AASA;;;;;;AAMA;;AAKA;;;;AAIA;;;;;;AAMA;;;;;;;;;;;;;;;;AAwBA;;;AChEA;AAGA;;;;AAMA;;;;;;ACtEA;AAIA;;AAOA;;;;AAQA;;;AAOA;;;AAOA;;;AAOA;;;;;;;;;ACrCA;;;ACOA;AAGA;;;;;;AAQA;;;;;;AAcA;;AC9BA;;;AAMA;AACA;;;AAUA;;;;;;ACnBA;AACA;;AAEA;;;;;;;ACFA;;AAEA;AAMA;;ACVA;;;;;;;;;;;;ACQA;AACA;;AAEA;AAEA;;ACIA;AACA;AAEA;;AAEA;AACA;;;ACJA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAGA;;;;AAMA;;;;;AAKA;AACA;AACA;AAjCA;AAAA;;;;;;AAFA;AAAA;AACA;;AAgDA;;ACbA;AAUA;;;AAGA;AAIA;AACA;AAEA;;;AAQA;ACrFA;ADwFA;AACA;;AC5FA;;ADoGA;;AAEA;AAOA;AACA;;;AAIA;AACA;AAKA;AAIA;AACA;;;;;;AAYA;;;AE5HA;AAEA;;AAGA;AAGA;AACA;AAEA;AAQA","sources":["webpack://@intellij-platform/core/./src/Dropdown/ComboBox.tsx","webpack://@intellij-platform/core/./src/Dropdown/StatelessListBox.tsx","webpack://@intellij-platform/core/./src/Dropdown/StyledContainer.tsx","webpack://@intellij-platform/core/./src/Dropdown/StyledDropdownArrowIcon.tsx","webpack://@intellij-platform/core/./src/Field/ContextHelp.tsx","webpack://@intellij-platform/core/./src/Field/Label.tsx","webpack://@intellij-platform/core/./src/Icon/StyledIconWrapper.tsx","webpack://@intellij-platform/core/./src/List/StyledList.tsx","webpack://@intellij-platform/core/./src/List/StyledListItem.tsx","webpack://@intellij-platform/core/./src/Overlay/Popover.tsx","webpack://@intellij-platform/core/./src/StyledSeparator.tsx","webpack://@intellij-platform/core/./src/Tooltip/TooltipPointer.tsx","webpack://@intellij-platform/core/./src/Tooltip/Tooltip.tsx","webpack://@intellij-platform/core/./src/Tooltip/tooltip-styles.ts","webpack://@intellij-platform/core/./src/Tooltip/ValidationTooltip.tsx"],"sourcesContent":["import React, {\n  CSSProperties,\n  ForwardedRef,\n  forwardRef,\n  HTMLProps,\n  Ref,\n  useRef,\n} from \"react\";\nimport { mergeProps, useObjectRef } from \"@react-aria/utils\";\nimport { AriaComboBoxProps, useComboBox } from \"@react-aria/combobox\";\nimport { useComboBoxState } from \"@react-stately/combobox\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { ControlledStateProps } from \"@intellij-platform/core/type-utils\";\nimport { BareButton } from \"@intellij-platform/core/Button\";\nimport { Popover } from \"@intellij-platform/core/Overlay\";\nimport { StatelessListBox } from \"./StatelessListBox\";\nimport { StyledContainer } from \"./StyledContainer\";\nimport { LabelPlacement, WithLabel } from \"../Field/Label\";\nimport { StyledDropdownArrowIcon } from \"./StyledDropdownArrowIcon\";\nimport {\n  PositionedTooltipTrigger,\n  ValidationTooltip,\n} from \"@intellij-platform/core/Tooltip\";\nimport {\n  ContextHelpProps,\n  WithInlineContextHelp,\n} from \"@intellij-platform/core/Field/ContextHelp\";\n\ntype AriaProps<T> = {\n  [K in keyof T as K extends `aria-${string}` ? K : never]: T[K];\n};\n\nexport interface ComboBoxProps<T extends object>\n  extends Pick<\n      AriaComboBoxProps<T>,\n      | \"disabledKeys\"\n      | \"defaultSelectedKey\"\n      | \"selectedKey\"\n      | \"isDisabled\"\n      | \"children\"\n      | \"items\"\n      | \"label\"\n      | \"autoFocus\"\n      | \"menuTrigger\"\n      | \"placeholder\"\n      | \"onFocus\"\n      | \"onBlur\"\n      | \"onKeyDown\"\n      | \"onKeyUp\"\n      | \"onOpenChange\"\n      | \"onFocusChange\"\n      | \"onSelectionChange\"\n    >,\n    AriaProps<AriaComboBoxProps<T>>,\n    ControlledStateProps<{\n      value: string;\n    }>,\n    ContextHelpProps {\n  labelPlacement?: LabelPlacement;\n  className?: string;\n  style?: CSSProperties;\n\n  validationState?: \"valid\" | \"error\" | \"warning\";\n\n  /**\n   * Validation message shown as a {@link ValidationTooltip} above the component.\n   * {@link ValidationTooltipProps#type} is defined based on `validationState`.\n   */\n  validationMessage?: React.ReactNode;\n\n  /**\n   * props to apply on input, excluding value that's controlled by the component\n   */\n  inputProps?: Omit<\n    HTMLProps<HTMLInputElement>,\n    \"value\" | \"defaultValue\" | \"as\"\n  >;\n  inputRef?: Ref<HTMLInputElement>;\n}\n\nconst StyledComboBoxContainer = styled(StyledContainer)`\n  padding: 0;\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\n          \"TextField.disabledForeground\" as UnknownThemeProp<\"TextField.disabledForeground\">\n        )\n      : theme.color(\n          \"TextField.foreground\" as UnknownThemeProp<\"TextField.foreground\">\n        )};\n`;\nconst StyledComboBoxInput = styled.input`\n  flex: 1;\n  background: none;\n  border: none;\n  outline: none;\n  color: inherit;\n  padding: ${({ theme }) =>\n    theme.inset(\"ComboBox.padding\") ?? \"1px 6px 1px 6px\"};\n  height: 100%;\n`;\n\nconst StyledDropdownButton = styled.button`\n  // Resetting default styles\n  appearance: none;\n  border: none;\n  background: ${({ theme }) => theme.color(\"ComboBox.ArrowButton.background\")};\n  outline: none;\n  font: inherit;\n  padding: 0;\n\n  // Custom styles\n  border-left: 1px solid ${({ theme }) => theme.commonColors.border()};\n  height: 100%;\n  aspect-ratio: 1;\n  /**\n   * In the reference impl, the clickable area exceeds the left border by a\n   * few pixels. The following trick implements that\n   */\n  position: relative;\n  ::before {\n    content: \"\";\n    position: absolute;\n    left: -4px;\n    top: 0;\n    bottom: 0;\n    width: 4px;\n  }\n`;\n\n/**\n * [Combobox](https://plugins.jetbrains.com/docs/intellij/combo-box.html) implementation.\n * Known differences with the reference impl:\n * - selected key doesn't focus when opened the dropdown manually.\n *   Opening the dropdown by pressing ArrowDown does focus the previously selected item.\n */\nexport const ComboBox = forwardRef(\n  <T extends object>(\n    {\n      labelPlacement,\n      style,\n      className,\n      value,\n      defaultValue,\n      onValueChange,\n      validationState,\n      validationMessage,\n      contextHelp,\n      contextHelpPlacement,\n      inputProps,\n      inputRef: inputRefProp,\n      ...props\n    }: ComboBoxProps<T>,\n    forwardedRef: ForwardedRef<HTMLDivElement>\n  ): React.JSX.Element => {\n    const ref = useObjectRef(forwardedRef);\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    const inputRef = useObjectRef(inputRefProp);\n    const dropdownContainerRef = useRef<HTMLDivElement>(null);\n    const popoverRef = useRef<HTMLDivElement>(null);\n    const listBoxRef = useRef<HTMLDivElement>(null);\n    const isInvalid = Boolean(validationState) && validationState !== \"valid\";\n\n    const state = useComboBoxState({\n      // defaultFilter not provided based on how ComboBoxes don't filter based on input in Intellij Platform\n      // filtering can still be implemented by controlling `value` and `items`.\n      menuTrigger: \"manual\", // overridable via props\n      allowsCustomValue: true,\n      inputValue: value,\n      defaultInputValue: defaultValue,\n      onInputChange: onValueChange,\n      isInvalid,\n      ...props,\n    });\n    const {\n      descriptionProps,\n      errorMessageProps,\n      labelProps,\n      inputProps: comboboxInputProps,\n      listBoxProps,\n      buttonProps,\n    } = useComboBox(\n      {\n        ...props,\n        allowsCustomValue: true,\n        buttonRef,\n        inputRef,\n        popoverRef,\n        listBoxRef,\n      },\n      state\n    );\n\n    // minWidth is not kept in the state, assuming it's unnecessary, considering the width is expected to be\n    // stable when the popover opens.\n    const minWidth = dropdownContainerRef.current\n      ? dropdownContainerRef.current?.offsetWidth + 2 /* for box shadow*/\n      : undefined;\n    return (\n      <>\n        <WithLabel\n          ref={ref}\n          isDisabled={props.isDisabled}\n          label={props.label}\n          labelPlacement={labelPlacement}\n          labelProps={labelProps}\n          className={className}\n          style={style}\n        >\n          {/* probably no need for HiddenSelect as autofilling doesn't seem relevant for applications using this library */}\n          <WithInlineContextHelp\n            contextHelp={contextHelp}\n            contextHelpPlacement={contextHelpPlacement}\n            descriptionProps={descriptionProps}\n          >\n            <StyledComboBoxContainer\n              ref={dropdownContainerRef}\n              validationState={validationState}\n              disabled={props.isDisabled}\n              className={state.isFocused ? \"is-focus\" : \"\"}\n            >\n              {/* FIXME: tooltip comes and goes on mouse enter/leave, which is especially weird when trying to open options */}\n              <PositionedTooltipTrigger\n                placement=\"top\"\n                showOnFocus\n                isDisabled={!validationMessage}\n                triggerRef={inputRef}\n                tooltip={\n                  <ValidationTooltip\n                    type={\n                      validationState !== \"valid\" ? validationState : undefined\n                    }\n                  >\n                    <div {...errorMessageProps}>{validationMessage}</div>\n                  </ValidationTooltip>\n                }\n                delay={0}\n              >\n                {(tooltipTriggerProps) => (\n                  <StyledComboBoxInput\n                    {...mergeProps(\n                      comboboxInputProps,\n                      inputProps,\n                      tooltipTriggerProps\n                    )}\n                  />\n                )}\n              </PositionedTooltipTrigger>\n\n              <BareButton {...buttonProps} ref={buttonRef}>\n                <StyledDropdownButton>\n                  <StyledDropdownArrowIcon\n                    disabled={props.isDisabled}\n                    size={20}\n                    icon=\"general/arrowDown.svg\"\n                  />\n                </StyledDropdownButton>\n              </BareButton>\n            </StyledComboBoxContainer>\n          </WithInlineContextHelp>\n        </WithLabel>\n        {state.isOpen && (\n          <Popover\n            ref={popoverRef}\n            state={state}\n            triggerRef={dropdownContainerRef}\n            placement=\"bottom start\"\n            containerPadding={0}\n            offset={2}\n            crossOffset={-1}\n          >\n            <StatelessListBox\n              {...listBoxProps}\n              ref={listBoxRef}\n              state={state}\n              minWidth={minWidth}\n            />\n          </Popover>\n        )}\n      </>\n    );\n  }\n);\n","import React, { ForwardedRef, useRef } from \"react\";\nimport {\n  AriaListBoxOptions,\n  useListBox,\n  useListBoxSection,\n  useOption,\n} from \"@react-aria/listbox\";\nimport { ListState } from \"@react-stately/list\";\nimport { Node } from \"@react-types/shared\";\n\nimport { StyledListItem } from \"@intellij-platform/core/List/StyledListItem\";\nimport { StyledList } from \"@intellij-platform/core/List/StyledList\";\nimport { StyledVerticalSeparator } from \"@intellij-platform/core/StyledSeparator\";\nimport { styled } from \"@intellij-platform/core/styled\";\nimport { useObjectRef } from \"@react-aria/utils\";\n\nexport const StatelessListBox = React.forwardRef(function StatelessListBox<\n  T extends object\n>(\n  {\n    state,\n    minWidth,\n    ...props\n  }: AriaListBoxOptions<T> & {\n    state: ListState<T>;\n    minWidth?: number;\n  },\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const ref = useObjectRef(forwardedRef);\n  const { listBoxProps, labelProps } = useListBox(props, state, ref);\n\n  return (\n    <>\n      <div {...labelProps}>{props.label}</div>\n      <StyledList {...listBoxProps} ref={ref} style={{ minWidth }}>\n        {[...state.collection].map((item) =>\n          item.type === \"section\" ? (\n            <ListBoxSection key={item.key} section={item} state={state} />\n          ) : (\n            <Option key={item.key} item={item} state={state} />\n          )\n        )}\n      </StyledList>\n    </>\n  );\n});\nfunction Option<T extends object>({\n  item,\n  state,\n}: {\n  item: Node<T>;\n  state: ListState<T>;\n}) {\n  const ref = React.useRef<HTMLDivElement>(null);\n  const { optionProps } = useOption({ key: item.key }, state, ref);\n\n  return (\n    <StyledListItem\n      {...optionProps}\n      ref={ref}\n      disabled={state.disabledKeys.has(item.key)}\n      selected={state.selectionManager.focusedKey === item.key}\n      containerFocused\n    >\n      {item.rendered}\n    </StyledListItem>\n  );\n}\n\nconst StyledSectionHeading = styled.div`\n  font-size: 0.6875rem;\n  padding: 0 0.5rem;\n  color: ${({ theme }) => theme.commonColors.inactiveTextColor}; // not verified\n`;\n\nconst StyledSection = styled.div`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nfunction ListBoxSection<T extends object>({\n  section,\n  state,\n}: {\n  section: Node<T>;\n  state: ListState<T>;\n}) {\n  let { itemProps, headingProps, groupProps } = useListBoxSection({\n    heading: section.rendered,\n    \"aria-label\": section[\"aria-label\"],\n  });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() && (\n        <StyledVerticalSeparator role=\"presentation\" />\n      )}\n      <li {...itemProps}>\n        {section.rendered && (\n          <StyledSectionHeading {...headingProps}>\n            {section.rendered}\n          </StyledSectionHeading>\n        )}\n        <StyledSection {...groupProps}>\n          {[\n            ...(state.collection.getChildren?.(section.key) ??\n              section.childNodes),\n          ].map((node) => (\n            <Option key={node.key} item={node} state={state} />\n          ))}\n        </StyledSection>\n      </li>\n    </>\n  );\n}\n","import { styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\n\nexport const StyledContainer = styled.div<{\n  disabled?: boolean;\n  validationState?: \"valid\" | \"error\" | \"warning\";\n}>`\n  box-sizing: border-box;\n  display: flex;\n  width: 100%;\n  align-items: center;\n  height: 1.5rem;\n  background: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"ComboBox.disabledBackground\")\n      : theme.color(\"ComboBox.background\")};\n  color: ${({ theme, disabled }) =>\n    disabled\n      ? theme.color(\"ComboBox.disabledForeground\")\n      : theme.color(\n          \"ComboBox.foreground\" as UnknownThemeProp<\"ComboBox.foreground\">\n        )};\n  border: 1px solid\n    ${({ theme, disabled, validationState }) =>\n      theme.commonColors.border({\n        disabled,\n        validationState,\n      })};\n  // The focus style is applied unconditionally in the reference impl, so no use of focus-visible or js-based focus visible detection\n\n  box-shadow: 0 0 0 0.125rem\n    ${({ theme, validationState }) =>\n      theme.commonColors.focusRing({\n        validationState,\n        focused: false,\n      })};\n  &:focus,\n  &.is-focus {\n    border-color: ${({ theme, validationState }) =>\n      theme.commonColors.border({\n        focused: true,\n        validationState,\n      })};\n    outline: none;\n    box-shadow: 0 0 0 0.125rem\n      ${({ theme, validationState }) =>\n        theme.commonColors.focusRing({\n          validationState,\n          focused: true,\n        })};\n  }\n\n  border-radius: ${({ theme }) => theme.borderRadius.default}px;\n`;\n","import { PlatformIcon } from \"@intellij-platform/core/Icon\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport const StyledDropdownArrowIcon = styled(PlatformIcon).attrs<{\n  disabled?: boolean;\n}>({\n  \"aria-hidden\": \"true\",\n})`\n  // NOTE: \"ArrowButton.nonEditableBackground\" theme key is used in the reference impl, but it doesn't seem necessary to allow\n  // for a separate arrow background in Dropdown (aka non-editable combobox), since the arrow is not really a\n  // separate button, but a visual indicator for the whole trigger. Also there is no mention of it in designs\n  // There is also separate theme properties for color and disabled color, but inheriting it (via currentColor)\n  // makes more sense\n\n  * {\n    fill: ${({ theme, disabled }) =>\n      disabled\n        ? theme.color(\"ComboBox.ArrowButton.disabledIconColor\")\n        : theme.color(\"ComboBox.ArrowButton.iconColor\")};\n  }\n`;\n","import { css, styled } from \"@intellij-platform/core/styled\";\nimport React from \"react\";\nimport { DOMAttributes, DOMProps } from \"@react-types/shared\";\n\n/**\n * Interface to inherit in props of components that support rendering context help.\n */\nexport interface ContextHelpProps {\n  /**\n   * Context help, shown below the input.\n   * A typical use case is\n   * [to provide example values](https://jetbrains.github.io/ui/principles/context_help/#07).\n   */\n  contextHelp?: React.ReactNode; // TODO: implement\n  /**\n   * Placement of the contextHelp text with respect to the control.\n   * See more: https://plugins.jetbrains.com/docs/intellij/inline-help-text.html#placement\n   */\n  contextHelpPlacement?: \"below\" | \"after\";\n}\n\nconst StyledContextHelp = styled.div`\n  color: ${({ theme }) => theme.commonColors.contextHelpForeground};\n`;\n\nconst StyledContextHelpWrapper = styled.div<{\n  placement: ContextHelpProps[\"contextHelpPlacement\"];\n}>`\n  font-size: 0.75rem; // 12px, in new UI. It's 11px in the old UI.\n  display: flex;\n  flex-direction: column;\n  align-items: start;\n  gap: 0.25rem; /* Not checked with the reference impl */\n  ${({ placement }) =>\n    placement === \"after\" &&\n    css`\n      flex-direction: row;\n      align-items: center;\n      gap: 1rem; /* Not checked with the reference impl */\n    `}\n  flex-grow: 1; /* Needed for when the control is inside a flex layout */\n`;\n\n/**\n * Implements [inline context help](https://plugins.jetbrains.com/docs/intellij/inline-help-text.html),\n * for its children.\n */\nexport const WithInlineContextHelp = ({\n  children,\n  descriptionProps,\n  contextHelpPlacement,\n  contextHelp,\n}: {\n  children: React.ReactNode;\n  /**\n   * Props to apply on the context help wrapper, to make the connected control\n   * described by the context help.\n   */\n  descriptionProps: DOMAttributes;\n} & ContextHelpProps) => {\n  return (\n    <StyledContextHelpWrapper placement={contextHelpPlacement}>\n      {children}\n      {contextHelp && (\n        <StyledContextHelp {...descriptionProps}>\n          {contextHelp}\n        </StyledContextHelp>\n      )}\n    </StyledContextHelpWrapper>\n  );\n};\n","import { styled } from \"@intellij-platform/core/styled\";\nimport React, {\n  ForwardedRef,\n  forwardRef,\n  RefObject,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n} from \"react\";\nimport { DOMAttributes } from \"@react-types/shared\";\n\nexport type LabelPlacement = \"above\" | \"before\";\n\nconst StyledLabelContainer = styled.div<{\n  labelPlacement?: LabelPlacement;\n}>`\n  display: inline-flex;\n  flex-direction: ${({ labelPlacement }) =>\n    labelPlacement === \"above\" ? \"column\" : \"row\"};\n  align-items: start;\n  gap: 0.375rem;\n`;\n\nconst StyledLabel = styled.label<{ isDisabled?: boolean }>`\n  color: ${({ theme, isDisabled: disabled }) =>\n    theme.commonColors.label({ disabled })};\n  margin-top: 0.25rem;\n  line-height: 1.2;\n`;\n\n/**\n * Implements [label](https://jetbrains.github.io/ui/controls/input_field/#label),\n * for elements like Input, Dropdown, etc.\n */\nexport const WithLabel = forwardRef(function WithLabel(\n  {\n    label,\n    labelPlacement,\n    labelProps,\n    children,\n    isDisabled,\n    ...props\n  }: {\n    isDisabled: boolean | undefined;\n    label: React.ReactNode;\n    labelPlacement: LabelPlacement | undefined /* intentionally not optional */;\n    labelProps?: DOMAttributes;\n  } & DOMAttributes,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const labelRef = React.useRef<HTMLLabelElement>(null);\n  useAlignedLabels({ ref: labelRef, enabled: labelPlacement !== \"above\" });\n  return (\n    <StyledLabelContainer\n      {...props}\n      labelPlacement={labelPlacement}\n      ref={forwardedRef}\n    >\n      {label && (\n        <StyledLabel {...labelProps} isDisabled={isDisabled} ref={labelRef}>\n          {label}\n        </StyledLabel>\n      )}\n      {children}\n    </StyledLabelContainer>\n  );\n});\n\nfunction useAlignedLabels({\n  ref,\n  enabled,\n}: {\n  ref: RefObject<HTMLElement>;\n  enabled?: boolean;\n}) {\n  const { applyLabelWidth, commonWidth } = useContext(LabelAlignmentContext);\n  useLayoutEffect(() => {\n    const apply = (): boolean => {\n      const width = ref.current?.offsetWidth;\n      if (width) {\n        applyLabelWidth(width);\n        return true;\n      }\n      return false;\n    };\n    // In some situations, the width is zero in the first render.\n    if (!apply()) {\n      setTimeout(apply, 0);\n    }\n  });\n\n  useEffect(() => {\n    if (ref.current) {\n      ref.current.style.width =\n        commonWidth && enabled ? `${commonWidth}px` : \"\";\n    }\n  }, [commonWidth, enabled]);\n}\n\nconst LabelAlignmentContext = React.createContext<{\n  commonWidth: number | null;\n  applyLabelWidth: (width: number) => void;\n}>({ commonWidth: null, applyLabelWidth: () => {} });\n\n/**\n * Provides a context for\n * [labeled input controls](https://jetbrains.github.io/ui/principles/layout/#labeled-input-controls)\n * with side-positioned labels to have their input boxes aligned.\n * It doesn't render anything in DOM and only provides a context used\n * by labeled controls to set a common width on labels so that the input boxes\n * align.\n * Labeled input controls are:\n * - {@link InputField}\n * - {@link ComboBox}\n * - {@link Dropdown}\n */\nexport function LabeledControlsAlignmentProvider({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  const [commonWidth, setCommonWidth] = React.useState<null | number>(null);\n\n  const applyLabelWidth = (width: number) => {\n    setCommonWidth((currentWidth) =>\n      width > (currentWidth ?? 0)\n        ? width + 1 /* without 1px it wraps in some cases ¯\\_(ツ)_/¯ */\n        : currentWidth\n    );\n  };\n  return (\n    <LabelAlignmentContext.Provider value={{ commonWidth, applyLabelWidth }}>\n      {children}\n    </LabelAlignmentContext.Provider>\n  );\n}\n","import { styled } from \"../styled\";\nimport { IconSize } from \"@intellij-platform/core/Icon/IconProps\";\n\nconst DEFAULT_ICON_SIZE: IconSize = 16;\n\nexport const StyledIconWrapper = styled.span<{\n  size?: IconSize;\n  useCurrentColor?: boolean;\n  role?: string;\n}>`\n  box-sizing: border-box;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  line-height: 0;\n  width: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  height: ${({ size = DEFAULT_ICON_SIZE }) => `${size}px`};\n  position: relative; // to allow absolute positioned indicators and overlays on icon\n  cursor: ${({ role }) => (role === \"button\" ? \"pointer\" : undefined)};\n`;\n","import { css } from \"styled-components\";\nimport { styled } from \"../styled\";\n\ntype StyledListProps = {\n  fillAvailableSpace?: boolean;\n};\nexport const StyledList = styled.div\n  .attrs<StyledListProps>((props) => ({ role: props.role || \"list\" }))\n  .withConfig<StyledListProps>({\n    shouldForwardProp: (prop) => prop !== \"fillAvailableSpace\",\n  })<StyledListProps>`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  max-height: 100%;\n  overflow: auto;\n  color: ${({ theme }) => theme.color(\"*.textForeground\")};\n  outline: none;\n  ${({ fillAvailableSpace }) =>\n    fillAvailableSpace &&\n    css`\n      flex: 1;\n      height: fill-available; // will be converted to --webkit-fill-available and --moz-available, but doesn't work in FF\n    `}\n  background: ${({ theme }) => theme.color(\"List.background\")};\n`;\n","import { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { styled } from \"../styled\";\n\nexport type StyledListItemProps = {\n  containerFocused: boolean;\n  selected: boolean;\n  disabled: boolean;\n};\n\nexport const StyledListItem = styled.div.attrs<StyledListItemProps>(\n  (props) => ({\n    role: props.role || \"listitem\",\n  })\n)<StyledListItemProps>`\n  ${({ containerFocused, selected, disabled, theme }) => {\n    let backgroundColor;\n    let color = disabled\n      ? theme.color(\"*.disabledForeground\")\n      : theme.color(\n          \"List.foreground\" as UnknownThemeProp<\"List.foreground\">,\n          theme.commonColors.labelForeground\n        );\n    if (selected) {\n      if (containerFocused) {\n        color = theme.asCurrentForeground(\n          theme.color(\n            \"List.selectionForeground\" as UnknownThemeProp<\"List.selectionForeground\">\n          ) || theme.commonColors.labelSelectedForeground\n        ) /* Prioritizing \"*.selectionForeground\" over labelSelectedForeground*/;\n        backgroundColor = theme.color(\n          \"List.selectionBackground\" as UnknownThemeProp<\"List.selectionBackground\">\n        );\n      } else {\n        color = theme.color(\n          \"List.selectionInactiveForeground\" as UnknownThemeProp<\"List.selectionInactiveForeground\">,\n          color\n        );\n        backgroundColor = theme.color(\n          \"List.selectionBackgroundInactive\" as UnknownThemeProp<\"List.selectionBackgroundInactive\">\n        );\n      }\n    }\n    return {\n      backgroundColor: theme.asCurrentBackground(backgroundColor),\n      color,\n    };\n  }};\n  position: relative;\n  display: flex;\n  white-space: nowrap;\n  padding: 0 0.5rem; // themed?\n  line-height: 1.25rem;\n  outline: none;\n  cursor: default;\n  min-width: min-content; // Needed for content sizing for when list/tree is used inside popup or modal window\n`;\n","import React, { ForwardedRef } from \"react\";\nimport {\n  AriaPopoverProps,\n  DismissButton,\n  Overlay,\n  usePopover,\n} from \"@react-aria/overlays\";\nimport { OverlayTriggerState } from \"@react-stately/overlays\";\n\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\n\nimport { styled } from \"../styled\";\nimport { useObjectRef } from \"@react-aria/utils\";\n\nexport interface PopoverProps extends Omit<AriaPopoverProps, \"popoverRef\"> {\n  children: React.ReactNode;\n  state: OverlayTriggerState;\n}\n\nconst StyledPopover = styled.div`\n  box-sizing: border-box;\n  // not checked if there should be a better substitute for * in the following colors. Maybe \"Component\"?\n  background-color: ${({ theme }) => theme.color(\"*.background\")};\n  color: ${({ theme }) => theme.color(\"*.foreground\")};\n  outline: none; // Focus will be reflected in header. No need for outline or any other focus style on the container\n  ${WINDOW_SHADOW}; // FIXME: OS-dependant style?\n`;\nexport const Popover = React.forwardRef(function Popover(\n  { children, state, offset = 8, ...props }: PopoverProps,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n) {\n  const popoverRef = useObjectRef(forwardedRef);\n  const { popoverProps } = usePopover(\n    {\n      ...props,\n      offset,\n      popoverRef,\n    },\n    state\n  );\n\n  return (\n    <Overlay>\n      {/* Rendering underlay doesn't seem necessary based on the reference impl */}\n      <StyledPopover {...popoverProps} ref={popoverRef}>\n        <DismissButton onDismiss={state.close} />\n        {children}\n        <DismissButton onDismiss={state.close} />\n      </StyledPopover>\n    </Overlay>\n  );\n});\n","import React from \"react\";\nimport { styled } from \"./styled\";\n\ntype SeparatorUI = {\n  STRIPE_INDENT: number;\n  STRIPE_WIDTH: number;\n};\n\n// based on implementation in com.intellij.ide.ui.laf.darcula.ui.DarculaSeparatorUI, which seems to be used for all themes\nconst DarculaSeparatorUI: SeparatorUI = {\n  STRIPE_INDENT: 1,\n  STRIPE_WIDTH: 1,\n};\n\nconst defaultSize =\n  2 * DarculaSeparatorUI.STRIPE_INDENT + DarculaSeparatorUI.STRIPE_WIDTH;\n\nexport const StyledSeparator = styled.hr(({ theme }) => ({\n  backgroundColor: theme.color(\n    \"Separator.separatorColor\",\n    theme.dark ? \"#cdcdcd\" : \"#515151\"\n  ),\n  backgroundClip: \"content-box\",\n  boxSizing: \"border-box\",\n  margin: 0,\n  border: \"none\",\n  flexShrink: 0,\n}));\n\nexport const StyledHorizontalSeparator = styled(StyledSeparator)`\n  height: inherit; // should it be auto?\n  padding: 0 ${DarculaSeparatorUI.STRIPE_INDENT}px;\n  width: ${defaultSize}px;\n`;\nexport const StyledVerticalSeparator = styled(StyledSeparator)`\n  width: auto;\n  padding: ${DarculaSeparatorUI.STRIPE_INDENT}px 0;\n  height: ${defaultSize}px;\n`;\n","import { compose, identity } from \"ramda\";\nimport React, { CSSProperties, RefObject, useEffect, useState } from \"react\";\nimport { css, styled } from \"@intellij-platform/core/styled\";\n\nimport {\n  tooltipBackground,\n  WITH_POINTER_BORDER_RADIUS,\n} from \"./tooltip-styles\";\n\ntype OffsetValue = number | `${number}%`;\nexport type TooltipPointerPosition = {\n  /**\n   * The side of the tooltip the pointer is shown\n   */\n  side: \"top\" | \"bottom\" | \"left\" | \"right\";\n  /**\n   * - When side is \"top\" or \"bottom\":\n   *   Horizontal offset (in px) with respect to the left (or right, if negative) of the tooltip.\n   * - When side is \"left\" or \"right\":\n   *   Vertical offset (in px) with respect to the top (or bottom, if negative) of the tooltip.\n   *\n   * @default: '50%'\n   */\n  offset?: OffsetValue | { value: OffsetValue; invert?: boolean };\n};\n\nconst POINTER_WIDTH = 6;\nconst POINTER_HEIGHT = 9;\nconst POINTER_THICKNESS = 1.5;\nconst TRANSLATE = `translate(-${POINTER_WIDTH}px, -${POINTER_HEIGHT}px)`;\nconst sideStyles = {\n  top: css`\n    top: 0;\n    transform: ${TRANSLATE};\n  `,\n  bottom: css`\n    bottom: 0;\n    transform: rotateX(180deg) ${TRANSLATE};\n  `,\n  left: css`\n    left: 0;\n    transform: rotate(-90deg) ${TRANSLATE};\n  `,\n  right: css`\n    right: 0;\n    transform: rotate(90deg) ${TRANSLATE};\n  `,\n};\nconst StyledTooltipPointer = styled.span<{\n  side: TooltipPointerPosition[\"side\"];\n}>`\n  position: absolute;\n  width: 0;\n  height: 0;\n  ${({ side }) => sideStyles[side]};\n\n  &::before {\n    content: \"\";\n    position: absolute;\n    border-left: ${POINTER_WIDTH + POINTER_THICKNESS}px solid transparent;\n    border-right: ${POINTER_WIDTH + POINTER_THICKNESS}px solid transparent;\n    border-bottom: ${POINTER_HEIGHT + POINTER_THICKNESS}px solid #636569;\n    left: -${POINTER_THICKNESS}px;\n    top: -${POINTER_THICKNESS}px;\n  }\n\n  &::after {\n    content: \"\";\n    position: absolute;\n    border-left: ${POINTER_WIDTH}px solid transparent;\n    border-right: ${POINTER_WIDTH}px solid transparent;\n    border-bottom: ${POINTER_HEIGHT}px solid ${tooltipBackground};\n  }\n`;\n\nfunction normalizeCssValue(value: string | number) {\n  return typeof value === \"number\" ? `${value}px` : value;\n}\n\nconst withMin = (min: number) => (value: string | number | undefined) =>\n  value != undefined ? `max(${min}px, ${normalizeCssValue(value)})` : value;\nconst withMax = (max: number) => (value: string | number | undefined) =>\n  value != undefined ? `min(${max}px, ${normalizeCssValue(value)})` : value;\nconst HEIGHT_OFFSET = POINTER_HEIGHT + WITH_POINTER_BORDER_RADIUS;\nconst WIDTH_OFFSET = POINTER_WIDTH + WITH_POINTER_BORDER_RADIUS;\n\n/**\n * Ensures pointer is not offset too much or too little that would make the arrow appear\n * outside the tooltip boundary.\n */\nfunction limitPointerPositionStyles(\n  { width, height }: { width: number | undefined; height: number | undefined },\n  { top, left, right, bottom }: CSSProperties\n) {\n  const applyVerticalMinMax = compose(\n    height ? withMax(height - HEIGHT_OFFSET) : identity,\n    withMin(HEIGHT_OFFSET)\n  );\n  const applyHorizontalMinMax = compose(\n    width ? withMax(width - WIDTH_OFFSET) : identity,\n    withMin(WIDTH_OFFSET)\n  );\n  return {\n    top: applyVerticalMinMax(top),\n    bottom: applyVerticalMinMax(bottom),\n    left: applyHorizontalMinMax(left),\n    right: applyHorizontalMinMax(right),\n  };\n}\n\nconst getOffsetCssProp = (\n  side: TooltipPointerPosition[\"side\"],\n  invert?: boolean\n): \"top\" | \"bottom\" | \"left\" | \"right\" => {\n  if (side === \"top\" || side === \"bottom\") {\n    return invert ? \"right\" : \"left\";\n  }\n  return invert ? \"bottom\" : \"top\";\n};\n\nfunction pointerPositionToOffsetStyle({\n  side,\n  offset = \"50%\",\n}: TooltipPointerPosition): CSSProperties {\n  const { invert = false, value: offsetValue } =\n    typeof offset === \"object\" ? offset : { invert: false, value: offset };\n  return {\n    [getOffsetCssProp(side, invert)]: offsetValue,\n  };\n}\n\nexport function TooltipPointer({\n  side,\n  offset,\n  tooltipRef,\n}: {\n  side: TooltipPointerPosition[\"side\"];\n  offset:\n    | { type: \"calculated\"; value: CSSProperties }\n    | { type: \"specific\"; value: TooltipPointerPosition[\"offset\"] };\n  tooltipRef: RefObject<HTMLElement>;\n}) {\n  const [size, setSize] = useState<{\n    height: number | undefined;\n    width: number | undefined;\n  }>({ height: undefined, width: undefined });\n  useEffect(() => {\n    const { offsetHeight, offsetWidth } = tooltipRef.current || {};\n    if (offsetHeight != size?.height || offsetWidth != size?.width) {\n      setSize({ height: offsetHeight, width: offsetWidth });\n    }\n  });\n\n  return (\n    <StyledTooltipPointer\n      side={side}\n      style={limitPointerPositionStyles(\n        size,\n        offset.type === \"specific\"\n          ? pointerPositionToOffsetStyle({ side, offset: offset.value })\n          : offset.value\n      )}\n    />\n  );\n}\n","import React, { ForwardedRef, MutableRefObject, useContext } from \"react\";\nimport { AriaTooltipProps, useTooltip } from \"@react-aria/tooltip\";\nimport { useObjectRef } from \"@react-aria/utils\";\nimport { PositionAria } from \"@react-aria/overlays\";\nimport { css, styled } from \"@intellij-platform/core/styled\";\nimport { UnknownThemeProp } from \"@intellij-platform/core/Theme\";\nimport { WINDOW_SHADOW } from \"@intellij-platform/core/style-constants\";\nimport { TooltipContext } from \"./TooltipContext\";\nimport { TooltipPointer, TooltipPointerPosition } from \"./TooltipPointer\";\nimport {\n  tooltipBackground,\n  tooltipBorderColor,\n  WITH_POINTER_BORDER_RADIUS,\n} from \"./tooltip-styles\";\n\nexport interface TooltipProps extends Omit<AriaTooltipProps, \"isOpen\"> {\n  children: React.ReactNode;\n  multiline?: boolean;\n  className?: string;\n  /**\n   * Whether (and in what position) the arrow pointer should be shown.\n   * When using {@link TooltipTrigger} or {@link PositionedTooltipTrigger}, the position of the pointer is calculated\n   * based on the target element, and a boolean value to define whether the arrow should be shown or not would suffice.\n   *\n   * Tooltips with pointer have slight style difference.\n   * {@see https://www.figma.com/file/nfDfMAdV7j2fnQlpYNAOfP/IntelliJ-Platform-UI-Kit-(Community)?type=design&node-id=15-51&mode=design&t=7PplrxG8ZfXB4hIK-0}\n   *\n   * @example\n   * <Tooltip withPointer />\n   * // shows the pointer in the position controlled by {@link TooltipTrigger} or {@link PositionedTooltipTrigger}\n   * // If there is not `TooltipTrigger` or `PositionedTooltipTrigger`, the arrow is shown on top center by default.\n   *\n   * @example\n   * <Tooltip withPointer={{side: 'top', offset: 30}} />\n   * // shows the pointer on the top side, with horizontal offset of 30px from the left of tooltip, regardless\n   * // of whether `TooltipTrigger` or `PositionedTooltipTrigger` is used.\n   *\n   * @example\n   * <Tooltip withPointer={{side: 'left', offset: -30}} />\n   * // shows the pointer on the left side, with vertidcal offset of 30px from the bottom of the tooltip, regardless\n   * // of whether `TooltipTrigger` or `PositionedTooltipTrigger` is used.\n   */\n  withPointer?: boolean | TooltipPointerPosition;\n}\n\n// Providing default value for paddings, based on intellijlaf theme. In Intellij Platform, themes extend either\n// intellijlaf or darcula. Which means some properties can be omitted in the custom theme, relying on the values\n// in the base theme. This is not how theming works here, at the moment, and there are other similar issues, but\n// this is just a mitigation for one case, spacing in tooltip.\nexport const DEFAULT_TEXT_BORDER_INSETS = \"0.5rem 0.8125rem 0.625rem 0.625rem\";\nexport const DEFAULT_SMALL_TEXT_BORDER_INSETS =\n  \"0.375rem 0.75rem 0.4375rem 0.625rem\";\nconst StyledTooltip = styled.div<{ multiline?: boolean; hasPointer?: boolean }>`\n  box-sizing: content-box;\n  max-width: ${\n    /**\n     * Max width is meant to be set on the multiline description (which is not used in ActionTooltip which would\n     * be right according to [the specs](https://jetbrains.github.io/ui/controls/tooltip/#09)).\n     * But if set on `Tooltip.Description`, title and link can still make the tooltip grow more that the expected max\n     * width. So it makes more sense to set the max width on the container anyway. But since the value of the max width\n     * is meant to be for description we set the box-sizing to \"content-box\" to exclude container's padding in max-width\n     * calculation.\n     */\n    ({ theme, multiline }) =>\n      multiline\n        ? `${\n            theme.value<number>(\n              \"HelpTooltip.maxWidth\" as UnknownThemeProp<\"HelpTooltip.maxWidth\">\n            ) ?? 250\n          }px`\n        : null\n  };\n  white-space: ${({ multiline }) => (!multiline ? \"nowrap\" : null)};\n  display: inline-flex;\n  flex-direction: column;\n  gap: ${({ theme }) =>\n    theme.value<number>(\n      \"HelpToolTip.verticalGap\" as UnknownThemeProp<\"HelpToolTip.verticalGap\">\n    ) ?? 4}px;\n  background: ${tooltipBackground};\n  color: ${({ theme }) =>\n    theme.color(\"ToolTip.foreground\", !theme.dark ? \"#000\" : \"#bfbfbf\")};\n  padding: ${({ theme, multiline }) =>\n    multiline\n      ? theme.inset(\"HelpTooltip.defaultTextBorderInsets\") ||\n        DEFAULT_TEXT_BORDER_INSETS\n      : theme.inset(\"HelpTooltip.smallTextBorderInsets\") ||\n        DEFAULT_SMALL_TEXT_BORDER_INSETS};\n  line-height: 1.2;\n  border-style: solid;\n  border-width: ${({ theme, hasPointer }) =>\n    theme.value<boolean>(\"ToolTip.paintBorder\") || hasPointer ? \"1px\" : \"0px\"};\n  border-color: ${tooltipBorderColor};\n  ${WINDOW_SHADOW};\n  ${({ hasPointer }) =>\n    hasPointer &&\n    css`\n      position: relative; // needed for absolute positioning of the pointer\n      border-radius: ${WITH_POINTER_BORDER_RADIUS}px;\n    `}\n`;\n\nconst StyledShortcut = styled.kbd`\n  all: unset;\n  color: ${({ theme }) =>\n    theme.color(\n      \"ToolTip.shortcutForeground\",\n      !theme.dark ? \"#787878\" : \"#999999\"\n    )};\n`;\n\nconst StyledHeader = styled.div`\n  font-size: ${({ theme }) => theme.fontSizeDelta(\"HelpTooltip.fontSizeDelta\")};\n  display: flex;\n  gap: 0.5rem;\n`;\nconst StyledDescription = styled.div`\n  color: ${({ theme }) =>\n    theme.color(\n      \"Tooltip.infoForeground\" as UnknownThemeProp<\"Tooltip.infoForeground\">,\n      theme.commonColors.contextHelpForeground\n    )};\n  font-size: ${({ theme }) =>\n    theme.fontSizeDelta(\"HelpTooltip.descriptionSizeDelta\")};\n`;\n\nconst StyledLink = styled.div`\n  color: ${({ theme }) =>\n    theme.color(\n      \"ToolTip.linkForeground\" as UnknownThemeProp<\"ToolTip.linkForeground\">,\n      theme.commonColors.linkForegroundEnabled\n    )};\n  a,\n  [role=\"link\"] {\n    // Maybe target Link instead, without important. It didn't work as expected, in the first try tho.\n    color: inherit !important;\n  }\n`;\n\nexport const placementToPointerSide: Record<\n  PositionAria[\"placement\"],\n  TooltipPointerPosition[\"side\"]\n> = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"right\",\n  right: \"left\",\n  center: \"top\", // doesn't make sense :-?\n};\n/**\n * Implements the UI of a Tooltip. For tooltip to be shown for a trigger, on hover, use {@link TooltipTrigger}.\n * The following components can be used to compose the content of a tooltip.\n * - {@link Tooltip.Header}\n * - {@link Tooltip.Description}\n * - {@link Tooltip.Link}\n * - {@link Tooltip.Shortcut}\n * Prefer using higher-level components like {@link HelpTooltip}, {@link ActionHelpTooltip} or {@link ActionTooltip}.\n * that ensure different pieces of tooltip content follow the\n * [design system recommendation](https://jetbrains.github.io/ui/controls/tooltip)\n *\n *\n * ### Reference:\n * Tooltip, Tooltip.* and TooltipTrigger are corresponding to [HelpTooltip](https://github.com/JetBrains/intellij-community/blob/854daf45b47a6ea9da0348978608bfbfe998d99c/platform/platform-api/src/com/intellij/ide/HelpTooltip.java#L102)\n * in the original impl.\n */\nconst Tooltip = React.forwardRef(function Tooltip(\n  { children, multiline, withPointer, ...props }: TooltipProps,\n  forwardedRef: ForwardedRef<HTMLDivElement>\n): JSX.Element {\n  const ref: MutableRefObject<HTMLDivElement | null> =\n    useObjectRef(forwardedRef);\n  const {\n    state,\n    isInteractive,\n    pointerPositionStyle,\n    placement = \"bottom\",\n  } = useContext(TooltipContext) || {};\n  const { tooltipProps } = useTooltip(\n    props,\n    state\n      ? {\n          ...state,\n          // if the tooltip is not interactive, let it be closed even when it's hovered. That's the according to the reference impl.\n          open: isInteractive ? state?.open : () => {},\n        }\n      : state\n  );\n\n  const { side, offset } =\n    typeof withPointer === \"object\"\n      ? withPointer\n      : { side: placementToPointerSide[placement], offset: undefined };\n\n  return (\n    <StyledTooltip\n      hasPointer={Boolean(withPointer)}\n      multiline={multiline}\n      {...tooltipProps}\n      className={props.className}\n      ref={ref}\n    >\n      {withPointer && (\n        <TooltipPointer\n          tooltipRef={ref}\n          side={side}\n          offset={\n            offset || !pointerPositionStyle\n              ? { type: \"specific\", value: offset }\n              : { type: \"calculated\", value: pointerPositionStyle }\n          }\n        />\n      )}\n      {children}\n    </StyledTooltip>\n  );\n});\n\nconst _Tooltip = Object.assign(Tooltip, {\n  Header: StyledHeader,\n  Shortcut: StyledShortcut,\n  Description: StyledDescription,\n  Link: StyledLink,\n});\n\nexport { _Tooltip as Tooltip };\n","import { Theme } from \"@intellij-platform/core/Theme\";\n\nexport const WITH_POINTER_BORDER_RADIUS = 4;\nexport const tooltipBackground = ({ theme }: { theme: Theme }) =>\n  theme.color(\"ToolTip.background\", !theme.dark ? \"#f2f2f2\" : \"#3c3f41\");\nexport const tooltipBorderColor = ({ theme }: { theme: Theme }) =>\n  theme.color(\"ToolTip.borderColor\", !theme.dark ? \"#adadad\" : \"#636569\");\n","import React from \"react\";\nimport { Tooltip } from \"@intellij-platform/core/Tooltip/Tooltip\";\nimport { styled } from \"@intellij-platform/core/styled\";\n\nexport interface ValidationTooltipProps {\n  children: React.ReactNode;\n  /**\n   * @default error\n   */\n  type?: \"error\" | \"warning\";\n}\n\nconst StyledValidationTooltip = styled(Tooltip)`\n  box-shadow: none;\n  padding: 0.25rem 0.5rem; // from ComponentValidator class in the reference impl\n  max-width: ${({ theme }) =>\n    `${theme.value<number>(\"ValidationTooltip.maxWidth\")}px`};\n  background: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.errorBackground\")};\n  border: 1px solid\n    ${({ theme }) => theme.color(\"ValidationTooltip.errorBorderColor\")};\n`;\n\nconst StyledWarningValidationTooltip = styled(StyledValidationTooltip)`\n  background: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.warningBackground\")};\n  border-color: ${({ theme }) =>\n    theme.color(\"ValidationTooltip.warningBorderColor\")};\n`;\n\n/**\n * Tooltip to be used for validation error messages\n * @see https://jetbrains.github.io/ui/principles/validation_errors/\n */\nexport const ValidationTooltip = ({\n  type = \"error\",\n  children,\n}: ValidationTooltipProps): JSX.Element => {\n  const Component =\n    type === \"error\" ? StyledValidationTooltip : StyledWarningValidationTooltip;\n  return <Component multiline>{children}</Component>;\n};\n"],"names":[],"sourceRoot":""}