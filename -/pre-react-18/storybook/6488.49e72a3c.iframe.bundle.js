"use strict";(self.webpackChunk_intellij_platform_core=self.webpackChunk_intellij_platform_core||[]).push([[6488],{"./src/Theme/Color.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{I:()=>Color});const numberPattern="[0-9]{0,3}.?[0-9]*",parseComponent=(componentStr,index)=>componentStr?index<3?parseInt(componentStr):Math.round(255*Math.min(parseFloat(componentStr),1)):void 0,parseHexRgba=str=>str.match(/^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})?$/i)?.slice(1,5).map((i=>i?parseInt(i,16):void 0)),parseShorthandHex=str=>str.match(/^#?([0-9A-F])([0-9A-F])([0-9A-F])$/i)?.slice(1,4).map((i=>i?parseInt(i+i,16):void 0)),parseRgb=str=>str.match(new RegExp(`^rgb\\(\\s*(${numberPattern})\\s*,\\s*(${numberPattern})\\s*,\\s*(${numberPattern}\\s*)\\)$`))?.slice(1,5).map(parseComponent),parseRgba=str=>str.match(new RegExp(`^rgba\\(\\s*(${numberPattern})\\s*,\\s*(${numberPattern})\\s*,\\s*(${numberPattern})\\s*,\\s*(${numberPattern}\\s*)\\)$`))?.slice(1,5).map(parseComponent);class Color{r;g;b;a;static FACTOR=.7;constructor(rgba,g,b,a=255){let r;"string"==typeof rgba?[r=NaN,g=NaN,b=NaN,a=255]=(str=>{const result=[parseHexRgba,parseShorthandHex,parseRgb,parseRgba].reduce(((result,parse)=>result||parse(str)),void 0);return Array.isArray(result)&&result.slice(0,3).every((c=>Number.isInteger(c)))?result:null})(rgba)||[]:rgba instanceof Color?[r,g,b,a]=[rgba.r,rgba.g,rgba.b,rgba.a]:r=rgba,this.r=r,this.g=g,this.b=b,this.a=a<1?Math.round(255*a):a}isValid(){return Number.isInteger(this.r)&&Number.isInteger(this.g)&&Number.isInteger(this.b)&&Number.isInteger(this.a)}withTransparency(alpha){return new Color(this.r,this.g,this.b,alpha)}brighter(){let{r,g,b,a:alpha}=this;const int=Math.floor,FACTOR=Color.FACTOR;let i=int(1/(1-FACTOR));return 0==r&&0==g&&0==b?new Color(i,i,i,alpha):(r>0&&r<i&&(r=i),g>0&&g<i&&(g=i),b>0&&b<i&&(b=i),new Color(Math.min(int(r/FACTOR),255),Math.min(int(g/FACTOR),255),Math.min(int(b/FACTOR),255),alpha))}darker(){const FACTOR=Color.FACTOR,int=Math.floor;return new Color(Math.max(int(this.r*FACTOR),0),Math.max(int(this.g*FACTOR),0),Math.max(int(this.b*FACTOR),0),this.a)}static brighter(color){return new Color(color).brighter().toString()}blend(colorOrColorString){const color="string"==typeof colorOrColorString?new Color(colorOrColorString):colorOrColorString,getBlendedValue=component=>Math.round(color.a/255*color[component]+this.a/255*(1-color.a/255)*this[component]);return new Color(getBlendedValue("r"),getBlendedValue("g"),getBlendedValue("b"))}toString(){const toString=component=>Number.isNaN(component)?"":component.toString(16).padStart(2,"0");return`#${toString(this.r)}${toString(this.g)}${toString(this.b)}${255===this.a?"":toString(this.a)}`}}},"./src/ToolWindows/MovableToolWindowStripeProvider.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>MovableToolWindowStripeProvider,e:()=>useMovableStripeButtons});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("../../node_modules/react/index.js"),_utils_useLatest__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/utils/useLatest.ts");const MovableToolWindowStripeContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null),MovableToolWindowStripeProvider=({onMove,children})=>{const stripes=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}),[draggingRect,setDraggingRect]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),[draggingKey,setDraggingKey]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),[dropPosition,setDropPosition]=(0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),getDropPositionRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((()=>null)),moveStartLocationRef=(0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null),contextValue=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)((()=>({addStripe:(id,propsRef)=>(stripes.current[id]&&console.error(`multiple stripes with the same id "${id}`),stripes.current[id]=propsRef,()=>{delete stripes.current[id]}),startMove:(id,{from,key})=>{const stripe=stripes.current[id]?.current;if(!stripe)return;const{stripeElRef}=stripe,stripeElement=stripeElRef.current;setDraggingRect((key=>stripeElement.querySelector(`[data-key="${key}"]`).getBoundingClientRect())(key).toJSON()),setDraggingKey(key);const indexInMain=stripe.mainItems.findIndex((item=>stripe.getKey(item)===key)),indexInSplit=stripe.splitItems.findIndex((item=>stripe.getKey(item)===key));moveStartLocationRef.current={id,anchor:stripe.anchor,index:indexInMain>-1?indexInMain:indexInSplit,isSplit:indexInSplit>-1};const dropPositionGetters=Object.entries(stripes.current).map((([id,stripe])=>[id,stripe.current.createGetDropPosition(key)])),getDropPosition=draggedRect=>{for(const[id,getDropPosition]of dropPositionGetters){const dropPosition=getDropPosition(draggedRect);if(dropPosition)return{id,dropPosition}}return null};setDropPosition(getDropPosition(from)),getDropPositionRef.current=getDropPosition},move:({to})=>{setDropPosition(getDropPositionRef.current(to))},endMove:()=>{dropPosition&&draggingKey&&onMove({from:moveStartLocationRef.current,to:{anchor:dropPosition.id,index:dropPosition.dropPosition.index,isSplit:dropPosition.dropPosition.split}}),setDraggingKey(null),setDropPosition(null),setDraggingRect(null)},dropPosition,draggingRect,draggingKey})),[dropPosition,draggingKey,draggingRect]);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(MovableToolWindowStripeContext.Provider,{value:contextValue},children)};function useMovableStripeButtons(props){const id=props.anchor,context=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MovableToolWindowStripeContext),latestPropsRef=(0,_utils_useLatest__WEBPACK_IMPORTED_MODULE_1__.d)(props);(0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)((()=>{if(context)return context.addStripe(id,latestPropsRef)}),[context,id]);return{getProps:key=>({moveDisabled:!context,onMoveStart:({from})=>{context?.startMove?.(id,{from,key})},onMove:({to})=>{context?.move({to})},onMoveEnd:()=>{context?.endMove()}}),draggingRect:context?.draggingRect??null,dropPosition:context?.dropPosition?.id===id?context?.dropPosition.dropPosition:null,draggingKey:context?.draggingKey??null}}MovableToolWindowStripeProvider.__docgenInfo={description:"A wrapper component to render around `ToolWindowStripe`s to make their button movable. Stripe buttons then become\ndraggable and can be moved either within the same `ToolWindowStripe` or across different ones.\n@param onMove: called when a stripe button is moved from one anchor to another.\n@param children: child element tree, containing one or more ToolWindowStripe elements. No need to be direct children.",methods:[],displayName:"MovableToolWindowStripeProvider",props:{children:{required:!0,tsType:{name:"ReactReactNode",raw:"React.ReactNode"},description:""},onMove:{required:!0,tsType:{name:"signature",type:"function",raw:"(args: { from: StripeLocation<T>; to: StripeLocation<T> }) => void",signature:{arguments:[{type:{name:"signature",type:"object",raw:"{ from: StripeLocation<T>; to: StripeLocation<T> }",signature:{properties:[{key:"from",value:{name:"signature",type:"object",raw:"{\n  index: number;\n  anchor: Anchor;\n  isSplit: boolean;\n}",signature:{properties:[{key:"index",value:{name:"number",required:!0}},{key:"anchor",value:{name:"union",raw:'"left" | "right" | "top" | "bottom"',elements:[{name:"literal",value:'"left"'},{name:"literal",value:'"right"'},{name:"literal",value:'"top"'},{name:"literal",value:'"bottom"'}],required:!0}},{key:"isSplit",value:{name:"boolean",required:!0}}]},required:!0}},{key:"to",value:{name:"signature",type:"object",raw:"{\n  index: number;\n  anchor: Anchor;\n  isSplit: boolean;\n}",signature:{properties:[{key:"index",value:{name:"number",required:!0}},{key:"anchor",value:{name:"union",raw:'"left" | "right" | "top" | "bottom"',elements:[{name:"literal",value:'"left"'},{name:"literal",value:'"right"'},{name:"literal",value:'"top"'},{name:"literal",value:'"bottom"'}],required:!0}},{key:"isSplit",value:{name:"boolean",required:!0}}]},required:!0}}]}},name:"args"}],return:{name:"void"}}},description:""}}}},"./src/ToolWindows/StyledToolWindowStripe.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{K:()=>StyledSpacer,l:()=>StyledToolWindowStripe});var _StyledToolWindowStripeButton__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./src/ToolWindows/StyledToolWindowStripeButton.tsx"),_utils__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./src/ToolWindows/utils.ts"),styled_components__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("../../node_modules/styled-components/dist/styled-components.browser.esm.js"),_styled__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./src/styled.ts"),_Theme_Color__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./src/Theme/Color.ts");const minHeight=`calc(${_StyledToolWindowStripeButton__WEBPACK_IMPORTED_MODULE_0__.A6} + ${2*_StyledToolWindowStripeButton__WEBPACK_IMPORTED_MODULE_0__.Mk+1}px)`,StyledToolWindowStripe=_styled__WEBPACK_IMPORTED_MODULE_3__.zo.div`
  box-sizing: border-box;
  background: ${({theme,highlighted})=>highlighted?_Theme_Color__WEBPACK_IMPORTED_MODULE_4__.I.brighter(theme.commonColors.panelBackground):theme.commonColors.panelBackground};
  display: inline-flex;
  overflow: hidden;
  ${({anchor,theme})=>styled_components__WEBPACK_IMPORTED_MODULE_2__.iv`border-${(0,_utils__WEBPACK_IMPORTED_MODULE_1__.vo)(anchor)}: 1px solid ${theme.commonColors.contrastBorder}`};
  ${({anchor,preventCollapse})=>(0,_utils__WEBPACK_IMPORTED_MODULE_1__.m$)(anchor)?styled_components__WEBPACK_IMPORTED_MODULE_2__.iv`
        flex-direction: row;
        width: 100%;
        min-height: ${preventCollapse?minHeight:"fit-content"};
        ${_StyledToolWindowStripeButton__WEBPACK_IMPORTED_MODULE_0__.jz} {
          height: 1.25rem;
        }
      `:styled_components__WEBPACK_IMPORTED_MODULE_2__.iv`
        flex-direction: column;
        height: 100%;
        min-width: ${preventCollapse?minHeight:"fit-content"};
        ${_StyledToolWindowStripeButton__WEBPACK_IMPORTED_MODULE_0__.jz} {
          width: 1.25rem;
        }
      `}
`,StyledSpacer=_styled__WEBPACK_IMPORTED_MODULE_3__.zo.div`
  flex: 1;
`},"./src/ToolWindows/StyledToolWindowStripeButton.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A6:()=>STRIPE_BUTTON_LINE_HEIGHT,Mk:()=>STRIPE_BUTTON_CROSS_PADDING,jz:()=>StyledToolWindowStripeButton});var _Icon_StyledIconWrapper__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./src/Icon/StyledIconWrapper.tsx"),_styled__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./src/styled.ts"),styled_components__WEBPACK_IMPORTED_MODULE_1__=(__webpack_require__("../../node_modules/react/index.js"),__webpack_require__("../../node_modules/styled-components/dist/styled-components.browser.esm.js"));const STRIPE_BUTTON_CROSS_PADDING=2.5,STRIPE_BUTTON_LINE_HEIGHT="1rem",StyledToolWindowStripeButton=_styled__WEBPACK_IMPORTED_MODULE_3__.zo.span`
  box-sizing: border-box;
  display: flex; // to allow icon and text alignment by default;
  align-items: center;
  cursor: default;
  user-select: none;
  overflow: hidden;
  direction: ltr;
  flex-shrink: 0;
  font-size: 0.7rem;
  line-height: ${STRIPE_BUTTON_LINE_HEIGHT}; // absolute value seems to be problematic when the base font size is changed
  white-space: nowrap;
  color: ${({theme,active})=>active?theme.color("ToolWindow.Button.selectedForeground",theme.dark?"rgb(255,255,255)":"rgb(0,0,0)"):theme.color("*.foreground")};
  background: ${({theme,active})=>active?theme.color("ToolWindow.Button.selectedBackground",theme.dark?"rgba(15,15,15,.332)":"rgba(85,85,85,.332)"):void 0};

  ${({anchor})=>"horizontal"===("left"===anchor||"right"===anchor?"vertical":"horizontal")?styled_components__WEBPACK_IMPORTED_MODULE_1__.iv`
        padding: ${STRIPE_BUTTON_CROSS_PADDING}px 10px;
      `:styled_components__WEBPACK_IMPORTED_MODULE_1__.iv`
        padding: 10px ${STRIPE_BUTTON_CROSS_PADDING}px;
        writing-mode: vertical-lr;
        // writing-mode: sideways-lr is not supported anywhere other than FF, so, we need to rotate
        transform: ${"left"===anchor?"rotateZ(180deg)":void 0};

        // icons are not rotated like text in Intellij Platform implementation. It kind of makes sense.
        ${_Icon_StyledIconWrapper__WEBPACK_IMPORTED_MODULE_2__.M} {
          transform: rotate(180deg);
        }
      `}
  ${({active})=>!active&&styled_components__WEBPACK_IMPORTED_MODULE_1__.iv`
      &:hover {
        background: ${({theme})=>theme.color("ToolWindow.Button.hoverBackground",theme.dark?"rgba(15,15,15,.156)":"rgba(85,85,85,.156)")};
      }
    `};
`},"./src/ToolWindows/ToolWindowStripe.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{f:()=>ToolWindowStripe});var mergeProps=__webpack_require__("../../node_modules/@react-aria/utils/dist/mergeProps.mjs"),react=__webpack_require__("../../node_modules/react/index.js"),utils=__webpack_require__("./src/ToolWindows/utils.ts");const createGetDropPosition=({anchor,stripeElement,splitItems,mainItems,getItemRect,getKey})=>{const getStripeRect=()=>stripeElement.getBoundingClientRect(),start=rect=>(0,utils.m$)(anchor)?rect.left:rect.top,end=rect=>(0,utils.m$)(anchor)?rect.right:rect.bottom,getDropPositions=(items,split=!1)=>{const getRef=split?end:start;return 0===items.length?[{index:0,split,score:draggingRect=>Math.abs(getRef(draggingRect)-getRef(getStripeRect()))}]:items.flatMap(((item,index)=>{const key=getKey(item);return[{index,split,relative:{key,placement:"before"},score:draggingRect=>Math.abs(getRef(draggingRect)-keyToOffsets[key].start)},{index:index+1,split,relative:{key,placement:"after"},score:draggingRect=>Math.abs(getRef(draggingRect)-keyToOffsets[key].end)}]}))},keyToOffsets=(items=>{const keyToOffsets={};return items.forEach((item=>{const key=getKey(item),boundingRect=getItemRect(key);keyToOffsets[key]={start:start(boundingRect),end:end(boundingRect)}})),keyToOffsets})([...mainItems,...splitItems]),dropPositions=[...getDropPositions(mainItems),...getDropPositions(splitItems,!0)];let lastDropPosition=null;return draggingRect=>{if(!(draggingRect=>{const stripeRect=getStripeRect();return draggingRect.right>stripeRect.left-stripeRect.width&&draggingRect.left<stripeRect.right&&draggingRect.bottom>stripeRect.top-stripeRect.height&&draggingRect.top<stripeRect.bottom})(draggingRect))return null;const result=dropPositions.reduce(((bestMatch,candidate)=>{const score=candidate.score(draggingRect);return!bestMatch||score<bestMatch.score?{...candidate,score}:bestMatch}),null);return result?(result.split===lastDropPosition?.split&&result.index===lastDropPosition?.index||(lastDropPosition=result),lastDropPosition):null}};var MovableToolWindowStripeProvider=__webpack_require__("./src/ToolWindows/MovableToolWindowStripeProvider.tsx"),StyledToolWindowStripe=__webpack_require__("./src/ToolWindows/StyledToolWindowStripe.tsx"),StyledToolWindowStripeButton=__webpack_require__("./src/ToolWindows/StyledToolWindowStripeButton.tsx"),useMove=__webpack_require__("./src/utils/interaction-utils/useMove.tsx"),Color=__webpack_require__("./src/Theme/Color.ts");function useElementMove({ref,onMoveStart,onMove,onMoveEnd,ghost:ghostOption,...otherOptions}){return(0,useMove.r)({...otherOptions,onMoveStart:()=>{const element=ref.current;let ghost=null;if(!element)throw new Error("Movement started but ref value is null. Make sure the passed ref is applied on the same element that other props are.");const updateGhostPosition=rect=>{ghost&&(ghost.style.left=`${rect.left}px`,ghost.style.top=`${rect.top}px`)},from=element.getBoundingClientRect();if(ghostOption){const defaultGhost=function createDefaultGhost(element){const ghost=element.cloneNode(!0);return ghost.style.backgroundColor=function findEffectiveBackgroundColor(element){let elem=element,colors=[];for(;null!=elem;){const computedBackground=getComputedStyle(elem).backgroundColor;if(computedBackground){const color=new Color.I(computedBackground);if(colors.unshift(color),255===color.a)break}elem=elem.parentElement}return colors.reduce(((resultColor,nextColor)=>resultColor?resultColor.blend(nextColor):nextColor),null)?.toString()||""}(element),ghost}(element);ghost="function"==typeof ghostOption&&ghostOption(defaultGhost)||defaultGhost,ghost.style.position="fixed",document.body.append(ghost),updateGhostPosition(from)}return{ghost,from,updateGhostPosition,startState:onMoveStart({from})}},onMove:({movement,startState:{from,updateGhostPosition,startState}})=>{const to={left:from.left+movement.x,right:from.right+movement.x,top:from.top+movement.y,bottom:from.bottom+movement.y,height:from.height,width:from.width};updateGhostPosition(to),onMove({from,to,movement,startState})},onMoveEnd:({startState:{ghost,startState}})=>{ghost?.remove(),onMoveEnd?.({startState})}})}function ToolWindowStripe({anchor,items:mainItems,renderItem:render,splitItems=[],selectedKeys=[],onItemPress,getKey}){const containerRef=(0,react.useRef)(null),{getProps,draggingRect,draggingKey,dropPosition}=(0,MovableToolWindowStripeProvider.e)({stripeElRef:containerRef,getKey,anchor,mainItems,splitItems,createGetDropPosition:key=>{const isNotCurrentItem=anItem=>getKey(anItem)!==key,stripeElement=containerRef.current;return createGetDropPosition({stripeElement,mainItems:mainItems.filter(isNotCurrentItem),splitItems:splitItems.filter(isNotCurrentItem),getKey,anchor,getItemRect:key=>stripeElement.querySelector(`[data-key="${key}"]`).getBoundingClientRect()})}}),highlighted=null!=dropPosition&&null!=draggingKey&&[...mainItems,...splitItems].every((item=>getKey(item)!==draggingKey)),renderItem=item=>{const key=getKey(item);return react.createElement(ToolWindowStripeButton,{anchor,key,"data-key":key,style:{...getStripeButtonStyles({key,dropPosition,anchor,draggingRect,draggingKey})},...getProps(key),active:selectedKeys.includes(key),onPress:()=>onItemPress?.(key)},render(item))};return react.createElement(react.Fragment,null,react.createElement(StyledToolWindowStripe.l,{anchor,preventCollapse:Boolean(dropPosition),highlighted,ref:containerRef},mainItems.map(renderItem),react.createElement(StyledToolWindowStripe.K,null),splitItems.map(renderItem)))}function getStripeButtonStyles({anchor,key,dropPosition,draggingRect,draggingKey}){const styles={};if(dropPosition?.relative?.key===key&&draggingRect){const marginValue=(0,utils.m$)(anchor)?draggingRect.width:draggingRect.height;(0,utils.m$)(anchor)?styles["before"===dropPosition.relative.placement?"marginLeft":"marginRight"]=marginValue:styles["before"===dropPosition.relative.placement?"marginTop":"marginBottom"]=marginValue}return key===draggingKey&&(styles.display="none"),styles}function ToolWindowStripeButton({children,anchor,onMoveStart,onMove,onMoveEnd,onPress,moveDisabled,...otherProps}){const ref=(0,react.useRef)(null),{pressProps}={pressProps:{onPointerUp:onPress,onMouseDown:e=>{e.preventDefault()}}},props=useElementMove({ref,disabled:moveDisabled,dragThreshold:7,ghost:!0,onMoveStart,onMove,onMoveEnd});return react.createElement(StyledToolWindowStripeButton.jz,{anchor,...(0,mergeProps.d)(otherProps,pressProps,props),ref},children)}ToolWindowStripe.__docgenInfo={description:"TODO: refactor to remove the key based interface.",methods:[],displayName:"ToolWindowStripe",props:{anchor:{required:!0,tsType:{name:"union",raw:'"left" | "right" | "top" | "bottom"',elements:[{name:"literal",value:'"left"'},{name:"literal",value:'"right"'},{name:"literal",value:'"top"'},{name:"literal",value:'"bottom"'}]},description:""},items:{required:!0,tsType:{name:"Array",elements:[{name:"T"}],raw:"T[]"},description:""},splitItems:{required:!1,tsType:{name:"Array",elements:[{name:"T"}],raw:"T[]"},description:"",defaultValue:{value:"[]",computed:!1}},getKey:{required:!0,tsType:{name:"signature",type:"function",raw:"(item: T) => Key",signature:{arguments:[{type:{name:"T"},name:"item"}],return:{name:"Key"}}},description:""},renderItem:{required:!0,tsType:{name:"signature",type:"function",raw:"(item: T) => React.ReactNode",signature:{arguments:[{type:{name:"T"},name:"item"}],return:{name:"ReactReactNode",raw:"React.ReactNode"}}},description:""},selectedKeys:{required:!1,tsType:{name:"Array",elements:[{name:"Key"}],raw:"Key[]"},description:"",defaultValue:{value:"[]",computed:!1}},onItemPress:{required:!1,tsType:{name:"signature",type:"function",raw:"(key: Key) => void",signature:{arguments:[{type:{name:"Key"},name:"key"}],return:{name:"void"}}},description:""}}}},"./src/ToolWindows/utils.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Ss:()=>getAnchorOrientation,m$:()=>isHorizontalToolWindow,vo:()=>theOtherSide});const getAnchorOrientation=anchor=>isHorizontalToolWindow(anchor)?"horizontal":"vertical",isHorizontalToolWindow=anchor=>"top"===anchor||"bottom"===anchor,theOtherSide=anchor=>({left:"right",right:"left",top:"bottom",bottom:"top"}[anchor])}}]);
//# sourceMappingURL=6488.49e72a3c.iframe.bundle.js.map