"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["947"],{84744:function(e,t,i){i.r(t),i.d(t,{default:()=>h,frontMatter:()=>a,metadata:()=>n,assets:()=>c,toc:()=>l,contentTitle:()=>r});var n=JSON.parse('{"id":"guides/Collections","title":"Collections","description":"A good number of components such as List, Tree, Menu, Tabs, etc. display a collection of items.","source":"@site/docs/guides/Collections.mdx","sourceDirName":"guides","slug":"/guides/Collections","permalink":"/jui/-/post-push/docs/guides/Collections","draft":false,"unlisted":false,"editUrl":"https://github.com/alirezamirian/jui/edit/master/packages/website/docs/guides/Collections.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Actions","permalink":"/jui/-/post-push/docs/guides/ActionSystem"},"next":{"title":"AlertDialog","permalink":"/jui/-/post-push/docs/components/AlertDialog"}}'),s=i("52322"),o=i("22840");let a={},r="Collections",c={},l=[{value:"Rendering optimization caveat",id:"rendering-optimization-caveat",level:2},{value:"Using context",id:"using-context",level:3},{value:"Wrapping items with extra state",id:"wrapping-items-with-extra-state",level:3},{value:"Disabling or limiting cache",id:"disabling-or-limiting-cache",level:3}];function d(e){let t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"collections",children:"Collections"})}),"\n",(0,s.jsxs)(t.p,{children:["A good number of components such as List, Tree, Menu, Tabs, etc. display a collection of items.\n",(0,s.jsx)(t.a,{href:"https://react-spectrum.adobe.com/react-stately/collections.html",children:"@react-stately/collections"})," is used for all of them\nto provide a uniform and flexible API that would allow for both static jsx-based or dynamic source of items."]}),"\n",(0,s.jsx)(t.h2,{id:"rendering-optimization-caveat",children:"Rendering optimization caveat"}),"\n",(0,s.jsxs)(t.p,{children:["When the API for dynamic items (",(0,s.jsx)(t.code,{children:"items"})," prop and a render function as ",(0,s.jsx)(t.code,{children:"children"}),") is used, the render result for each\nitem ",(0,s.jsx)(t.a,{href:"https://react-spectrum.adobe.com/react-stately/collections.html#why-not-array-map",children:"is subject to caching"})," based\non the item object. It's important to understand this assumption that the rendering should only depend on the item, and\nnot any other piece of state, for example, from the closure."]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"The item renderer function should be a pure function that relies exclusively on its single argument: the item object."})}),"\n",(0,s.jsx)(t.p,{children:"However, in certain scenarios, you might need to render UI elements based on factors other than the item object. Here are a few ways to achieve this:"}),"\n",(0,s.jsx)(t.h3,{id:"using-context",children:"Using context"}),"\n",(0,s.jsx)(t.p,{children:"TODO (This is particularly useful for components implementing virtual rendering, where only a limited number of items are mounted at a time, and changes to additional state should affect only those without rebuilding the entire collection)."}),"\n",(0,s.jsx)(t.h3,{id:"wrapping-items-with-extra-state",children:"Wrapping items with extra state"}),"\n",(0,s.jsx)(t.p,{children:"TODO"}),"\n",(0,s.jsx)(t.h3,{id:"disabling-or-limiting-cache",children:"Disabling or limiting cache"}),"\n",(0,s.jsxs)(t.p,{children:["For components that support it, you can control caching by setting the ",(0,s.jsx)(t.code,{children:"cacheInvalidation"})," prop. Passing ",(0,s.jsx)(t.code,{children:"true"})," to this prop will disable caching entirely, but it may significantly reduce performance for large collections. In a performance test on a ",(0,s.jsx)(t.a,{href:"../components/Tree",children:"Tree"})," with 400 elements, disabling the cache resulted in a ~10x slower rendering."]}),"\n",(0,s.jsx)(t.p,{children:"A middle-ground approach is to pass an array of cache invalidators instead of completely turning off the cache:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"<Tree cacheInvalidation={{ invalidators: [nestedSelection] }}>...</Tree>\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This configuration will only invalidate the cache when ",(0,s.jsx)(t.code,{children:"nestedSelection"})," changes."]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);
//# sourceMappingURL=4d0df159.c4bb1683.js.map